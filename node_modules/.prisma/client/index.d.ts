
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Usuario
 * 
 */
export type Usuario = $Result.DefaultSelection<Prisma.$UsuarioPayload>
/**
 * Model Rol
 * 
 */
export type Rol = $Result.DefaultSelection<Prisma.$RolPayload>
/**
 * Model Permiso
 * 
 */
export type Permiso = $Result.DefaultSelection<Prisma.$PermisoPayload>
/**
 * Model Rol_permiso
 * 
 */
export type Rol_permiso = $Result.DefaultSelection<Prisma.$Rol_permisoPayload>
/**
 * Model Competidor
 * 
 */
export type Competidor = $Result.DefaultSelection<Prisma.$CompetidorPayload>
/**
 * Model Tutor
 * 
 */
export type Tutor = $Result.DefaultSelection<Prisma.$TutorPayload>
/**
 * Model Departamento
 * 
 */
export type Departamento = $Result.DefaultSelection<Prisma.$DepartamentoPayload>
/**
 * Model Provincia
 * 
 */
export type Provincia = $Result.DefaultSelection<Prisma.$ProvinciaPayload>
/**
 * Model Colegio
 * 
 */
export type Colegio = $Result.DefaultSelection<Prisma.$ColegioPayload>
/**
 * Model Convocatoria
 * 
 */
export type Convocatoria = $Result.DefaultSelection<Prisma.$ConvocatoriaPayload>
/**
 * Model Area
 * 
 */
export type Area = $Result.DefaultSelection<Prisma.$AreaPayload>
/**
 * Model Categoria
 * 
 */
export type Categoria = $Result.DefaultSelection<Prisma.$CategoriaPayload>
/**
 * Model Grado
 * 
 */
export type Grado = $Result.DefaultSelection<Prisma.$GradoPayload>
/**
 * Model Pago
 * 
 */
export type Pago = $Result.DefaultSelection<Prisma.$PagoPayload>
/**
 * Model Area_convocatoria
 * 
 */
export type Area_convocatoria = $Result.DefaultSelection<Prisma.$Area_convocatoriaPayload>
/**
 * Model Categoria_area
 * 
 */
export type Categoria_area = $Result.DefaultSelection<Prisma.$Categoria_areaPayload>
/**
 * Model Inscripcion_tutor
 * 
 */
export type Inscripcion_tutor = $Result.DefaultSelection<Prisma.$Inscripcion_tutorPayload>
/**
 * Model Metodo_pago
 * 
 */
export type Metodo_pago = $Result.DefaultSelection<Prisma.$Metodo_pagoPayload>
/**
 * Model estado_convocatoria
 * 
 */
export type estado_convocatoria = $Result.DefaultSelection<Prisma.$estado_convocatoriaPayload>
/**
 * Model Inscripcion
 * 
 */
export type Inscripcion = $Result.DefaultSelection<Prisma.$InscripcionPayload>
/**
 * Model Nivel
 * 
 */
export type Nivel = $Result.DefaultSelection<Prisma.$NivelPayload>
/**
 * Model Notificacion
 * 
 */
export type Notificacion = $Result.DefaultSelection<Prisma.$NotificacionPayload>
/**
 * Model Motivo_rechazo
 * 
 */
export type Motivo_rechazo = $Result.DefaultSelection<Prisma.$Motivo_rechazoPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Usuarios
 * const usuarios = await prisma.usuario.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Usuarios
   * const usuarios = await prisma.usuario.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.usuario`: Exposes CRUD operations for the **Usuario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuarios
    * const usuarios = await prisma.usuario.findMany()
    * ```
    */
  get usuario(): Prisma.UsuarioDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rol`: Exposes CRUD operations for the **Rol** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rols
    * const rols = await prisma.rol.findMany()
    * ```
    */
  get rol(): Prisma.RolDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.permiso`: Exposes CRUD operations for the **Permiso** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permisos
    * const permisos = await prisma.permiso.findMany()
    * ```
    */
  get permiso(): Prisma.PermisoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rol_permiso`: Exposes CRUD operations for the **Rol_permiso** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rol_permisos
    * const rol_permisos = await prisma.rol_permiso.findMany()
    * ```
    */
  get rol_permiso(): Prisma.Rol_permisoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.competidor`: Exposes CRUD operations for the **Competidor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Competidors
    * const competidors = await prisma.competidor.findMany()
    * ```
    */
  get competidor(): Prisma.CompetidorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tutor`: Exposes CRUD operations for the **Tutor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tutors
    * const tutors = await prisma.tutor.findMany()
    * ```
    */
  get tutor(): Prisma.TutorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.departamento`: Exposes CRUD operations for the **Departamento** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Departamentos
    * const departamentos = await prisma.departamento.findMany()
    * ```
    */
  get departamento(): Prisma.DepartamentoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.provincia`: Exposes CRUD operations for the **Provincia** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Provincias
    * const provincias = await prisma.provincia.findMany()
    * ```
    */
  get provincia(): Prisma.ProvinciaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.colegio`: Exposes CRUD operations for the **Colegio** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Colegios
    * const colegios = await prisma.colegio.findMany()
    * ```
    */
  get colegio(): Prisma.ColegioDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.convocatoria`: Exposes CRUD operations for the **Convocatoria** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Convocatorias
    * const convocatorias = await prisma.convocatoria.findMany()
    * ```
    */
  get convocatoria(): Prisma.ConvocatoriaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.area`: Exposes CRUD operations for the **Area** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Areas
    * const areas = await prisma.area.findMany()
    * ```
    */
  get area(): Prisma.AreaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.categoria`: Exposes CRUD operations for the **Categoria** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categorias
    * const categorias = await prisma.categoria.findMany()
    * ```
    */
  get categoria(): Prisma.CategoriaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.grado`: Exposes CRUD operations for the **Grado** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Grados
    * const grados = await prisma.grado.findMany()
    * ```
    */
  get grado(): Prisma.GradoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pago`: Exposes CRUD operations for the **Pago** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pagos
    * const pagos = await prisma.pago.findMany()
    * ```
    */
  get pago(): Prisma.PagoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.area_convocatoria`: Exposes CRUD operations for the **Area_convocatoria** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Area_convocatorias
    * const area_convocatorias = await prisma.area_convocatoria.findMany()
    * ```
    */
  get area_convocatoria(): Prisma.Area_convocatoriaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.categoria_area`: Exposes CRUD operations for the **Categoria_area** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categoria_areas
    * const categoria_areas = await prisma.categoria_area.findMany()
    * ```
    */
  get categoria_area(): Prisma.Categoria_areaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inscripcion_tutor`: Exposes CRUD operations for the **Inscripcion_tutor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inscripcion_tutors
    * const inscripcion_tutors = await prisma.inscripcion_tutor.findMany()
    * ```
    */
  get inscripcion_tutor(): Prisma.Inscripcion_tutorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.metodo_pago`: Exposes CRUD operations for the **Metodo_pago** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Metodo_pagos
    * const metodo_pagos = await prisma.metodo_pago.findMany()
    * ```
    */
  get metodo_pago(): Prisma.Metodo_pagoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.estado_convocatoria`: Exposes CRUD operations for the **estado_convocatoria** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Estado_convocatorias
    * const estado_convocatorias = await prisma.estado_convocatoria.findMany()
    * ```
    */
  get estado_convocatoria(): Prisma.estado_convocatoriaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inscripcion`: Exposes CRUD operations for the **Inscripcion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inscripcions
    * const inscripcions = await prisma.inscripcion.findMany()
    * ```
    */
  get inscripcion(): Prisma.InscripcionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.nivel`: Exposes CRUD operations for the **Nivel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Nivels
    * const nivels = await prisma.nivel.findMany()
    * ```
    */
  get nivel(): Prisma.NivelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notificacion`: Exposes CRUD operations for the **Notificacion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notificacions
    * const notificacions = await prisma.notificacion.findMany()
    * ```
    */
  get notificacion(): Prisma.NotificacionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.motivo_rechazo`: Exposes CRUD operations for the **Motivo_rechazo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Motivo_rechazos
    * const motivo_rechazos = await prisma.motivo_rechazo.findMany()
    * ```
    */
  get motivo_rechazo(): Prisma.Motivo_rechazoDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Usuario: 'Usuario',
    Rol: 'Rol',
    Permiso: 'Permiso',
    Rol_permiso: 'Rol_permiso',
    Competidor: 'Competidor',
    Tutor: 'Tutor',
    Departamento: 'Departamento',
    Provincia: 'Provincia',
    Colegio: 'Colegio',
    Convocatoria: 'Convocatoria',
    Area: 'Area',
    Categoria: 'Categoria',
    Grado: 'Grado',
    Pago: 'Pago',
    Area_convocatoria: 'Area_convocatoria',
    Categoria_area: 'Categoria_area',
    Inscripcion_tutor: 'Inscripcion_tutor',
    Metodo_pago: 'Metodo_pago',
    estado_convocatoria: 'estado_convocatoria',
    Inscripcion: 'Inscripcion',
    Nivel: 'Nivel',
    Notificacion: 'Notificacion',
    Motivo_rechazo: 'Motivo_rechazo'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "usuario" | "rol" | "permiso" | "rol_permiso" | "competidor" | "tutor" | "departamento" | "provincia" | "colegio" | "convocatoria" | "area" | "categoria" | "grado" | "pago" | "area_convocatoria" | "categoria_area" | "inscripcion_tutor" | "metodo_pago" | "estado_convocatoria" | "inscripcion" | "nivel" | "notificacion" | "motivo_rechazo"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Usuario: {
        payload: Prisma.$UsuarioPayload<ExtArgs>
        fields: Prisma.UsuarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsuarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsuarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          findFirst: {
            args: Prisma.UsuarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsuarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          findMany: {
            args: Prisma.UsuarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>[]
          }
          create: {
            args: Prisma.UsuarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          createMany: {
            args: Prisma.UsuarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UsuarioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>[]
          }
          delete: {
            args: Prisma.UsuarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          update: {
            args: Prisma.UsuarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          deleteMany: {
            args: Prisma.UsuarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsuarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UsuarioUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>[]
          }
          upsert: {
            args: Prisma.UsuarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          aggregate: {
            args: Prisma.UsuarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsuario>
          }
          groupBy: {
            args: Prisma.UsuarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsuarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsuarioCountArgs<ExtArgs>
            result: $Utils.Optional<UsuarioCountAggregateOutputType> | number
          }
        }
      }
      Rol: {
        payload: Prisma.$RolPayload<ExtArgs>
        fields: Prisma.RolFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RolFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RolFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPayload>
          }
          findFirst: {
            args: Prisma.RolFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RolFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPayload>
          }
          findMany: {
            args: Prisma.RolFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPayload>[]
          }
          create: {
            args: Prisma.RolCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPayload>
          }
          createMany: {
            args: Prisma.RolCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RolCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPayload>[]
          }
          delete: {
            args: Prisma.RolDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPayload>
          }
          update: {
            args: Prisma.RolUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPayload>
          }
          deleteMany: {
            args: Prisma.RolDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RolUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RolUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPayload>[]
          }
          upsert: {
            args: Prisma.RolUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPayload>
          }
          aggregate: {
            args: Prisma.RolAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRol>
          }
          groupBy: {
            args: Prisma.RolGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolGroupByOutputType>[]
          }
          count: {
            args: Prisma.RolCountArgs<ExtArgs>
            result: $Utils.Optional<RolCountAggregateOutputType> | number
          }
        }
      }
      Permiso: {
        payload: Prisma.$PermisoPayload<ExtArgs>
        fields: Prisma.PermisoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PermisoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermisoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PermisoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermisoPayload>
          }
          findFirst: {
            args: Prisma.PermisoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermisoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PermisoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermisoPayload>
          }
          findMany: {
            args: Prisma.PermisoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermisoPayload>[]
          }
          create: {
            args: Prisma.PermisoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermisoPayload>
          }
          createMany: {
            args: Prisma.PermisoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PermisoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermisoPayload>[]
          }
          delete: {
            args: Prisma.PermisoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermisoPayload>
          }
          update: {
            args: Prisma.PermisoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermisoPayload>
          }
          deleteMany: {
            args: Prisma.PermisoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PermisoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PermisoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermisoPayload>[]
          }
          upsert: {
            args: Prisma.PermisoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermisoPayload>
          }
          aggregate: {
            args: Prisma.PermisoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePermiso>
          }
          groupBy: {
            args: Prisma.PermisoGroupByArgs<ExtArgs>
            result: $Utils.Optional<PermisoGroupByOutputType>[]
          }
          count: {
            args: Prisma.PermisoCountArgs<ExtArgs>
            result: $Utils.Optional<PermisoCountAggregateOutputType> | number
          }
        }
      }
      Rol_permiso: {
        payload: Prisma.$Rol_permisoPayload<ExtArgs>
        fields: Prisma.Rol_permisoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Rol_permisoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Rol_permisoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Rol_permisoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Rol_permisoPayload>
          }
          findFirst: {
            args: Prisma.Rol_permisoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Rol_permisoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Rol_permisoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Rol_permisoPayload>
          }
          findMany: {
            args: Prisma.Rol_permisoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Rol_permisoPayload>[]
          }
          create: {
            args: Prisma.Rol_permisoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Rol_permisoPayload>
          }
          createMany: {
            args: Prisma.Rol_permisoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Rol_permisoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Rol_permisoPayload>[]
          }
          delete: {
            args: Prisma.Rol_permisoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Rol_permisoPayload>
          }
          update: {
            args: Prisma.Rol_permisoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Rol_permisoPayload>
          }
          deleteMany: {
            args: Prisma.Rol_permisoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Rol_permisoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.Rol_permisoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Rol_permisoPayload>[]
          }
          upsert: {
            args: Prisma.Rol_permisoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Rol_permisoPayload>
          }
          aggregate: {
            args: Prisma.Rol_permisoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRol_permiso>
          }
          groupBy: {
            args: Prisma.Rol_permisoGroupByArgs<ExtArgs>
            result: $Utils.Optional<Rol_permisoGroupByOutputType>[]
          }
          count: {
            args: Prisma.Rol_permisoCountArgs<ExtArgs>
            result: $Utils.Optional<Rol_permisoCountAggregateOutputType> | number
          }
        }
      }
      Competidor: {
        payload: Prisma.$CompetidorPayload<ExtArgs>
        fields: Prisma.CompetidorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompetidorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompetidorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompetidorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompetidorPayload>
          }
          findFirst: {
            args: Prisma.CompetidorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompetidorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompetidorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompetidorPayload>
          }
          findMany: {
            args: Prisma.CompetidorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompetidorPayload>[]
          }
          create: {
            args: Prisma.CompetidorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompetidorPayload>
          }
          createMany: {
            args: Prisma.CompetidorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompetidorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompetidorPayload>[]
          }
          delete: {
            args: Prisma.CompetidorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompetidorPayload>
          }
          update: {
            args: Prisma.CompetidorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompetidorPayload>
          }
          deleteMany: {
            args: Prisma.CompetidorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompetidorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CompetidorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompetidorPayload>[]
          }
          upsert: {
            args: Prisma.CompetidorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompetidorPayload>
          }
          aggregate: {
            args: Prisma.CompetidorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompetidor>
          }
          groupBy: {
            args: Prisma.CompetidorGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompetidorGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompetidorCountArgs<ExtArgs>
            result: $Utils.Optional<CompetidorCountAggregateOutputType> | number
          }
        }
      }
      Tutor: {
        payload: Prisma.$TutorPayload<ExtArgs>
        fields: Prisma.TutorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TutorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TutorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutorPayload>
          }
          findFirst: {
            args: Prisma.TutorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TutorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutorPayload>
          }
          findMany: {
            args: Prisma.TutorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutorPayload>[]
          }
          create: {
            args: Prisma.TutorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutorPayload>
          }
          createMany: {
            args: Prisma.TutorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TutorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutorPayload>[]
          }
          delete: {
            args: Prisma.TutorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutorPayload>
          }
          update: {
            args: Prisma.TutorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutorPayload>
          }
          deleteMany: {
            args: Prisma.TutorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TutorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TutorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutorPayload>[]
          }
          upsert: {
            args: Prisma.TutorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutorPayload>
          }
          aggregate: {
            args: Prisma.TutorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTutor>
          }
          groupBy: {
            args: Prisma.TutorGroupByArgs<ExtArgs>
            result: $Utils.Optional<TutorGroupByOutputType>[]
          }
          count: {
            args: Prisma.TutorCountArgs<ExtArgs>
            result: $Utils.Optional<TutorCountAggregateOutputType> | number
          }
        }
      }
      Departamento: {
        payload: Prisma.$DepartamentoPayload<ExtArgs>
        fields: Prisma.DepartamentoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DepartamentoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartamentoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DepartamentoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartamentoPayload>
          }
          findFirst: {
            args: Prisma.DepartamentoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartamentoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DepartamentoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartamentoPayload>
          }
          findMany: {
            args: Prisma.DepartamentoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartamentoPayload>[]
          }
          create: {
            args: Prisma.DepartamentoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartamentoPayload>
          }
          createMany: {
            args: Prisma.DepartamentoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DepartamentoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartamentoPayload>[]
          }
          delete: {
            args: Prisma.DepartamentoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartamentoPayload>
          }
          update: {
            args: Prisma.DepartamentoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartamentoPayload>
          }
          deleteMany: {
            args: Prisma.DepartamentoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DepartamentoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DepartamentoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartamentoPayload>[]
          }
          upsert: {
            args: Prisma.DepartamentoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartamentoPayload>
          }
          aggregate: {
            args: Prisma.DepartamentoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDepartamento>
          }
          groupBy: {
            args: Prisma.DepartamentoGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepartamentoGroupByOutputType>[]
          }
          count: {
            args: Prisma.DepartamentoCountArgs<ExtArgs>
            result: $Utils.Optional<DepartamentoCountAggregateOutputType> | number
          }
        }
      }
      Provincia: {
        payload: Prisma.$ProvinciaPayload<ExtArgs>
        fields: Prisma.ProvinciaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProvinciaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvinciaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProvinciaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvinciaPayload>
          }
          findFirst: {
            args: Prisma.ProvinciaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvinciaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProvinciaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvinciaPayload>
          }
          findMany: {
            args: Prisma.ProvinciaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvinciaPayload>[]
          }
          create: {
            args: Prisma.ProvinciaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvinciaPayload>
          }
          createMany: {
            args: Prisma.ProvinciaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProvinciaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvinciaPayload>[]
          }
          delete: {
            args: Prisma.ProvinciaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvinciaPayload>
          }
          update: {
            args: Prisma.ProvinciaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvinciaPayload>
          }
          deleteMany: {
            args: Prisma.ProvinciaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProvinciaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProvinciaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvinciaPayload>[]
          }
          upsert: {
            args: Prisma.ProvinciaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvinciaPayload>
          }
          aggregate: {
            args: Prisma.ProvinciaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProvincia>
          }
          groupBy: {
            args: Prisma.ProvinciaGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProvinciaGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProvinciaCountArgs<ExtArgs>
            result: $Utils.Optional<ProvinciaCountAggregateOutputType> | number
          }
        }
      }
      Colegio: {
        payload: Prisma.$ColegioPayload<ExtArgs>
        fields: Prisma.ColegioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ColegioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColegioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ColegioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColegioPayload>
          }
          findFirst: {
            args: Prisma.ColegioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColegioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ColegioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColegioPayload>
          }
          findMany: {
            args: Prisma.ColegioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColegioPayload>[]
          }
          create: {
            args: Prisma.ColegioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColegioPayload>
          }
          createMany: {
            args: Prisma.ColegioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ColegioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColegioPayload>[]
          }
          delete: {
            args: Prisma.ColegioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColegioPayload>
          }
          update: {
            args: Prisma.ColegioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColegioPayload>
          }
          deleteMany: {
            args: Prisma.ColegioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ColegioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ColegioUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColegioPayload>[]
          }
          upsert: {
            args: Prisma.ColegioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColegioPayload>
          }
          aggregate: {
            args: Prisma.ColegioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateColegio>
          }
          groupBy: {
            args: Prisma.ColegioGroupByArgs<ExtArgs>
            result: $Utils.Optional<ColegioGroupByOutputType>[]
          }
          count: {
            args: Prisma.ColegioCountArgs<ExtArgs>
            result: $Utils.Optional<ColegioCountAggregateOutputType> | number
          }
        }
      }
      Convocatoria: {
        payload: Prisma.$ConvocatoriaPayload<ExtArgs>
        fields: Prisma.ConvocatoriaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConvocatoriaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConvocatoriaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConvocatoriaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConvocatoriaPayload>
          }
          findFirst: {
            args: Prisma.ConvocatoriaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConvocatoriaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConvocatoriaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConvocatoriaPayload>
          }
          findMany: {
            args: Prisma.ConvocatoriaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConvocatoriaPayload>[]
          }
          create: {
            args: Prisma.ConvocatoriaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConvocatoriaPayload>
          }
          createMany: {
            args: Prisma.ConvocatoriaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConvocatoriaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConvocatoriaPayload>[]
          }
          delete: {
            args: Prisma.ConvocatoriaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConvocatoriaPayload>
          }
          update: {
            args: Prisma.ConvocatoriaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConvocatoriaPayload>
          }
          deleteMany: {
            args: Prisma.ConvocatoriaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConvocatoriaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConvocatoriaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConvocatoriaPayload>[]
          }
          upsert: {
            args: Prisma.ConvocatoriaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConvocatoriaPayload>
          }
          aggregate: {
            args: Prisma.ConvocatoriaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConvocatoria>
          }
          groupBy: {
            args: Prisma.ConvocatoriaGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConvocatoriaGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConvocatoriaCountArgs<ExtArgs>
            result: $Utils.Optional<ConvocatoriaCountAggregateOutputType> | number
          }
        }
      }
      Area: {
        payload: Prisma.$AreaPayload<ExtArgs>
        fields: Prisma.AreaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AreaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AreaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaPayload>
          }
          findFirst: {
            args: Prisma.AreaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AreaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaPayload>
          }
          findMany: {
            args: Prisma.AreaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaPayload>[]
          }
          create: {
            args: Prisma.AreaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaPayload>
          }
          createMany: {
            args: Prisma.AreaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AreaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaPayload>[]
          }
          delete: {
            args: Prisma.AreaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaPayload>
          }
          update: {
            args: Prisma.AreaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaPayload>
          }
          deleteMany: {
            args: Prisma.AreaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AreaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AreaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaPayload>[]
          }
          upsert: {
            args: Prisma.AreaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaPayload>
          }
          aggregate: {
            args: Prisma.AreaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateArea>
          }
          groupBy: {
            args: Prisma.AreaGroupByArgs<ExtArgs>
            result: $Utils.Optional<AreaGroupByOutputType>[]
          }
          count: {
            args: Prisma.AreaCountArgs<ExtArgs>
            result: $Utils.Optional<AreaCountAggregateOutputType> | number
          }
        }
      }
      Categoria: {
        payload: Prisma.$CategoriaPayload<ExtArgs>
        fields: Prisma.CategoriaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoriaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoriaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload>
          }
          findFirst: {
            args: Prisma.CategoriaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoriaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload>
          }
          findMany: {
            args: Prisma.CategoriaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload>[]
          }
          create: {
            args: Prisma.CategoriaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload>
          }
          createMany: {
            args: Prisma.CategoriaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoriaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload>[]
          }
          delete: {
            args: Prisma.CategoriaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload>
          }
          update: {
            args: Prisma.CategoriaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload>
          }
          deleteMany: {
            args: Prisma.CategoriaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoriaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CategoriaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload>[]
          }
          upsert: {
            args: Prisma.CategoriaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload>
          }
          aggregate: {
            args: Prisma.CategoriaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategoria>
          }
          groupBy: {
            args: Prisma.CategoriaGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoriaGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoriaCountArgs<ExtArgs>
            result: $Utils.Optional<CategoriaCountAggregateOutputType> | number
          }
        }
      }
      Grado: {
        payload: Prisma.$GradoPayload<ExtArgs>
        fields: Prisma.GradoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GradoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GradoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradoPayload>
          }
          findFirst: {
            args: Prisma.GradoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GradoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradoPayload>
          }
          findMany: {
            args: Prisma.GradoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradoPayload>[]
          }
          create: {
            args: Prisma.GradoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradoPayload>
          }
          createMany: {
            args: Prisma.GradoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GradoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradoPayload>[]
          }
          delete: {
            args: Prisma.GradoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradoPayload>
          }
          update: {
            args: Prisma.GradoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradoPayload>
          }
          deleteMany: {
            args: Prisma.GradoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GradoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GradoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradoPayload>[]
          }
          upsert: {
            args: Prisma.GradoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradoPayload>
          }
          aggregate: {
            args: Prisma.GradoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGrado>
          }
          groupBy: {
            args: Prisma.GradoGroupByArgs<ExtArgs>
            result: $Utils.Optional<GradoGroupByOutputType>[]
          }
          count: {
            args: Prisma.GradoCountArgs<ExtArgs>
            result: $Utils.Optional<GradoCountAggregateOutputType> | number
          }
        }
      }
      Pago: {
        payload: Prisma.$PagoPayload<ExtArgs>
        fields: Prisma.PagoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PagoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PagoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagoPayload>
          }
          findFirst: {
            args: Prisma.PagoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PagoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagoPayload>
          }
          findMany: {
            args: Prisma.PagoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagoPayload>[]
          }
          create: {
            args: Prisma.PagoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagoPayload>
          }
          createMany: {
            args: Prisma.PagoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PagoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagoPayload>[]
          }
          delete: {
            args: Prisma.PagoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagoPayload>
          }
          update: {
            args: Prisma.PagoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagoPayload>
          }
          deleteMany: {
            args: Prisma.PagoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PagoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PagoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagoPayload>[]
          }
          upsert: {
            args: Prisma.PagoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagoPayload>
          }
          aggregate: {
            args: Prisma.PagoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePago>
          }
          groupBy: {
            args: Prisma.PagoGroupByArgs<ExtArgs>
            result: $Utils.Optional<PagoGroupByOutputType>[]
          }
          count: {
            args: Prisma.PagoCountArgs<ExtArgs>
            result: $Utils.Optional<PagoCountAggregateOutputType> | number
          }
        }
      }
      Area_convocatoria: {
        payload: Prisma.$Area_convocatoriaPayload<ExtArgs>
        fields: Prisma.Area_convocatoriaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Area_convocatoriaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Area_convocatoriaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Area_convocatoriaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Area_convocatoriaPayload>
          }
          findFirst: {
            args: Prisma.Area_convocatoriaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Area_convocatoriaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Area_convocatoriaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Area_convocatoriaPayload>
          }
          findMany: {
            args: Prisma.Area_convocatoriaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Area_convocatoriaPayload>[]
          }
          create: {
            args: Prisma.Area_convocatoriaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Area_convocatoriaPayload>
          }
          createMany: {
            args: Prisma.Area_convocatoriaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Area_convocatoriaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Area_convocatoriaPayload>[]
          }
          delete: {
            args: Prisma.Area_convocatoriaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Area_convocatoriaPayload>
          }
          update: {
            args: Prisma.Area_convocatoriaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Area_convocatoriaPayload>
          }
          deleteMany: {
            args: Prisma.Area_convocatoriaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Area_convocatoriaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.Area_convocatoriaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Area_convocatoriaPayload>[]
          }
          upsert: {
            args: Prisma.Area_convocatoriaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Area_convocatoriaPayload>
          }
          aggregate: {
            args: Prisma.Area_convocatoriaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateArea_convocatoria>
          }
          groupBy: {
            args: Prisma.Area_convocatoriaGroupByArgs<ExtArgs>
            result: $Utils.Optional<Area_convocatoriaGroupByOutputType>[]
          }
          count: {
            args: Prisma.Area_convocatoriaCountArgs<ExtArgs>
            result: $Utils.Optional<Area_convocatoriaCountAggregateOutputType> | number
          }
        }
      }
      Categoria_area: {
        payload: Prisma.$Categoria_areaPayload<ExtArgs>
        fields: Prisma.Categoria_areaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Categoria_areaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Categoria_areaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Categoria_areaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Categoria_areaPayload>
          }
          findFirst: {
            args: Prisma.Categoria_areaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Categoria_areaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Categoria_areaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Categoria_areaPayload>
          }
          findMany: {
            args: Prisma.Categoria_areaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Categoria_areaPayload>[]
          }
          create: {
            args: Prisma.Categoria_areaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Categoria_areaPayload>
          }
          createMany: {
            args: Prisma.Categoria_areaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Categoria_areaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Categoria_areaPayload>[]
          }
          delete: {
            args: Prisma.Categoria_areaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Categoria_areaPayload>
          }
          update: {
            args: Prisma.Categoria_areaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Categoria_areaPayload>
          }
          deleteMany: {
            args: Prisma.Categoria_areaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Categoria_areaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.Categoria_areaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Categoria_areaPayload>[]
          }
          upsert: {
            args: Prisma.Categoria_areaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Categoria_areaPayload>
          }
          aggregate: {
            args: Prisma.Categoria_areaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategoria_area>
          }
          groupBy: {
            args: Prisma.Categoria_areaGroupByArgs<ExtArgs>
            result: $Utils.Optional<Categoria_areaGroupByOutputType>[]
          }
          count: {
            args: Prisma.Categoria_areaCountArgs<ExtArgs>
            result: $Utils.Optional<Categoria_areaCountAggregateOutputType> | number
          }
        }
      }
      Inscripcion_tutor: {
        payload: Prisma.$Inscripcion_tutorPayload<ExtArgs>
        fields: Prisma.Inscripcion_tutorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Inscripcion_tutorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Inscripcion_tutorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Inscripcion_tutorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Inscripcion_tutorPayload>
          }
          findFirst: {
            args: Prisma.Inscripcion_tutorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Inscripcion_tutorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Inscripcion_tutorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Inscripcion_tutorPayload>
          }
          findMany: {
            args: Prisma.Inscripcion_tutorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Inscripcion_tutorPayload>[]
          }
          create: {
            args: Prisma.Inscripcion_tutorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Inscripcion_tutorPayload>
          }
          createMany: {
            args: Prisma.Inscripcion_tutorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Inscripcion_tutorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Inscripcion_tutorPayload>[]
          }
          delete: {
            args: Prisma.Inscripcion_tutorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Inscripcion_tutorPayload>
          }
          update: {
            args: Prisma.Inscripcion_tutorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Inscripcion_tutorPayload>
          }
          deleteMany: {
            args: Prisma.Inscripcion_tutorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Inscripcion_tutorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.Inscripcion_tutorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Inscripcion_tutorPayload>[]
          }
          upsert: {
            args: Prisma.Inscripcion_tutorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Inscripcion_tutorPayload>
          }
          aggregate: {
            args: Prisma.Inscripcion_tutorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInscripcion_tutor>
          }
          groupBy: {
            args: Prisma.Inscripcion_tutorGroupByArgs<ExtArgs>
            result: $Utils.Optional<Inscripcion_tutorGroupByOutputType>[]
          }
          count: {
            args: Prisma.Inscripcion_tutorCountArgs<ExtArgs>
            result: $Utils.Optional<Inscripcion_tutorCountAggregateOutputType> | number
          }
        }
      }
      Metodo_pago: {
        payload: Prisma.$Metodo_pagoPayload<ExtArgs>
        fields: Prisma.Metodo_pagoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Metodo_pagoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Metodo_pagoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Metodo_pagoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Metodo_pagoPayload>
          }
          findFirst: {
            args: Prisma.Metodo_pagoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Metodo_pagoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Metodo_pagoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Metodo_pagoPayload>
          }
          findMany: {
            args: Prisma.Metodo_pagoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Metodo_pagoPayload>[]
          }
          create: {
            args: Prisma.Metodo_pagoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Metodo_pagoPayload>
          }
          createMany: {
            args: Prisma.Metodo_pagoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Metodo_pagoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Metodo_pagoPayload>[]
          }
          delete: {
            args: Prisma.Metodo_pagoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Metodo_pagoPayload>
          }
          update: {
            args: Prisma.Metodo_pagoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Metodo_pagoPayload>
          }
          deleteMany: {
            args: Prisma.Metodo_pagoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Metodo_pagoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.Metodo_pagoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Metodo_pagoPayload>[]
          }
          upsert: {
            args: Prisma.Metodo_pagoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Metodo_pagoPayload>
          }
          aggregate: {
            args: Prisma.Metodo_pagoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMetodo_pago>
          }
          groupBy: {
            args: Prisma.Metodo_pagoGroupByArgs<ExtArgs>
            result: $Utils.Optional<Metodo_pagoGroupByOutputType>[]
          }
          count: {
            args: Prisma.Metodo_pagoCountArgs<ExtArgs>
            result: $Utils.Optional<Metodo_pagoCountAggregateOutputType> | number
          }
        }
      }
      estado_convocatoria: {
        payload: Prisma.$estado_convocatoriaPayload<ExtArgs>
        fields: Prisma.estado_convocatoriaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.estado_convocatoriaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estado_convocatoriaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.estado_convocatoriaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estado_convocatoriaPayload>
          }
          findFirst: {
            args: Prisma.estado_convocatoriaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estado_convocatoriaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.estado_convocatoriaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estado_convocatoriaPayload>
          }
          findMany: {
            args: Prisma.estado_convocatoriaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estado_convocatoriaPayload>[]
          }
          create: {
            args: Prisma.estado_convocatoriaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estado_convocatoriaPayload>
          }
          createMany: {
            args: Prisma.estado_convocatoriaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.estado_convocatoriaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estado_convocatoriaPayload>[]
          }
          delete: {
            args: Prisma.estado_convocatoriaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estado_convocatoriaPayload>
          }
          update: {
            args: Prisma.estado_convocatoriaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estado_convocatoriaPayload>
          }
          deleteMany: {
            args: Prisma.estado_convocatoriaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.estado_convocatoriaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.estado_convocatoriaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estado_convocatoriaPayload>[]
          }
          upsert: {
            args: Prisma.estado_convocatoriaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estado_convocatoriaPayload>
          }
          aggregate: {
            args: Prisma.Estado_convocatoriaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEstado_convocatoria>
          }
          groupBy: {
            args: Prisma.estado_convocatoriaGroupByArgs<ExtArgs>
            result: $Utils.Optional<Estado_convocatoriaGroupByOutputType>[]
          }
          count: {
            args: Prisma.estado_convocatoriaCountArgs<ExtArgs>
            result: $Utils.Optional<Estado_convocatoriaCountAggregateOutputType> | number
          }
        }
      }
      Inscripcion: {
        payload: Prisma.$InscripcionPayload<ExtArgs>
        fields: Prisma.InscripcionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InscripcionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InscripcionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InscripcionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InscripcionPayload>
          }
          findFirst: {
            args: Prisma.InscripcionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InscripcionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InscripcionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InscripcionPayload>
          }
          findMany: {
            args: Prisma.InscripcionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InscripcionPayload>[]
          }
          create: {
            args: Prisma.InscripcionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InscripcionPayload>
          }
          createMany: {
            args: Prisma.InscripcionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InscripcionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InscripcionPayload>[]
          }
          delete: {
            args: Prisma.InscripcionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InscripcionPayload>
          }
          update: {
            args: Prisma.InscripcionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InscripcionPayload>
          }
          deleteMany: {
            args: Prisma.InscripcionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InscripcionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InscripcionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InscripcionPayload>[]
          }
          upsert: {
            args: Prisma.InscripcionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InscripcionPayload>
          }
          aggregate: {
            args: Prisma.InscripcionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInscripcion>
          }
          groupBy: {
            args: Prisma.InscripcionGroupByArgs<ExtArgs>
            result: $Utils.Optional<InscripcionGroupByOutputType>[]
          }
          count: {
            args: Prisma.InscripcionCountArgs<ExtArgs>
            result: $Utils.Optional<InscripcionCountAggregateOutputType> | number
          }
        }
      }
      Nivel: {
        payload: Prisma.$NivelPayload<ExtArgs>
        fields: Prisma.NivelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NivelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NivelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NivelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NivelPayload>
          }
          findFirst: {
            args: Prisma.NivelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NivelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NivelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NivelPayload>
          }
          findMany: {
            args: Prisma.NivelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NivelPayload>[]
          }
          create: {
            args: Prisma.NivelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NivelPayload>
          }
          createMany: {
            args: Prisma.NivelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NivelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NivelPayload>[]
          }
          delete: {
            args: Prisma.NivelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NivelPayload>
          }
          update: {
            args: Prisma.NivelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NivelPayload>
          }
          deleteMany: {
            args: Prisma.NivelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NivelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NivelUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NivelPayload>[]
          }
          upsert: {
            args: Prisma.NivelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NivelPayload>
          }
          aggregate: {
            args: Prisma.NivelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNivel>
          }
          groupBy: {
            args: Prisma.NivelGroupByArgs<ExtArgs>
            result: $Utils.Optional<NivelGroupByOutputType>[]
          }
          count: {
            args: Prisma.NivelCountArgs<ExtArgs>
            result: $Utils.Optional<NivelCountAggregateOutputType> | number
          }
        }
      }
      Notificacion: {
        payload: Prisma.$NotificacionPayload<ExtArgs>
        fields: Prisma.NotificacionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificacionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificacionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload>
          }
          findFirst: {
            args: Prisma.NotificacionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificacionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload>
          }
          findMany: {
            args: Prisma.NotificacionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload>[]
          }
          create: {
            args: Prisma.NotificacionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload>
          }
          createMany: {
            args: Prisma.NotificacionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificacionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload>[]
          }
          delete: {
            args: Prisma.NotificacionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload>
          }
          update: {
            args: Prisma.NotificacionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload>
          }
          deleteMany: {
            args: Prisma.NotificacionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificacionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificacionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload>[]
          }
          upsert: {
            args: Prisma.NotificacionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload>
          }
          aggregate: {
            args: Prisma.NotificacionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificacion>
          }
          groupBy: {
            args: Prisma.NotificacionGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificacionGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificacionCountArgs<ExtArgs>
            result: $Utils.Optional<NotificacionCountAggregateOutputType> | number
          }
        }
      }
      Motivo_rechazo: {
        payload: Prisma.$Motivo_rechazoPayload<ExtArgs>
        fields: Prisma.Motivo_rechazoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Motivo_rechazoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Motivo_rechazoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Motivo_rechazoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Motivo_rechazoPayload>
          }
          findFirst: {
            args: Prisma.Motivo_rechazoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Motivo_rechazoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Motivo_rechazoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Motivo_rechazoPayload>
          }
          findMany: {
            args: Prisma.Motivo_rechazoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Motivo_rechazoPayload>[]
          }
          create: {
            args: Prisma.Motivo_rechazoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Motivo_rechazoPayload>
          }
          createMany: {
            args: Prisma.Motivo_rechazoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Motivo_rechazoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Motivo_rechazoPayload>[]
          }
          delete: {
            args: Prisma.Motivo_rechazoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Motivo_rechazoPayload>
          }
          update: {
            args: Prisma.Motivo_rechazoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Motivo_rechazoPayload>
          }
          deleteMany: {
            args: Prisma.Motivo_rechazoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Motivo_rechazoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.Motivo_rechazoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Motivo_rechazoPayload>[]
          }
          upsert: {
            args: Prisma.Motivo_rechazoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Motivo_rechazoPayload>
          }
          aggregate: {
            args: Prisma.Motivo_rechazoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMotivo_rechazo>
          }
          groupBy: {
            args: Prisma.Motivo_rechazoGroupByArgs<ExtArgs>
            result: $Utils.Optional<Motivo_rechazoGroupByOutputType>[]
          }
          count: {
            args: Prisma.Motivo_rechazoCountArgs<ExtArgs>
            result: $Utils.Optional<Motivo_rechazoCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    usuario?: UsuarioOmit
    rol?: RolOmit
    permiso?: PermisoOmit
    rol_permiso?: Rol_permisoOmit
    competidor?: CompetidorOmit
    tutor?: TutorOmit
    departamento?: DepartamentoOmit
    provincia?: ProvinciaOmit
    colegio?: ColegioOmit
    convocatoria?: ConvocatoriaOmit
    area?: AreaOmit
    categoria?: CategoriaOmit
    grado?: GradoOmit
    pago?: PagoOmit
    area_convocatoria?: Area_convocatoriaOmit
    categoria_area?: Categoria_areaOmit
    inscripcion_tutor?: Inscripcion_tutorOmit
    metodo_pago?: Metodo_pagoOmit
    estado_convocatoria?: estado_convocatoriaOmit
    inscripcion?: InscripcionOmit
    nivel?: NivelOmit
    notificacion?: NotificacionOmit
    motivo_rechazo?: Motivo_rechazoOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UsuarioCountOutputType
   */

  export type UsuarioCountOutputType = {
    Notificacion: number
  }

  export type UsuarioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Notificacion?: boolean | UsuarioCountOutputTypeCountNotificacionArgs
  }

  // Custom InputTypes
  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioCountOutputType
     */
    select?: UsuarioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountNotificacionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificacionWhereInput
  }


  /**
   * Count Type RolCountOutputType
   */

  export type RolCountOutputType = {
    roles: number
    usuarios: number
  }

  export type RolCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | RolCountOutputTypeCountRolesArgs
    usuarios?: boolean | RolCountOutputTypeCountUsuariosArgs
  }

  // Custom InputTypes
  /**
   * RolCountOutputType without action
   */
  export type RolCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolCountOutputType
     */
    select?: RolCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RolCountOutputType without action
   */
  export type RolCountOutputTypeCountRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Rol_permisoWhereInput
  }

  /**
   * RolCountOutputType without action
   */
  export type RolCountOutputTypeCountUsuariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuarioWhereInput
  }


  /**
   * Count Type PermisoCountOutputType
   */

  export type PermisoCountOutputType = {
    roles: number
  }

  export type PermisoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | PermisoCountOutputTypeCountRolesArgs
  }

  // Custom InputTypes
  /**
   * PermisoCountOutputType without action
   */
  export type PermisoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermisoCountOutputType
     */
    select?: PermisoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PermisoCountOutputType without action
   */
  export type PermisoCountOutputTypeCountRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Rol_permisoWhereInput
  }


  /**
   * Count Type CompetidorCountOutputType
   */

  export type CompetidorCountOutputType = {
    Inscripciones: number
    Inscripcion: number
  }

  export type CompetidorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Inscripciones?: boolean | CompetidorCountOutputTypeCountInscripcionesArgs
    Inscripcion?: boolean | CompetidorCountOutputTypeCountInscripcionArgs
  }

  // Custom InputTypes
  /**
   * CompetidorCountOutputType without action
   */
  export type CompetidorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompetidorCountOutputType
     */
    select?: CompetidorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CompetidorCountOutputType without action
   */
  export type CompetidorCountOutputTypeCountInscripcionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Inscripcion_tutorWhereInput
  }

  /**
   * CompetidorCountOutputType without action
   */
  export type CompetidorCountOutputTypeCountInscripcionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InscripcionWhereInput
  }


  /**
   * Count Type TutorCountOutputType
   */

  export type TutorCountOutputType = {
    Inscripciones_tutor: number
  }

  export type TutorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Inscripciones_tutor?: boolean | TutorCountOutputTypeCountInscripciones_tutorArgs
  }

  // Custom InputTypes
  /**
   * TutorCountOutputType without action
   */
  export type TutorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutorCountOutputType
     */
    select?: TutorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TutorCountOutputType without action
   */
  export type TutorCountOutputTypeCountInscripciones_tutorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Inscripcion_tutorWhereInput
  }


  /**
   * Count Type DepartamentoCountOutputType
   */

  export type DepartamentoCountOutputType = {
    Provincia: number
  }

  export type DepartamentoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Provincia?: boolean | DepartamentoCountOutputTypeCountProvinciaArgs
  }

  // Custom InputTypes
  /**
   * DepartamentoCountOutputType without action
   */
  export type DepartamentoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartamentoCountOutputType
     */
    select?: DepartamentoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DepartamentoCountOutputType without action
   */
  export type DepartamentoCountOutputTypeCountProvinciaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProvinciaWhereInput
  }


  /**
   * Count Type ProvinciaCountOutputType
   */

  export type ProvinciaCountOutputType = {
    Colegio: number
    Competidor: number
  }

  export type ProvinciaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Colegio?: boolean | ProvinciaCountOutputTypeCountColegioArgs
    Competidor?: boolean | ProvinciaCountOutputTypeCountCompetidorArgs
  }

  // Custom InputTypes
  /**
   * ProvinciaCountOutputType without action
   */
  export type ProvinciaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProvinciaCountOutputType
     */
    select?: ProvinciaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProvinciaCountOutputType without action
   */
  export type ProvinciaCountOutputTypeCountColegioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ColegioWhereInput
  }

  /**
   * ProvinciaCountOutputType without action
   */
  export type ProvinciaCountOutputTypeCountCompetidorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompetidorWhereInput
  }


  /**
   * Count Type ColegioCountOutputType
   */

  export type ColegioCountOutputType = {
    Competidores: number
  }

  export type ColegioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Competidores?: boolean | ColegioCountOutputTypeCountCompetidoresArgs
  }

  // Custom InputTypes
  /**
   * ColegioCountOutputType without action
   */
  export type ColegioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ColegioCountOutputType
     */
    select?: ColegioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ColegioCountOutputType without action
   */
  export type ColegioCountOutputTypeCountCompetidoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompetidorWhereInput
  }


  /**
   * Count Type ConvocatoriaCountOutputType
   */

  export type ConvocatoriaCountOutputType = {
    Area_convocatoria: number
    Inscripcion: number
  }

  export type ConvocatoriaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Area_convocatoria?: boolean | ConvocatoriaCountOutputTypeCountArea_convocatoriaArgs
    Inscripcion?: boolean | ConvocatoriaCountOutputTypeCountInscripcionArgs
  }

  // Custom InputTypes
  /**
   * ConvocatoriaCountOutputType without action
   */
  export type ConvocatoriaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConvocatoriaCountOutputType
     */
    select?: ConvocatoriaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConvocatoriaCountOutputType without action
   */
  export type ConvocatoriaCountOutputTypeCountArea_convocatoriaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Area_convocatoriaWhereInput
  }

  /**
   * ConvocatoriaCountOutputType without action
   */
  export type ConvocatoriaCountOutputTypeCountInscripcionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InscripcionWhereInput
  }


  /**
   * Count Type AreaCountOutputType
   */

  export type AreaCountOutputType = {
    Area_convocatoria: number
    area_categoria: number
    Tutor: number
    Inscripcion: number
  }

  export type AreaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Area_convocatoria?: boolean | AreaCountOutputTypeCountArea_convocatoriaArgs
    area_categoria?: boolean | AreaCountOutputTypeCountArea_categoriaArgs
    Tutor?: boolean | AreaCountOutputTypeCountTutorArgs
    Inscripcion?: boolean | AreaCountOutputTypeCountInscripcionArgs
  }

  // Custom InputTypes
  /**
   * AreaCountOutputType without action
   */
  export type AreaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AreaCountOutputType
     */
    select?: AreaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AreaCountOutputType without action
   */
  export type AreaCountOutputTypeCountArea_convocatoriaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Area_convocatoriaWhereInput
  }

  /**
   * AreaCountOutputType without action
   */
  export type AreaCountOutputTypeCountArea_categoriaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Categoria_areaWhereInput
  }

  /**
   * AreaCountOutputType without action
   */
  export type AreaCountOutputTypeCountTutorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TutorWhereInput
  }

  /**
   * AreaCountOutputType without action
   */
  export type AreaCountOutputTypeCountInscripcionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InscripcionWhereInput
  }


  /**
   * Count Type CategoriaCountOutputType
   */

  export type CategoriaCountOutputType = {
    Categoria_convocatoria: number
    Inscripcion: number
  }

  export type CategoriaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Categoria_convocatoria?: boolean | CategoriaCountOutputTypeCountCategoria_convocatoriaArgs
    Inscripcion?: boolean | CategoriaCountOutputTypeCountInscripcionArgs
  }

  // Custom InputTypes
  /**
   * CategoriaCountOutputType without action
   */
  export type CategoriaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriaCountOutputType
     */
    select?: CategoriaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoriaCountOutputType without action
   */
  export type CategoriaCountOutputTypeCountCategoria_convocatoriaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Categoria_areaWhereInput
  }

  /**
   * CategoriaCountOutputType without action
   */
  export type CategoriaCountOutputTypeCountInscripcionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InscripcionWhereInput
  }


  /**
   * Count Type GradoCountOutputType
   */

  export type GradoCountOutputType = {
    categorias_max: number
    categorias_min: number
  }

  export type GradoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categorias_max?: boolean | GradoCountOutputTypeCountCategorias_maxArgs
    categorias_min?: boolean | GradoCountOutputTypeCountCategorias_minArgs
  }

  // Custom InputTypes
  /**
   * GradoCountOutputType without action
   */
  export type GradoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradoCountOutputType
     */
    select?: GradoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GradoCountOutputType without action
   */
  export type GradoCountOutputTypeCountCategorias_maxArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoriaWhereInput
  }

  /**
   * GradoCountOutputType without action
   */
  export type GradoCountOutputTypeCountCategorias_minArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoriaWhereInput
  }


  /**
   * Count Type Metodo_pagoCountOutputType
   */

  export type Metodo_pagoCountOutputType = {
    Pago: number
  }

  export type Metodo_pagoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Pago?: boolean | Metodo_pagoCountOutputTypeCountPagoArgs
  }

  // Custom InputTypes
  /**
   * Metodo_pagoCountOutputType without action
   */
  export type Metodo_pagoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metodo_pagoCountOutputType
     */
    select?: Metodo_pagoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Metodo_pagoCountOutputType without action
   */
  export type Metodo_pagoCountOutputTypeCountPagoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PagoWhereInput
  }


  /**
   * Count Type Estado_convocatoriaCountOutputType
   */

  export type Estado_convocatoriaCountOutputType = {
    Convocatoria: number
  }

  export type Estado_convocatoriaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Convocatoria?: boolean | Estado_convocatoriaCountOutputTypeCountConvocatoriaArgs
  }

  // Custom InputTypes
  /**
   * Estado_convocatoriaCountOutputType without action
   */
  export type Estado_convocatoriaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estado_convocatoriaCountOutputType
     */
    select?: Estado_convocatoriaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Estado_convocatoriaCountOutputType without action
   */
  export type Estado_convocatoriaCountOutputTypeCountConvocatoriaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConvocatoriaWhereInput
  }


  /**
   * Count Type InscripcionCountOutputType
   */

  export type InscripcionCountOutputType = {
    tutorInscripciones: number
    pagos: number
  }

  export type InscripcionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tutorInscripciones?: boolean | InscripcionCountOutputTypeCountTutorInscripcionesArgs
    pagos?: boolean | InscripcionCountOutputTypeCountPagosArgs
  }

  // Custom InputTypes
  /**
   * InscripcionCountOutputType without action
   */
  export type InscripcionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InscripcionCountOutputType
     */
    select?: InscripcionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InscripcionCountOutputType without action
   */
  export type InscripcionCountOutputTypeCountTutorInscripcionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Inscripcion_tutorWhereInput
  }

  /**
   * InscripcionCountOutputType without action
   */
  export type InscripcionCountOutputTypeCountPagosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PagoWhereInput
  }


  /**
   * Count Type NivelCountOutputType
   */

  export type NivelCountOutputType = {
    Grado: number
  }

  export type NivelCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Grado?: boolean | NivelCountOutputTypeCountGradoArgs
  }

  // Custom InputTypes
  /**
   * NivelCountOutputType without action
   */
  export type NivelCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NivelCountOutputType
     */
    select?: NivelCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NivelCountOutputType without action
   */
  export type NivelCountOutputTypeCountGradoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GradoWhereInput
  }


  /**
   * Count Type Motivo_rechazoCountOutputType
   */

  export type Motivo_rechazoCountOutputType = {
    inscripcionesTutor: number
  }

  export type Motivo_rechazoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inscripcionesTutor?: boolean | Motivo_rechazoCountOutputTypeCountInscripcionesTutorArgs
  }

  // Custom InputTypes
  /**
   * Motivo_rechazoCountOutputType without action
   */
  export type Motivo_rechazoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Motivo_rechazoCountOutputType
     */
    select?: Motivo_rechazoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Motivo_rechazoCountOutputType without action
   */
  export type Motivo_rechazoCountOutputTypeCountInscripcionesTutorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Inscripcion_tutorWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Usuario
   */

  export type AggregateUsuario = {
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  export type UsuarioAvgAggregateOutputType = {
    rol_id: number | null
  }

  export type UsuarioSumAggregateOutputType = {
    rol_id: number | null
  }

  export type UsuarioMinAggregateOutputType = {
    id: string | null
    correo_electronico: string | null
    nombre: string | null
    apellido: string | null
    estado: boolean | null
    password: string | null
    rol_id: number | null
    createdAt: Date | null
  }

  export type UsuarioMaxAggregateOutputType = {
    id: string | null
    correo_electronico: string | null
    nombre: string | null
    apellido: string | null
    estado: boolean | null
    password: string | null
    rol_id: number | null
    createdAt: Date | null
  }

  export type UsuarioCountAggregateOutputType = {
    id: number
    correo_electronico: number
    nombre: number
    apellido: number
    estado: number
    password: number
    rol_id: number
    createdAt: number
    _all: number
  }


  export type UsuarioAvgAggregateInputType = {
    rol_id?: true
  }

  export type UsuarioSumAggregateInputType = {
    rol_id?: true
  }

  export type UsuarioMinAggregateInputType = {
    id?: true
    correo_electronico?: true
    nombre?: true
    apellido?: true
    estado?: true
    password?: true
    rol_id?: true
    createdAt?: true
  }

  export type UsuarioMaxAggregateInputType = {
    id?: true
    correo_electronico?: true
    nombre?: true
    apellido?: true
    estado?: true
    password?: true
    rol_id?: true
    createdAt?: true
  }

  export type UsuarioCountAggregateInputType = {
    id?: true
    correo_electronico?: true
    nombre?: true
    apellido?: true
    estado?: true
    password?: true
    rol_id?: true
    createdAt?: true
    _all?: true
  }

  export type UsuarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuario to aggregate.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Usuarios
    **/
    _count?: true | UsuarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsuarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsuarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuarioMaxAggregateInputType
  }

  export type GetUsuarioAggregateType<T extends UsuarioAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuario[P]>
      : GetScalarType<T[P], AggregateUsuario[P]>
  }




  export type UsuarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuarioWhereInput
    orderBy?: UsuarioOrderByWithAggregationInput | UsuarioOrderByWithAggregationInput[]
    by: UsuarioScalarFieldEnum[] | UsuarioScalarFieldEnum
    having?: UsuarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuarioCountAggregateInputType | true
    _avg?: UsuarioAvgAggregateInputType
    _sum?: UsuarioSumAggregateInputType
    _min?: UsuarioMinAggregateInputType
    _max?: UsuarioMaxAggregateInputType
  }

  export type UsuarioGroupByOutputType = {
    id: string
    correo_electronico: string
    nombre: string
    apellido: string
    estado: boolean
    password: string
    rol_id: number
    createdAt: Date
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  type GetUsuarioGroupByPayload<T extends UsuarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsuarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
            : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
        }
      >
    >


  export type UsuarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    correo_electronico?: boolean
    nombre?: boolean
    apellido?: boolean
    estado?: boolean
    password?: boolean
    rol_id?: boolean
    createdAt?: boolean
    competidor?: boolean | Usuario$competidorArgs<ExtArgs>
    tutor?: boolean | Usuario$tutorArgs<ExtArgs>
    role?: boolean | RolDefaultArgs<ExtArgs>
    Notificacion?: boolean | Usuario$NotificacionArgs<ExtArgs>
    _count?: boolean | UsuarioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuario"]>

  export type UsuarioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    correo_electronico?: boolean
    nombre?: boolean
    apellido?: boolean
    estado?: boolean
    password?: boolean
    rol_id?: boolean
    createdAt?: boolean
    role?: boolean | RolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuario"]>

  export type UsuarioSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    correo_electronico?: boolean
    nombre?: boolean
    apellido?: boolean
    estado?: boolean
    password?: boolean
    rol_id?: boolean
    createdAt?: boolean
    role?: boolean | RolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuario"]>

  export type UsuarioSelectScalar = {
    id?: boolean
    correo_electronico?: boolean
    nombre?: boolean
    apellido?: boolean
    estado?: boolean
    password?: boolean
    rol_id?: boolean
    createdAt?: boolean
  }

  export type UsuarioOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "correo_electronico" | "nombre" | "apellido" | "estado" | "password" | "rol_id" | "createdAt", ExtArgs["result"]["usuario"]>
  export type UsuarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    competidor?: boolean | Usuario$competidorArgs<ExtArgs>
    tutor?: boolean | Usuario$tutorArgs<ExtArgs>
    role?: boolean | RolDefaultArgs<ExtArgs>
    Notificacion?: boolean | Usuario$NotificacionArgs<ExtArgs>
    _count?: boolean | UsuarioCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UsuarioIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RolDefaultArgs<ExtArgs>
  }
  export type UsuarioIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RolDefaultArgs<ExtArgs>
  }

  export type $UsuarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Usuario"
    objects: {
      competidor: Prisma.$CompetidorPayload<ExtArgs> | null
      tutor: Prisma.$TutorPayload<ExtArgs> | null
      role: Prisma.$RolPayload<ExtArgs>
      Notificacion: Prisma.$NotificacionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      correo_electronico: string
      nombre: string
      apellido: string
      estado: boolean
      password: string
      rol_id: number
      createdAt: Date
    }, ExtArgs["result"]["usuario"]>
    composites: {}
  }

  type UsuarioGetPayload<S extends boolean | null | undefined | UsuarioDefaultArgs> = $Result.GetResult<Prisma.$UsuarioPayload, S>

  type UsuarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UsuarioFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsuarioCountAggregateInputType | true
    }

  export interface UsuarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Usuario'], meta: { name: 'Usuario' } }
    /**
     * Find zero or one Usuario that matches the filter.
     * @param {UsuarioFindUniqueArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsuarioFindUniqueArgs>(args: SelectSubset<T, UsuarioFindUniqueArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Usuario that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UsuarioFindUniqueOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsuarioFindUniqueOrThrowArgs>(args: SelectSubset<T, UsuarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Usuario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsuarioFindFirstArgs>(args?: SelectSubset<T, UsuarioFindFirstArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Usuario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsuarioFindFirstOrThrowArgs>(args?: SelectSubset<T, UsuarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuarios
     * const usuarios = await prisma.usuario.findMany()
     * 
     * // Get first 10 Usuarios
     * const usuarios = await prisma.usuario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usuarioWithIdOnly = await prisma.usuario.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsuarioFindManyArgs>(args?: SelectSubset<T, UsuarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Usuario.
     * @param {UsuarioCreateArgs} args - Arguments to create a Usuario.
     * @example
     * // Create one Usuario
     * const Usuario = await prisma.usuario.create({
     *   data: {
     *     // ... data to create a Usuario
     *   }
     * })
     * 
     */
    create<T extends UsuarioCreateArgs>(args: SelectSubset<T, UsuarioCreateArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Usuarios.
     * @param {UsuarioCreateManyArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuario = await prisma.usuario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsuarioCreateManyArgs>(args?: SelectSubset<T, UsuarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Usuarios and returns the data saved in the database.
     * @param {UsuarioCreateManyAndReturnArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuario = await prisma.usuario.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Usuarios and only return the `id`
     * const usuarioWithIdOnly = await prisma.usuario.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UsuarioCreateManyAndReturnArgs>(args?: SelectSubset<T, UsuarioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Usuario.
     * @param {UsuarioDeleteArgs} args - Arguments to delete one Usuario.
     * @example
     * // Delete one Usuario
     * const Usuario = await prisma.usuario.delete({
     *   where: {
     *     // ... filter to delete one Usuario
     *   }
     * })
     * 
     */
    delete<T extends UsuarioDeleteArgs>(args: SelectSubset<T, UsuarioDeleteArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Usuario.
     * @param {UsuarioUpdateArgs} args - Arguments to update one Usuario.
     * @example
     * // Update one Usuario
     * const usuario = await prisma.usuario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsuarioUpdateArgs>(args: SelectSubset<T, UsuarioUpdateArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Usuarios.
     * @param {UsuarioDeleteManyArgs} args - Arguments to filter Usuarios to delete.
     * @example
     * // Delete a few Usuarios
     * const { count } = await prisma.usuario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsuarioDeleteManyArgs>(args?: SelectSubset<T, UsuarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuarios
     * const usuario = await prisma.usuario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsuarioUpdateManyArgs>(args: SelectSubset<T, UsuarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios and returns the data updated in the database.
     * @param {UsuarioUpdateManyAndReturnArgs} args - Arguments to update many Usuarios.
     * @example
     * // Update many Usuarios
     * const usuario = await prisma.usuario.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Usuarios and only return the `id`
     * const usuarioWithIdOnly = await prisma.usuario.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UsuarioUpdateManyAndReturnArgs>(args: SelectSubset<T, UsuarioUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Usuario.
     * @param {UsuarioUpsertArgs} args - Arguments to update or create a Usuario.
     * @example
     * // Update or create a Usuario
     * const usuario = await prisma.usuario.upsert({
     *   create: {
     *     // ... data to create a Usuario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuario we want to update
     *   }
     * })
     */
    upsert<T extends UsuarioUpsertArgs>(args: SelectSubset<T, UsuarioUpsertArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioCountArgs} args - Arguments to filter Usuarios to count.
     * @example
     * // Count the number of Usuarios
     * const count = await prisma.usuario.count({
     *   where: {
     *     // ... the filter for the Usuarios we want to count
     *   }
     * })
    **/
    count<T extends UsuarioCountArgs>(
      args?: Subset<T, UsuarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuarioAggregateArgs>(args: Subset<T, UsuarioAggregateArgs>): Prisma.PrismaPromise<GetUsuarioAggregateType<T>>

    /**
     * Group by Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsuarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsuarioGroupByArgs['orderBy'] }
        : { orderBy?: UsuarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsuarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Usuario model
   */
  readonly fields: UsuarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Usuario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsuarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    competidor<T extends Usuario$competidorArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$competidorArgs<ExtArgs>>): Prisma__CompetidorClient<$Result.GetResult<Prisma.$CompetidorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    tutor<T extends Usuario$tutorArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$tutorArgs<ExtArgs>>): Prisma__TutorClient<$Result.GetResult<Prisma.$TutorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    role<T extends RolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RolDefaultArgs<ExtArgs>>): Prisma__RolClient<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Notificacion<T extends Usuario$NotificacionArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$NotificacionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Usuario model
   */
  interface UsuarioFieldRefs {
    readonly id: FieldRef<"Usuario", 'String'>
    readonly correo_electronico: FieldRef<"Usuario", 'String'>
    readonly nombre: FieldRef<"Usuario", 'String'>
    readonly apellido: FieldRef<"Usuario", 'String'>
    readonly estado: FieldRef<"Usuario", 'Boolean'>
    readonly password: FieldRef<"Usuario", 'String'>
    readonly rol_id: FieldRef<"Usuario", 'Int'>
    readonly createdAt: FieldRef<"Usuario", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Usuario findUnique
   */
  export type UsuarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario findUniqueOrThrow
   */
  export type UsuarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario findFirst
   */
  export type UsuarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario findFirstOrThrow
   */
  export type UsuarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario findMany
   */
  export type UsuarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuarios to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario create
   */
  export type UsuarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The data needed to create a Usuario.
     */
    data: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
  }

  /**
   * Usuario createMany
   */
  export type UsuarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Usuarios.
     */
    data: UsuarioCreateManyInput | UsuarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Usuario createManyAndReturn
   */
  export type UsuarioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * The data used to create many Usuarios.
     */
    data: UsuarioCreateManyInput | UsuarioCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Usuario update
   */
  export type UsuarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The data needed to update a Usuario.
     */
    data: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
    /**
     * Choose, which Usuario to update.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario updateMany
   */
  export type UsuarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Usuarios.
     */
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyInput>
    /**
     * Filter which Usuarios to update
     */
    where?: UsuarioWhereInput
    /**
     * Limit how many Usuarios to update.
     */
    limit?: number
  }

  /**
   * Usuario updateManyAndReturn
   */
  export type UsuarioUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * The data used to update Usuarios.
     */
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyInput>
    /**
     * Filter which Usuarios to update
     */
    where?: UsuarioWhereInput
    /**
     * Limit how many Usuarios to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Usuario upsert
   */
  export type UsuarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The filter to search for the Usuario to update in case it exists.
     */
    where: UsuarioWhereUniqueInput
    /**
     * In case the Usuario found by the `where` argument doesn't exist, create a new Usuario with this data.
     */
    create: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
    /**
     * In case the Usuario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
  }

  /**
   * Usuario delete
   */
  export type UsuarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter which Usuario to delete.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario deleteMany
   */
  export type UsuarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuarios to delete
     */
    where?: UsuarioWhereInput
    /**
     * Limit how many Usuarios to delete.
     */
    limit?: number
  }

  /**
   * Usuario.competidor
   */
  export type Usuario$competidorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Competidor
     */
    select?: CompetidorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Competidor
     */
    omit?: CompetidorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompetidorInclude<ExtArgs> | null
    where?: CompetidorWhereInput
  }

  /**
   * Usuario.tutor
   */
  export type Usuario$tutorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tutor
     */
    select?: TutorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tutor
     */
    omit?: TutorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutorInclude<ExtArgs> | null
    where?: TutorWhereInput
  }

  /**
   * Usuario.Notificacion
   */
  export type Usuario$NotificacionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notificacion
     */
    omit?: NotificacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null
    where?: NotificacionWhereInput
    orderBy?: NotificacionOrderByWithRelationInput | NotificacionOrderByWithRelationInput[]
    cursor?: NotificacionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificacionScalarFieldEnum | NotificacionScalarFieldEnum[]
  }

  /**
   * Usuario without action
   */
  export type UsuarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
  }


  /**
   * Model Rol
   */

  export type AggregateRol = {
    _count: RolCountAggregateOutputType | null
    _avg: RolAvgAggregateOutputType | null
    _sum: RolSumAggregateOutputType | null
    _min: RolMinAggregateOutputType | null
    _max: RolMaxAggregateOutputType | null
  }

  export type RolAvgAggregateOutputType = {
    id: number | null
  }

  export type RolSumAggregateOutputType = {
    id: number | null
  }

  export type RolMinAggregateOutputType = {
    id: number | null
    nombre: string | null
  }

  export type RolMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
  }

  export type RolCountAggregateOutputType = {
    id: number
    nombre: number
    _all: number
  }


  export type RolAvgAggregateInputType = {
    id?: true
  }

  export type RolSumAggregateInputType = {
    id?: true
  }

  export type RolMinAggregateInputType = {
    id?: true
    nombre?: true
  }

  export type RolMaxAggregateInputType = {
    id?: true
    nombre?: true
  }

  export type RolCountAggregateInputType = {
    id?: true
    nombre?: true
    _all?: true
  }

  export type RolAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rol to aggregate.
     */
    where?: RolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rols to fetch.
     */
    orderBy?: RolOrderByWithRelationInput | RolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Rols
    **/
    _count?: true | RolCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RolAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RolSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolMaxAggregateInputType
  }

  export type GetRolAggregateType<T extends RolAggregateArgs> = {
        [P in keyof T & keyof AggregateRol]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRol[P]>
      : GetScalarType<T[P], AggregateRol[P]>
  }




  export type RolGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolWhereInput
    orderBy?: RolOrderByWithAggregationInput | RolOrderByWithAggregationInput[]
    by: RolScalarFieldEnum[] | RolScalarFieldEnum
    having?: RolScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolCountAggregateInputType | true
    _avg?: RolAvgAggregateInputType
    _sum?: RolSumAggregateInputType
    _min?: RolMinAggregateInputType
    _max?: RolMaxAggregateInputType
  }

  export type RolGroupByOutputType = {
    id: number
    nombre: string
    _count: RolCountAggregateOutputType | null
    _avg: RolAvgAggregateOutputType | null
    _sum: RolSumAggregateOutputType | null
    _min: RolMinAggregateOutputType | null
    _max: RolMaxAggregateOutputType | null
  }

  type GetRolGroupByPayload<T extends RolGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolGroupByOutputType[P]>
            : GetScalarType<T[P], RolGroupByOutputType[P]>
        }
      >
    >


  export type RolSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    roles?: boolean | Rol$rolesArgs<ExtArgs>
    usuarios?: boolean | Rol$usuariosArgs<ExtArgs>
    _count?: boolean | RolCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rol"]>

  export type RolSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
  }, ExtArgs["result"]["rol"]>

  export type RolSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
  }, ExtArgs["result"]["rol"]>

  export type RolSelectScalar = {
    id?: boolean
    nombre?: boolean
  }

  export type RolOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nombre", ExtArgs["result"]["rol"]>
  export type RolInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | Rol$rolesArgs<ExtArgs>
    usuarios?: boolean | Rol$usuariosArgs<ExtArgs>
    _count?: boolean | RolCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RolIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RolIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RolPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Rol"
    objects: {
      roles: Prisma.$Rol_permisoPayload<ExtArgs>[]
      usuarios: Prisma.$UsuarioPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string
    }, ExtArgs["result"]["rol"]>
    composites: {}
  }

  type RolGetPayload<S extends boolean | null | undefined | RolDefaultArgs> = $Result.GetResult<Prisma.$RolPayload, S>

  type RolCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RolFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RolCountAggregateInputType | true
    }

  export interface RolDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Rol'], meta: { name: 'Rol' } }
    /**
     * Find zero or one Rol that matches the filter.
     * @param {RolFindUniqueArgs} args - Arguments to find a Rol
     * @example
     * // Get one Rol
     * const rol = await prisma.rol.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RolFindUniqueArgs>(args: SelectSubset<T, RolFindUniqueArgs<ExtArgs>>): Prisma__RolClient<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Rol that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RolFindUniqueOrThrowArgs} args - Arguments to find a Rol
     * @example
     * // Get one Rol
     * const rol = await prisma.rol.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RolFindUniqueOrThrowArgs>(args: SelectSubset<T, RolFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RolClient<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rol that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolFindFirstArgs} args - Arguments to find a Rol
     * @example
     * // Get one Rol
     * const rol = await prisma.rol.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RolFindFirstArgs>(args?: SelectSubset<T, RolFindFirstArgs<ExtArgs>>): Prisma__RolClient<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rol that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolFindFirstOrThrowArgs} args - Arguments to find a Rol
     * @example
     * // Get one Rol
     * const rol = await prisma.rol.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RolFindFirstOrThrowArgs>(args?: SelectSubset<T, RolFindFirstOrThrowArgs<ExtArgs>>): Prisma__RolClient<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Rols that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rols
     * const rols = await prisma.rol.findMany()
     * 
     * // Get first 10 Rols
     * const rols = await prisma.rol.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rolWithIdOnly = await prisma.rol.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RolFindManyArgs>(args?: SelectSubset<T, RolFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Rol.
     * @param {RolCreateArgs} args - Arguments to create a Rol.
     * @example
     * // Create one Rol
     * const Rol = await prisma.rol.create({
     *   data: {
     *     // ... data to create a Rol
     *   }
     * })
     * 
     */
    create<T extends RolCreateArgs>(args: SelectSubset<T, RolCreateArgs<ExtArgs>>): Prisma__RolClient<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Rols.
     * @param {RolCreateManyArgs} args - Arguments to create many Rols.
     * @example
     * // Create many Rols
     * const rol = await prisma.rol.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RolCreateManyArgs>(args?: SelectSubset<T, RolCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Rols and returns the data saved in the database.
     * @param {RolCreateManyAndReturnArgs} args - Arguments to create many Rols.
     * @example
     * // Create many Rols
     * const rol = await prisma.rol.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Rols and only return the `id`
     * const rolWithIdOnly = await prisma.rol.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RolCreateManyAndReturnArgs>(args?: SelectSubset<T, RolCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Rol.
     * @param {RolDeleteArgs} args - Arguments to delete one Rol.
     * @example
     * // Delete one Rol
     * const Rol = await prisma.rol.delete({
     *   where: {
     *     // ... filter to delete one Rol
     *   }
     * })
     * 
     */
    delete<T extends RolDeleteArgs>(args: SelectSubset<T, RolDeleteArgs<ExtArgs>>): Prisma__RolClient<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Rol.
     * @param {RolUpdateArgs} args - Arguments to update one Rol.
     * @example
     * // Update one Rol
     * const rol = await prisma.rol.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RolUpdateArgs>(args: SelectSubset<T, RolUpdateArgs<ExtArgs>>): Prisma__RolClient<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Rols.
     * @param {RolDeleteManyArgs} args - Arguments to filter Rols to delete.
     * @example
     * // Delete a few Rols
     * const { count } = await prisma.rol.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RolDeleteManyArgs>(args?: SelectSubset<T, RolDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rols.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rols
     * const rol = await prisma.rol.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RolUpdateManyArgs>(args: SelectSubset<T, RolUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rols and returns the data updated in the database.
     * @param {RolUpdateManyAndReturnArgs} args - Arguments to update many Rols.
     * @example
     * // Update many Rols
     * const rol = await prisma.rol.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Rols and only return the `id`
     * const rolWithIdOnly = await prisma.rol.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RolUpdateManyAndReturnArgs>(args: SelectSubset<T, RolUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Rol.
     * @param {RolUpsertArgs} args - Arguments to update or create a Rol.
     * @example
     * // Update or create a Rol
     * const rol = await prisma.rol.upsert({
     *   create: {
     *     // ... data to create a Rol
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rol we want to update
     *   }
     * })
     */
    upsert<T extends RolUpsertArgs>(args: SelectSubset<T, RolUpsertArgs<ExtArgs>>): Prisma__RolClient<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Rols.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolCountArgs} args - Arguments to filter Rols to count.
     * @example
     * // Count the number of Rols
     * const count = await prisma.rol.count({
     *   where: {
     *     // ... the filter for the Rols we want to count
     *   }
     * })
    **/
    count<T extends RolCountArgs>(
      args?: Subset<T, RolCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rol.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolAggregateArgs>(args: Subset<T, RolAggregateArgs>): Prisma.PrismaPromise<GetRolAggregateType<T>>

    /**
     * Group by Rol.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RolGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RolGroupByArgs['orderBy'] }
        : { orderBy?: RolGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RolGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Rol model
   */
  readonly fields: RolFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Rol.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RolClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    roles<T extends Rol$rolesArgs<ExtArgs> = {}>(args?: Subset<T, Rol$rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Rol_permisoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    usuarios<T extends Rol$usuariosArgs<ExtArgs> = {}>(args?: Subset<T, Rol$usuariosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Rol model
   */
  interface RolFieldRefs {
    readonly id: FieldRef<"Rol", 'Int'>
    readonly nombre: FieldRef<"Rol", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Rol findUnique
   */
  export type RolFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rol
     */
    omit?: RolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolInclude<ExtArgs> | null
    /**
     * Filter, which Rol to fetch.
     */
    where: RolWhereUniqueInput
  }

  /**
   * Rol findUniqueOrThrow
   */
  export type RolFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rol
     */
    omit?: RolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolInclude<ExtArgs> | null
    /**
     * Filter, which Rol to fetch.
     */
    where: RolWhereUniqueInput
  }

  /**
   * Rol findFirst
   */
  export type RolFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rol
     */
    omit?: RolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolInclude<ExtArgs> | null
    /**
     * Filter, which Rol to fetch.
     */
    where?: RolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rols to fetch.
     */
    orderBy?: RolOrderByWithRelationInput | RolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rols.
     */
    cursor?: RolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rols.
     */
    distinct?: RolScalarFieldEnum | RolScalarFieldEnum[]
  }

  /**
   * Rol findFirstOrThrow
   */
  export type RolFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rol
     */
    omit?: RolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolInclude<ExtArgs> | null
    /**
     * Filter, which Rol to fetch.
     */
    where?: RolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rols to fetch.
     */
    orderBy?: RolOrderByWithRelationInput | RolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rols.
     */
    cursor?: RolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rols.
     */
    distinct?: RolScalarFieldEnum | RolScalarFieldEnum[]
  }

  /**
   * Rol findMany
   */
  export type RolFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rol
     */
    omit?: RolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolInclude<ExtArgs> | null
    /**
     * Filter, which Rols to fetch.
     */
    where?: RolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rols to fetch.
     */
    orderBy?: RolOrderByWithRelationInput | RolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Rols.
     */
    cursor?: RolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rols.
     */
    skip?: number
    distinct?: RolScalarFieldEnum | RolScalarFieldEnum[]
  }

  /**
   * Rol create
   */
  export type RolCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rol
     */
    omit?: RolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolInclude<ExtArgs> | null
    /**
     * The data needed to create a Rol.
     */
    data: XOR<RolCreateInput, RolUncheckedCreateInput>
  }

  /**
   * Rol createMany
   */
  export type RolCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Rols.
     */
    data: RolCreateManyInput | RolCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Rol createManyAndReturn
   */
  export type RolCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Rol
     */
    omit?: RolOmit<ExtArgs> | null
    /**
     * The data used to create many Rols.
     */
    data: RolCreateManyInput | RolCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Rol update
   */
  export type RolUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rol
     */
    omit?: RolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolInclude<ExtArgs> | null
    /**
     * The data needed to update a Rol.
     */
    data: XOR<RolUpdateInput, RolUncheckedUpdateInput>
    /**
     * Choose, which Rol to update.
     */
    where: RolWhereUniqueInput
  }

  /**
   * Rol updateMany
   */
  export type RolUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Rols.
     */
    data: XOR<RolUpdateManyMutationInput, RolUncheckedUpdateManyInput>
    /**
     * Filter which Rols to update
     */
    where?: RolWhereInput
    /**
     * Limit how many Rols to update.
     */
    limit?: number
  }

  /**
   * Rol updateManyAndReturn
   */
  export type RolUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Rol
     */
    omit?: RolOmit<ExtArgs> | null
    /**
     * The data used to update Rols.
     */
    data: XOR<RolUpdateManyMutationInput, RolUncheckedUpdateManyInput>
    /**
     * Filter which Rols to update
     */
    where?: RolWhereInput
    /**
     * Limit how many Rols to update.
     */
    limit?: number
  }

  /**
   * Rol upsert
   */
  export type RolUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rol
     */
    omit?: RolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolInclude<ExtArgs> | null
    /**
     * The filter to search for the Rol to update in case it exists.
     */
    where: RolWhereUniqueInput
    /**
     * In case the Rol found by the `where` argument doesn't exist, create a new Rol with this data.
     */
    create: XOR<RolCreateInput, RolUncheckedCreateInput>
    /**
     * In case the Rol was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RolUpdateInput, RolUncheckedUpdateInput>
  }

  /**
   * Rol delete
   */
  export type RolDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rol
     */
    omit?: RolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolInclude<ExtArgs> | null
    /**
     * Filter which Rol to delete.
     */
    where: RolWhereUniqueInput
  }

  /**
   * Rol deleteMany
   */
  export type RolDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rols to delete
     */
    where?: RolWhereInput
    /**
     * Limit how many Rols to delete.
     */
    limit?: number
  }

  /**
   * Rol.roles
   */
  export type Rol$rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol_permiso
     */
    select?: Rol_permisoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rol_permiso
     */
    omit?: Rol_permisoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Rol_permisoInclude<ExtArgs> | null
    where?: Rol_permisoWhereInput
    orderBy?: Rol_permisoOrderByWithRelationInput | Rol_permisoOrderByWithRelationInput[]
    cursor?: Rol_permisoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Rol_permisoScalarFieldEnum | Rol_permisoScalarFieldEnum[]
  }

  /**
   * Rol.usuarios
   */
  export type Rol$usuariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    where?: UsuarioWhereInput
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    cursor?: UsuarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Rol without action
   */
  export type RolDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rol
     */
    omit?: RolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolInclude<ExtArgs> | null
  }


  /**
   * Model Permiso
   */

  export type AggregatePermiso = {
    _count: PermisoCountAggregateOutputType | null
    _avg: PermisoAvgAggregateOutputType | null
    _sum: PermisoSumAggregateOutputType | null
    _min: PermisoMinAggregateOutputType | null
    _max: PermisoMaxAggregateOutputType | null
  }

  export type PermisoAvgAggregateOutputType = {
    id: number | null
  }

  export type PermisoSumAggregateOutputType = {
    id: number | null
  }

  export type PermisoMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    descripcion: string | null
  }

  export type PermisoMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    descripcion: string | null
  }

  export type PermisoCountAggregateOutputType = {
    id: number
    nombre: number
    descripcion: number
    _all: number
  }


  export type PermisoAvgAggregateInputType = {
    id?: true
  }

  export type PermisoSumAggregateInputType = {
    id?: true
  }

  export type PermisoMinAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
  }

  export type PermisoMaxAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
  }

  export type PermisoCountAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    _all?: true
  }

  export type PermisoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permiso to aggregate.
     */
    where?: PermisoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permisos to fetch.
     */
    orderBy?: PermisoOrderByWithRelationInput | PermisoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PermisoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permisos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permisos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Permisos
    **/
    _count?: true | PermisoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PermisoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PermisoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermisoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermisoMaxAggregateInputType
  }

  export type GetPermisoAggregateType<T extends PermisoAggregateArgs> = {
        [P in keyof T & keyof AggregatePermiso]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermiso[P]>
      : GetScalarType<T[P], AggregatePermiso[P]>
  }




  export type PermisoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermisoWhereInput
    orderBy?: PermisoOrderByWithAggregationInput | PermisoOrderByWithAggregationInput[]
    by: PermisoScalarFieldEnum[] | PermisoScalarFieldEnum
    having?: PermisoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermisoCountAggregateInputType | true
    _avg?: PermisoAvgAggregateInputType
    _sum?: PermisoSumAggregateInputType
    _min?: PermisoMinAggregateInputType
    _max?: PermisoMaxAggregateInputType
  }

  export type PermisoGroupByOutputType = {
    id: number
    nombre: string
    descripcion: string
    _count: PermisoCountAggregateOutputType | null
    _avg: PermisoAvgAggregateOutputType | null
    _sum: PermisoSumAggregateOutputType | null
    _min: PermisoMinAggregateOutputType | null
    _max: PermisoMaxAggregateOutputType | null
  }

  type GetPermisoGroupByPayload<T extends PermisoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermisoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermisoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermisoGroupByOutputType[P]>
            : GetScalarType<T[P], PermisoGroupByOutputType[P]>
        }
      >
    >


  export type PermisoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    roles?: boolean | Permiso$rolesArgs<ExtArgs>
    _count?: boolean | PermisoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permiso"]>

  export type PermisoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
  }, ExtArgs["result"]["permiso"]>

  export type PermisoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
  }, ExtArgs["result"]["permiso"]>

  export type PermisoSelectScalar = {
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
  }

  export type PermisoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nombre" | "descripcion", ExtArgs["result"]["permiso"]>
  export type PermisoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | Permiso$rolesArgs<ExtArgs>
    _count?: boolean | PermisoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PermisoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PermisoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PermisoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Permiso"
    objects: {
      roles: Prisma.$Rol_permisoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string
      descripcion: string
    }, ExtArgs["result"]["permiso"]>
    composites: {}
  }

  type PermisoGetPayload<S extends boolean | null | undefined | PermisoDefaultArgs> = $Result.GetResult<Prisma.$PermisoPayload, S>

  type PermisoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PermisoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PermisoCountAggregateInputType | true
    }

  export interface PermisoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Permiso'], meta: { name: 'Permiso' } }
    /**
     * Find zero or one Permiso that matches the filter.
     * @param {PermisoFindUniqueArgs} args - Arguments to find a Permiso
     * @example
     * // Get one Permiso
     * const permiso = await prisma.permiso.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PermisoFindUniqueArgs>(args: SelectSubset<T, PermisoFindUniqueArgs<ExtArgs>>): Prisma__PermisoClient<$Result.GetResult<Prisma.$PermisoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Permiso that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PermisoFindUniqueOrThrowArgs} args - Arguments to find a Permiso
     * @example
     * // Get one Permiso
     * const permiso = await prisma.permiso.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PermisoFindUniqueOrThrowArgs>(args: SelectSubset<T, PermisoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PermisoClient<$Result.GetResult<Prisma.$PermisoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permiso that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermisoFindFirstArgs} args - Arguments to find a Permiso
     * @example
     * // Get one Permiso
     * const permiso = await prisma.permiso.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PermisoFindFirstArgs>(args?: SelectSubset<T, PermisoFindFirstArgs<ExtArgs>>): Prisma__PermisoClient<$Result.GetResult<Prisma.$PermisoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permiso that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermisoFindFirstOrThrowArgs} args - Arguments to find a Permiso
     * @example
     * // Get one Permiso
     * const permiso = await prisma.permiso.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PermisoFindFirstOrThrowArgs>(args?: SelectSubset<T, PermisoFindFirstOrThrowArgs<ExtArgs>>): Prisma__PermisoClient<$Result.GetResult<Prisma.$PermisoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Permisos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermisoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permisos
     * const permisos = await prisma.permiso.findMany()
     * 
     * // Get first 10 Permisos
     * const permisos = await prisma.permiso.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const permisoWithIdOnly = await prisma.permiso.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PermisoFindManyArgs>(args?: SelectSubset<T, PermisoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermisoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Permiso.
     * @param {PermisoCreateArgs} args - Arguments to create a Permiso.
     * @example
     * // Create one Permiso
     * const Permiso = await prisma.permiso.create({
     *   data: {
     *     // ... data to create a Permiso
     *   }
     * })
     * 
     */
    create<T extends PermisoCreateArgs>(args: SelectSubset<T, PermisoCreateArgs<ExtArgs>>): Prisma__PermisoClient<$Result.GetResult<Prisma.$PermisoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Permisos.
     * @param {PermisoCreateManyArgs} args - Arguments to create many Permisos.
     * @example
     * // Create many Permisos
     * const permiso = await prisma.permiso.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PermisoCreateManyArgs>(args?: SelectSubset<T, PermisoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Permisos and returns the data saved in the database.
     * @param {PermisoCreateManyAndReturnArgs} args - Arguments to create many Permisos.
     * @example
     * // Create many Permisos
     * const permiso = await prisma.permiso.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Permisos and only return the `id`
     * const permisoWithIdOnly = await prisma.permiso.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PermisoCreateManyAndReturnArgs>(args?: SelectSubset<T, PermisoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermisoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Permiso.
     * @param {PermisoDeleteArgs} args - Arguments to delete one Permiso.
     * @example
     * // Delete one Permiso
     * const Permiso = await prisma.permiso.delete({
     *   where: {
     *     // ... filter to delete one Permiso
     *   }
     * })
     * 
     */
    delete<T extends PermisoDeleteArgs>(args: SelectSubset<T, PermisoDeleteArgs<ExtArgs>>): Prisma__PermisoClient<$Result.GetResult<Prisma.$PermisoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Permiso.
     * @param {PermisoUpdateArgs} args - Arguments to update one Permiso.
     * @example
     * // Update one Permiso
     * const permiso = await prisma.permiso.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PermisoUpdateArgs>(args: SelectSubset<T, PermisoUpdateArgs<ExtArgs>>): Prisma__PermisoClient<$Result.GetResult<Prisma.$PermisoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Permisos.
     * @param {PermisoDeleteManyArgs} args - Arguments to filter Permisos to delete.
     * @example
     * // Delete a few Permisos
     * const { count } = await prisma.permiso.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PermisoDeleteManyArgs>(args?: SelectSubset<T, PermisoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permisos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermisoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permisos
     * const permiso = await prisma.permiso.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PermisoUpdateManyArgs>(args: SelectSubset<T, PermisoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permisos and returns the data updated in the database.
     * @param {PermisoUpdateManyAndReturnArgs} args - Arguments to update many Permisos.
     * @example
     * // Update many Permisos
     * const permiso = await prisma.permiso.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Permisos and only return the `id`
     * const permisoWithIdOnly = await prisma.permiso.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PermisoUpdateManyAndReturnArgs>(args: SelectSubset<T, PermisoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermisoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Permiso.
     * @param {PermisoUpsertArgs} args - Arguments to update or create a Permiso.
     * @example
     * // Update or create a Permiso
     * const permiso = await prisma.permiso.upsert({
     *   create: {
     *     // ... data to create a Permiso
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permiso we want to update
     *   }
     * })
     */
    upsert<T extends PermisoUpsertArgs>(args: SelectSubset<T, PermisoUpsertArgs<ExtArgs>>): Prisma__PermisoClient<$Result.GetResult<Prisma.$PermisoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Permisos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermisoCountArgs} args - Arguments to filter Permisos to count.
     * @example
     * // Count the number of Permisos
     * const count = await prisma.permiso.count({
     *   where: {
     *     // ... the filter for the Permisos we want to count
     *   }
     * })
    **/
    count<T extends PermisoCountArgs>(
      args?: Subset<T, PermisoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermisoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permiso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermisoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermisoAggregateArgs>(args: Subset<T, PermisoAggregateArgs>): Prisma.PrismaPromise<GetPermisoAggregateType<T>>

    /**
     * Group by Permiso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermisoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PermisoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PermisoGroupByArgs['orderBy'] }
        : { orderBy?: PermisoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PermisoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermisoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Permiso model
   */
  readonly fields: PermisoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Permiso.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PermisoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    roles<T extends Permiso$rolesArgs<ExtArgs> = {}>(args?: Subset<T, Permiso$rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Rol_permisoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Permiso model
   */
  interface PermisoFieldRefs {
    readonly id: FieldRef<"Permiso", 'Int'>
    readonly nombre: FieldRef<"Permiso", 'String'>
    readonly descripcion: FieldRef<"Permiso", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Permiso findUnique
   */
  export type PermisoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permiso
     */
    select?: PermisoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permiso
     */
    omit?: PermisoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermisoInclude<ExtArgs> | null
    /**
     * Filter, which Permiso to fetch.
     */
    where: PermisoWhereUniqueInput
  }

  /**
   * Permiso findUniqueOrThrow
   */
  export type PermisoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permiso
     */
    select?: PermisoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permiso
     */
    omit?: PermisoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermisoInclude<ExtArgs> | null
    /**
     * Filter, which Permiso to fetch.
     */
    where: PermisoWhereUniqueInput
  }

  /**
   * Permiso findFirst
   */
  export type PermisoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permiso
     */
    select?: PermisoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permiso
     */
    omit?: PermisoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermisoInclude<ExtArgs> | null
    /**
     * Filter, which Permiso to fetch.
     */
    where?: PermisoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permisos to fetch.
     */
    orderBy?: PermisoOrderByWithRelationInput | PermisoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permisos.
     */
    cursor?: PermisoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permisos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permisos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permisos.
     */
    distinct?: PermisoScalarFieldEnum | PermisoScalarFieldEnum[]
  }

  /**
   * Permiso findFirstOrThrow
   */
  export type PermisoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permiso
     */
    select?: PermisoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permiso
     */
    omit?: PermisoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermisoInclude<ExtArgs> | null
    /**
     * Filter, which Permiso to fetch.
     */
    where?: PermisoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permisos to fetch.
     */
    orderBy?: PermisoOrderByWithRelationInput | PermisoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permisos.
     */
    cursor?: PermisoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permisos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permisos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permisos.
     */
    distinct?: PermisoScalarFieldEnum | PermisoScalarFieldEnum[]
  }

  /**
   * Permiso findMany
   */
  export type PermisoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permiso
     */
    select?: PermisoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permiso
     */
    omit?: PermisoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermisoInclude<ExtArgs> | null
    /**
     * Filter, which Permisos to fetch.
     */
    where?: PermisoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permisos to fetch.
     */
    orderBy?: PermisoOrderByWithRelationInput | PermisoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Permisos.
     */
    cursor?: PermisoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permisos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permisos.
     */
    skip?: number
    distinct?: PermisoScalarFieldEnum | PermisoScalarFieldEnum[]
  }

  /**
   * Permiso create
   */
  export type PermisoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permiso
     */
    select?: PermisoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permiso
     */
    omit?: PermisoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermisoInclude<ExtArgs> | null
    /**
     * The data needed to create a Permiso.
     */
    data: XOR<PermisoCreateInput, PermisoUncheckedCreateInput>
  }

  /**
   * Permiso createMany
   */
  export type PermisoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Permisos.
     */
    data: PermisoCreateManyInput | PermisoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Permiso createManyAndReturn
   */
  export type PermisoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permiso
     */
    select?: PermisoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Permiso
     */
    omit?: PermisoOmit<ExtArgs> | null
    /**
     * The data used to create many Permisos.
     */
    data: PermisoCreateManyInput | PermisoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Permiso update
   */
  export type PermisoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permiso
     */
    select?: PermisoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permiso
     */
    omit?: PermisoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermisoInclude<ExtArgs> | null
    /**
     * The data needed to update a Permiso.
     */
    data: XOR<PermisoUpdateInput, PermisoUncheckedUpdateInput>
    /**
     * Choose, which Permiso to update.
     */
    where: PermisoWhereUniqueInput
  }

  /**
   * Permiso updateMany
   */
  export type PermisoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Permisos.
     */
    data: XOR<PermisoUpdateManyMutationInput, PermisoUncheckedUpdateManyInput>
    /**
     * Filter which Permisos to update
     */
    where?: PermisoWhereInput
    /**
     * Limit how many Permisos to update.
     */
    limit?: number
  }

  /**
   * Permiso updateManyAndReturn
   */
  export type PermisoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permiso
     */
    select?: PermisoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Permiso
     */
    omit?: PermisoOmit<ExtArgs> | null
    /**
     * The data used to update Permisos.
     */
    data: XOR<PermisoUpdateManyMutationInput, PermisoUncheckedUpdateManyInput>
    /**
     * Filter which Permisos to update
     */
    where?: PermisoWhereInput
    /**
     * Limit how many Permisos to update.
     */
    limit?: number
  }

  /**
   * Permiso upsert
   */
  export type PermisoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permiso
     */
    select?: PermisoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permiso
     */
    omit?: PermisoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermisoInclude<ExtArgs> | null
    /**
     * The filter to search for the Permiso to update in case it exists.
     */
    where: PermisoWhereUniqueInput
    /**
     * In case the Permiso found by the `where` argument doesn't exist, create a new Permiso with this data.
     */
    create: XOR<PermisoCreateInput, PermisoUncheckedCreateInput>
    /**
     * In case the Permiso was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PermisoUpdateInput, PermisoUncheckedUpdateInput>
  }

  /**
   * Permiso delete
   */
  export type PermisoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permiso
     */
    select?: PermisoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permiso
     */
    omit?: PermisoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermisoInclude<ExtArgs> | null
    /**
     * Filter which Permiso to delete.
     */
    where: PermisoWhereUniqueInput
  }

  /**
   * Permiso deleteMany
   */
  export type PermisoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permisos to delete
     */
    where?: PermisoWhereInput
    /**
     * Limit how many Permisos to delete.
     */
    limit?: number
  }

  /**
   * Permiso.roles
   */
  export type Permiso$rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol_permiso
     */
    select?: Rol_permisoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rol_permiso
     */
    omit?: Rol_permisoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Rol_permisoInclude<ExtArgs> | null
    where?: Rol_permisoWhereInput
    orderBy?: Rol_permisoOrderByWithRelationInput | Rol_permisoOrderByWithRelationInput[]
    cursor?: Rol_permisoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Rol_permisoScalarFieldEnum | Rol_permisoScalarFieldEnum[]
  }

  /**
   * Permiso without action
   */
  export type PermisoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permiso
     */
    select?: PermisoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permiso
     */
    omit?: PermisoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermisoInclude<ExtArgs> | null
  }


  /**
   * Model Rol_permiso
   */

  export type AggregateRol_permiso = {
    _count: Rol_permisoCountAggregateOutputType | null
    _avg: Rol_permisoAvgAggregateOutputType | null
    _sum: Rol_permisoSumAggregateOutputType | null
    _min: Rol_permisoMinAggregateOutputType | null
    _max: Rol_permisoMaxAggregateOutputType | null
  }

  export type Rol_permisoAvgAggregateOutputType = {
    id: number | null
    rol_id: number | null
    permiso_id: number | null
  }

  export type Rol_permisoSumAggregateOutputType = {
    id: number | null
    rol_id: number | null
    permiso_id: number | null
  }

  export type Rol_permisoMinAggregateOutputType = {
    id: number | null
    rol_id: number | null
    permiso_id: number | null
  }

  export type Rol_permisoMaxAggregateOutputType = {
    id: number | null
    rol_id: number | null
    permiso_id: number | null
  }

  export type Rol_permisoCountAggregateOutputType = {
    id: number
    rol_id: number
    permiso_id: number
    _all: number
  }


  export type Rol_permisoAvgAggregateInputType = {
    id?: true
    rol_id?: true
    permiso_id?: true
  }

  export type Rol_permisoSumAggregateInputType = {
    id?: true
    rol_id?: true
    permiso_id?: true
  }

  export type Rol_permisoMinAggregateInputType = {
    id?: true
    rol_id?: true
    permiso_id?: true
  }

  export type Rol_permisoMaxAggregateInputType = {
    id?: true
    rol_id?: true
    permiso_id?: true
  }

  export type Rol_permisoCountAggregateInputType = {
    id?: true
    rol_id?: true
    permiso_id?: true
    _all?: true
  }

  export type Rol_permisoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rol_permiso to aggregate.
     */
    where?: Rol_permisoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rol_permisos to fetch.
     */
    orderBy?: Rol_permisoOrderByWithRelationInput | Rol_permisoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Rol_permisoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rol_permisos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rol_permisos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Rol_permisos
    **/
    _count?: true | Rol_permisoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Rol_permisoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Rol_permisoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Rol_permisoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Rol_permisoMaxAggregateInputType
  }

  export type GetRol_permisoAggregateType<T extends Rol_permisoAggregateArgs> = {
        [P in keyof T & keyof AggregateRol_permiso]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRol_permiso[P]>
      : GetScalarType<T[P], AggregateRol_permiso[P]>
  }




  export type Rol_permisoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Rol_permisoWhereInput
    orderBy?: Rol_permisoOrderByWithAggregationInput | Rol_permisoOrderByWithAggregationInput[]
    by: Rol_permisoScalarFieldEnum[] | Rol_permisoScalarFieldEnum
    having?: Rol_permisoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Rol_permisoCountAggregateInputType | true
    _avg?: Rol_permisoAvgAggregateInputType
    _sum?: Rol_permisoSumAggregateInputType
    _min?: Rol_permisoMinAggregateInputType
    _max?: Rol_permisoMaxAggregateInputType
  }

  export type Rol_permisoGroupByOutputType = {
    id: number
    rol_id: number
    permiso_id: number
    _count: Rol_permisoCountAggregateOutputType | null
    _avg: Rol_permisoAvgAggregateOutputType | null
    _sum: Rol_permisoSumAggregateOutputType | null
    _min: Rol_permisoMinAggregateOutputType | null
    _max: Rol_permisoMaxAggregateOutputType | null
  }

  type GetRol_permisoGroupByPayload<T extends Rol_permisoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Rol_permisoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Rol_permisoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Rol_permisoGroupByOutputType[P]>
            : GetScalarType<T[P], Rol_permisoGroupByOutputType[P]>
        }
      >
    >


  export type Rol_permisoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rol_id?: boolean
    permiso_id?: boolean
    permiso?: boolean | PermisoDefaultArgs<ExtArgs>
    rol?: boolean | RolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rol_permiso"]>

  export type Rol_permisoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rol_id?: boolean
    permiso_id?: boolean
    permiso?: boolean | PermisoDefaultArgs<ExtArgs>
    rol?: boolean | RolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rol_permiso"]>

  export type Rol_permisoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rol_id?: boolean
    permiso_id?: boolean
    permiso?: boolean | PermisoDefaultArgs<ExtArgs>
    rol?: boolean | RolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rol_permiso"]>

  export type Rol_permisoSelectScalar = {
    id?: boolean
    rol_id?: boolean
    permiso_id?: boolean
  }

  export type Rol_permisoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "rol_id" | "permiso_id", ExtArgs["result"]["rol_permiso"]>
  export type Rol_permisoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permiso?: boolean | PermisoDefaultArgs<ExtArgs>
    rol?: boolean | RolDefaultArgs<ExtArgs>
  }
  export type Rol_permisoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permiso?: boolean | PermisoDefaultArgs<ExtArgs>
    rol?: boolean | RolDefaultArgs<ExtArgs>
  }
  export type Rol_permisoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permiso?: boolean | PermisoDefaultArgs<ExtArgs>
    rol?: boolean | RolDefaultArgs<ExtArgs>
  }

  export type $Rol_permisoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Rol_permiso"
    objects: {
      permiso: Prisma.$PermisoPayload<ExtArgs>
      rol: Prisma.$RolPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      rol_id: number
      permiso_id: number
    }, ExtArgs["result"]["rol_permiso"]>
    composites: {}
  }

  type Rol_permisoGetPayload<S extends boolean | null | undefined | Rol_permisoDefaultArgs> = $Result.GetResult<Prisma.$Rol_permisoPayload, S>

  type Rol_permisoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Rol_permisoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Rol_permisoCountAggregateInputType | true
    }

  export interface Rol_permisoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Rol_permiso'], meta: { name: 'Rol_permiso' } }
    /**
     * Find zero or one Rol_permiso that matches the filter.
     * @param {Rol_permisoFindUniqueArgs} args - Arguments to find a Rol_permiso
     * @example
     * // Get one Rol_permiso
     * const rol_permiso = await prisma.rol_permiso.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Rol_permisoFindUniqueArgs>(args: SelectSubset<T, Rol_permisoFindUniqueArgs<ExtArgs>>): Prisma__Rol_permisoClient<$Result.GetResult<Prisma.$Rol_permisoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Rol_permiso that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Rol_permisoFindUniqueOrThrowArgs} args - Arguments to find a Rol_permiso
     * @example
     * // Get one Rol_permiso
     * const rol_permiso = await prisma.rol_permiso.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Rol_permisoFindUniqueOrThrowArgs>(args: SelectSubset<T, Rol_permisoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Rol_permisoClient<$Result.GetResult<Prisma.$Rol_permisoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rol_permiso that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Rol_permisoFindFirstArgs} args - Arguments to find a Rol_permiso
     * @example
     * // Get one Rol_permiso
     * const rol_permiso = await prisma.rol_permiso.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Rol_permisoFindFirstArgs>(args?: SelectSubset<T, Rol_permisoFindFirstArgs<ExtArgs>>): Prisma__Rol_permisoClient<$Result.GetResult<Prisma.$Rol_permisoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rol_permiso that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Rol_permisoFindFirstOrThrowArgs} args - Arguments to find a Rol_permiso
     * @example
     * // Get one Rol_permiso
     * const rol_permiso = await prisma.rol_permiso.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Rol_permisoFindFirstOrThrowArgs>(args?: SelectSubset<T, Rol_permisoFindFirstOrThrowArgs<ExtArgs>>): Prisma__Rol_permisoClient<$Result.GetResult<Prisma.$Rol_permisoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Rol_permisos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Rol_permisoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rol_permisos
     * const rol_permisos = await prisma.rol_permiso.findMany()
     * 
     * // Get first 10 Rol_permisos
     * const rol_permisos = await prisma.rol_permiso.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rol_permisoWithIdOnly = await prisma.rol_permiso.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Rol_permisoFindManyArgs>(args?: SelectSubset<T, Rol_permisoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Rol_permisoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Rol_permiso.
     * @param {Rol_permisoCreateArgs} args - Arguments to create a Rol_permiso.
     * @example
     * // Create one Rol_permiso
     * const Rol_permiso = await prisma.rol_permiso.create({
     *   data: {
     *     // ... data to create a Rol_permiso
     *   }
     * })
     * 
     */
    create<T extends Rol_permisoCreateArgs>(args: SelectSubset<T, Rol_permisoCreateArgs<ExtArgs>>): Prisma__Rol_permisoClient<$Result.GetResult<Prisma.$Rol_permisoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Rol_permisos.
     * @param {Rol_permisoCreateManyArgs} args - Arguments to create many Rol_permisos.
     * @example
     * // Create many Rol_permisos
     * const rol_permiso = await prisma.rol_permiso.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Rol_permisoCreateManyArgs>(args?: SelectSubset<T, Rol_permisoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Rol_permisos and returns the data saved in the database.
     * @param {Rol_permisoCreateManyAndReturnArgs} args - Arguments to create many Rol_permisos.
     * @example
     * // Create many Rol_permisos
     * const rol_permiso = await prisma.rol_permiso.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Rol_permisos and only return the `id`
     * const rol_permisoWithIdOnly = await prisma.rol_permiso.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Rol_permisoCreateManyAndReturnArgs>(args?: SelectSubset<T, Rol_permisoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Rol_permisoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Rol_permiso.
     * @param {Rol_permisoDeleteArgs} args - Arguments to delete one Rol_permiso.
     * @example
     * // Delete one Rol_permiso
     * const Rol_permiso = await prisma.rol_permiso.delete({
     *   where: {
     *     // ... filter to delete one Rol_permiso
     *   }
     * })
     * 
     */
    delete<T extends Rol_permisoDeleteArgs>(args: SelectSubset<T, Rol_permisoDeleteArgs<ExtArgs>>): Prisma__Rol_permisoClient<$Result.GetResult<Prisma.$Rol_permisoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Rol_permiso.
     * @param {Rol_permisoUpdateArgs} args - Arguments to update one Rol_permiso.
     * @example
     * // Update one Rol_permiso
     * const rol_permiso = await prisma.rol_permiso.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Rol_permisoUpdateArgs>(args: SelectSubset<T, Rol_permisoUpdateArgs<ExtArgs>>): Prisma__Rol_permisoClient<$Result.GetResult<Prisma.$Rol_permisoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Rol_permisos.
     * @param {Rol_permisoDeleteManyArgs} args - Arguments to filter Rol_permisos to delete.
     * @example
     * // Delete a few Rol_permisos
     * const { count } = await prisma.rol_permiso.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Rol_permisoDeleteManyArgs>(args?: SelectSubset<T, Rol_permisoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rol_permisos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Rol_permisoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rol_permisos
     * const rol_permiso = await prisma.rol_permiso.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Rol_permisoUpdateManyArgs>(args: SelectSubset<T, Rol_permisoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rol_permisos and returns the data updated in the database.
     * @param {Rol_permisoUpdateManyAndReturnArgs} args - Arguments to update many Rol_permisos.
     * @example
     * // Update many Rol_permisos
     * const rol_permiso = await prisma.rol_permiso.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Rol_permisos and only return the `id`
     * const rol_permisoWithIdOnly = await prisma.rol_permiso.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends Rol_permisoUpdateManyAndReturnArgs>(args: SelectSubset<T, Rol_permisoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Rol_permisoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Rol_permiso.
     * @param {Rol_permisoUpsertArgs} args - Arguments to update or create a Rol_permiso.
     * @example
     * // Update or create a Rol_permiso
     * const rol_permiso = await prisma.rol_permiso.upsert({
     *   create: {
     *     // ... data to create a Rol_permiso
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rol_permiso we want to update
     *   }
     * })
     */
    upsert<T extends Rol_permisoUpsertArgs>(args: SelectSubset<T, Rol_permisoUpsertArgs<ExtArgs>>): Prisma__Rol_permisoClient<$Result.GetResult<Prisma.$Rol_permisoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Rol_permisos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Rol_permisoCountArgs} args - Arguments to filter Rol_permisos to count.
     * @example
     * // Count the number of Rol_permisos
     * const count = await prisma.rol_permiso.count({
     *   where: {
     *     // ... the filter for the Rol_permisos we want to count
     *   }
     * })
    **/
    count<T extends Rol_permisoCountArgs>(
      args?: Subset<T, Rol_permisoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Rol_permisoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rol_permiso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Rol_permisoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Rol_permisoAggregateArgs>(args: Subset<T, Rol_permisoAggregateArgs>): Prisma.PrismaPromise<GetRol_permisoAggregateType<T>>

    /**
     * Group by Rol_permiso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Rol_permisoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Rol_permisoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Rol_permisoGroupByArgs['orderBy'] }
        : { orderBy?: Rol_permisoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Rol_permisoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRol_permisoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Rol_permiso model
   */
  readonly fields: Rol_permisoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Rol_permiso.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Rol_permisoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    permiso<T extends PermisoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PermisoDefaultArgs<ExtArgs>>): Prisma__PermisoClient<$Result.GetResult<Prisma.$PermisoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    rol<T extends RolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RolDefaultArgs<ExtArgs>>): Prisma__RolClient<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Rol_permiso model
   */
  interface Rol_permisoFieldRefs {
    readonly id: FieldRef<"Rol_permiso", 'Int'>
    readonly rol_id: FieldRef<"Rol_permiso", 'Int'>
    readonly permiso_id: FieldRef<"Rol_permiso", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Rol_permiso findUnique
   */
  export type Rol_permisoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol_permiso
     */
    select?: Rol_permisoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rol_permiso
     */
    omit?: Rol_permisoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Rol_permisoInclude<ExtArgs> | null
    /**
     * Filter, which Rol_permiso to fetch.
     */
    where: Rol_permisoWhereUniqueInput
  }

  /**
   * Rol_permiso findUniqueOrThrow
   */
  export type Rol_permisoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol_permiso
     */
    select?: Rol_permisoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rol_permiso
     */
    omit?: Rol_permisoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Rol_permisoInclude<ExtArgs> | null
    /**
     * Filter, which Rol_permiso to fetch.
     */
    where: Rol_permisoWhereUniqueInput
  }

  /**
   * Rol_permiso findFirst
   */
  export type Rol_permisoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol_permiso
     */
    select?: Rol_permisoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rol_permiso
     */
    omit?: Rol_permisoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Rol_permisoInclude<ExtArgs> | null
    /**
     * Filter, which Rol_permiso to fetch.
     */
    where?: Rol_permisoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rol_permisos to fetch.
     */
    orderBy?: Rol_permisoOrderByWithRelationInput | Rol_permisoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rol_permisos.
     */
    cursor?: Rol_permisoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rol_permisos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rol_permisos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rol_permisos.
     */
    distinct?: Rol_permisoScalarFieldEnum | Rol_permisoScalarFieldEnum[]
  }

  /**
   * Rol_permiso findFirstOrThrow
   */
  export type Rol_permisoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol_permiso
     */
    select?: Rol_permisoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rol_permiso
     */
    omit?: Rol_permisoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Rol_permisoInclude<ExtArgs> | null
    /**
     * Filter, which Rol_permiso to fetch.
     */
    where?: Rol_permisoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rol_permisos to fetch.
     */
    orderBy?: Rol_permisoOrderByWithRelationInput | Rol_permisoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rol_permisos.
     */
    cursor?: Rol_permisoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rol_permisos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rol_permisos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rol_permisos.
     */
    distinct?: Rol_permisoScalarFieldEnum | Rol_permisoScalarFieldEnum[]
  }

  /**
   * Rol_permiso findMany
   */
  export type Rol_permisoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol_permiso
     */
    select?: Rol_permisoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rol_permiso
     */
    omit?: Rol_permisoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Rol_permisoInclude<ExtArgs> | null
    /**
     * Filter, which Rol_permisos to fetch.
     */
    where?: Rol_permisoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rol_permisos to fetch.
     */
    orderBy?: Rol_permisoOrderByWithRelationInput | Rol_permisoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Rol_permisos.
     */
    cursor?: Rol_permisoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rol_permisos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rol_permisos.
     */
    skip?: number
    distinct?: Rol_permisoScalarFieldEnum | Rol_permisoScalarFieldEnum[]
  }

  /**
   * Rol_permiso create
   */
  export type Rol_permisoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol_permiso
     */
    select?: Rol_permisoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rol_permiso
     */
    omit?: Rol_permisoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Rol_permisoInclude<ExtArgs> | null
    /**
     * The data needed to create a Rol_permiso.
     */
    data: XOR<Rol_permisoCreateInput, Rol_permisoUncheckedCreateInput>
  }

  /**
   * Rol_permiso createMany
   */
  export type Rol_permisoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Rol_permisos.
     */
    data: Rol_permisoCreateManyInput | Rol_permisoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Rol_permiso createManyAndReturn
   */
  export type Rol_permisoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol_permiso
     */
    select?: Rol_permisoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Rol_permiso
     */
    omit?: Rol_permisoOmit<ExtArgs> | null
    /**
     * The data used to create many Rol_permisos.
     */
    data: Rol_permisoCreateManyInput | Rol_permisoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Rol_permisoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Rol_permiso update
   */
  export type Rol_permisoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol_permiso
     */
    select?: Rol_permisoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rol_permiso
     */
    omit?: Rol_permisoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Rol_permisoInclude<ExtArgs> | null
    /**
     * The data needed to update a Rol_permiso.
     */
    data: XOR<Rol_permisoUpdateInput, Rol_permisoUncheckedUpdateInput>
    /**
     * Choose, which Rol_permiso to update.
     */
    where: Rol_permisoWhereUniqueInput
  }

  /**
   * Rol_permiso updateMany
   */
  export type Rol_permisoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Rol_permisos.
     */
    data: XOR<Rol_permisoUpdateManyMutationInput, Rol_permisoUncheckedUpdateManyInput>
    /**
     * Filter which Rol_permisos to update
     */
    where?: Rol_permisoWhereInput
    /**
     * Limit how many Rol_permisos to update.
     */
    limit?: number
  }

  /**
   * Rol_permiso updateManyAndReturn
   */
  export type Rol_permisoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol_permiso
     */
    select?: Rol_permisoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Rol_permiso
     */
    omit?: Rol_permisoOmit<ExtArgs> | null
    /**
     * The data used to update Rol_permisos.
     */
    data: XOR<Rol_permisoUpdateManyMutationInput, Rol_permisoUncheckedUpdateManyInput>
    /**
     * Filter which Rol_permisos to update
     */
    where?: Rol_permisoWhereInput
    /**
     * Limit how many Rol_permisos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Rol_permisoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Rol_permiso upsert
   */
  export type Rol_permisoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol_permiso
     */
    select?: Rol_permisoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rol_permiso
     */
    omit?: Rol_permisoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Rol_permisoInclude<ExtArgs> | null
    /**
     * The filter to search for the Rol_permiso to update in case it exists.
     */
    where: Rol_permisoWhereUniqueInput
    /**
     * In case the Rol_permiso found by the `where` argument doesn't exist, create a new Rol_permiso with this data.
     */
    create: XOR<Rol_permisoCreateInput, Rol_permisoUncheckedCreateInput>
    /**
     * In case the Rol_permiso was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Rol_permisoUpdateInput, Rol_permisoUncheckedUpdateInput>
  }

  /**
   * Rol_permiso delete
   */
  export type Rol_permisoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol_permiso
     */
    select?: Rol_permisoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rol_permiso
     */
    omit?: Rol_permisoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Rol_permisoInclude<ExtArgs> | null
    /**
     * Filter which Rol_permiso to delete.
     */
    where: Rol_permisoWhereUniqueInput
  }

  /**
   * Rol_permiso deleteMany
   */
  export type Rol_permisoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rol_permisos to delete
     */
    where?: Rol_permisoWhereInput
    /**
     * Limit how many Rol_permisos to delete.
     */
    limit?: number
  }

  /**
   * Rol_permiso without action
   */
  export type Rol_permisoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol_permiso
     */
    select?: Rol_permisoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rol_permiso
     */
    omit?: Rol_permisoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Rol_permisoInclude<ExtArgs> | null
  }


  /**
   * Model Competidor
   */

  export type AggregateCompetidor = {
    _count: CompetidorCountAggregateOutputType | null
    _avg: CompetidorAvgAggregateOutputType | null
    _sum: CompetidorSumAggregateOutputType | null
    _min: CompetidorMinAggregateOutputType | null
    _max: CompetidorMaxAggregateOutputType | null
  }

  export type CompetidorAvgAggregateOutputType = {
    colegio_id: number | null
    provincia_id: number | null
  }

  export type CompetidorSumAggregateOutputType = {
    colegio_id: number | null
    provincia_id: number | null
  }

  export type CompetidorMinAggregateOutputType = {
    id: string | null
    usuario_id: string | null
    colegio_id: number | null
    provincia_id: number | null
    carnet_identidad: string | null
    fecha_nacimiento: Date | null
  }

  export type CompetidorMaxAggregateOutputType = {
    id: string | null
    usuario_id: string | null
    colegio_id: number | null
    provincia_id: number | null
    carnet_identidad: string | null
    fecha_nacimiento: Date | null
  }

  export type CompetidorCountAggregateOutputType = {
    id: number
    usuario_id: number
    colegio_id: number
    provincia_id: number
    carnet_identidad: number
    fecha_nacimiento: number
    _all: number
  }


  export type CompetidorAvgAggregateInputType = {
    colegio_id?: true
    provincia_id?: true
  }

  export type CompetidorSumAggregateInputType = {
    colegio_id?: true
    provincia_id?: true
  }

  export type CompetidorMinAggregateInputType = {
    id?: true
    usuario_id?: true
    colegio_id?: true
    provincia_id?: true
    carnet_identidad?: true
    fecha_nacimiento?: true
  }

  export type CompetidorMaxAggregateInputType = {
    id?: true
    usuario_id?: true
    colegio_id?: true
    provincia_id?: true
    carnet_identidad?: true
    fecha_nacimiento?: true
  }

  export type CompetidorCountAggregateInputType = {
    id?: true
    usuario_id?: true
    colegio_id?: true
    provincia_id?: true
    carnet_identidad?: true
    fecha_nacimiento?: true
    _all?: true
  }

  export type CompetidorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Competidor to aggregate.
     */
    where?: CompetidorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Competidors to fetch.
     */
    orderBy?: CompetidorOrderByWithRelationInput | CompetidorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompetidorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Competidors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Competidors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Competidors
    **/
    _count?: true | CompetidorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompetidorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompetidorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompetidorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompetidorMaxAggregateInputType
  }

  export type GetCompetidorAggregateType<T extends CompetidorAggregateArgs> = {
        [P in keyof T & keyof AggregateCompetidor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompetidor[P]>
      : GetScalarType<T[P], AggregateCompetidor[P]>
  }




  export type CompetidorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompetidorWhereInput
    orderBy?: CompetidorOrderByWithAggregationInput | CompetidorOrderByWithAggregationInput[]
    by: CompetidorScalarFieldEnum[] | CompetidorScalarFieldEnum
    having?: CompetidorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompetidorCountAggregateInputType | true
    _avg?: CompetidorAvgAggregateInputType
    _sum?: CompetidorSumAggregateInputType
    _min?: CompetidorMinAggregateInputType
    _max?: CompetidorMaxAggregateInputType
  }

  export type CompetidorGroupByOutputType = {
    id: string
    usuario_id: string
    colegio_id: number
    provincia_id: number
    carnet_identidad: string
    fecha_nacimiento: Date
    _count: CompetidorCountAggregateOutputType | null
    _avg: CompetidorAvgAggregateOutputType | null
    _sum: CompetidorSumAggregateOutputType | null
    _min: CompetidorMinAggregateOutputType | null
    _max: CompetidorMaxAggregateOutputType | null
  }

  type GetCompetidorGroupByPayload<T extends CompetidorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompetidorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompetidorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompetidorGroupByOutputType[P]>
            : GetScalarType<T[P], CompetidorGroupByOutputType[P]>
        }
      >
    >


  export type CompetidorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuario_id?: boolean
    colegio_id?: boolean
    provincia_id?: boolean
    carnet_identidad?: boolean
    fecha_nacimiento?: boolean
    colegio?: boolean | ColegioDefaultArgs<ExtArgs>
    provincia?: boolean | ProvinciaDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    Inscripciones?: boolean | Competidor$InscripcionesArgs<ExtArgs>
    Inscripcion?: boolean | Competidor$InscripcionArgs<ExtArgs>
    _count?: boolean | CompetidorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["competidor"]>

  export type CompetidorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuario_id?: boolean
    colegio_id?: boolean
    provincia_id?: boolean
    carnet_identidad?: boolean
    fecha_nacimiento?: boolean
    colegio?: boolean | ColegioDefaultArgs<ExtArgs>
    provincia?: boolean | ProvinciaDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["competidor"]>

  export type CompetidorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuario_id?: boolean
    colegio_id?: boolean
    provincia_id?: boolean
    carnet_identidad?: boolean
    fecha_nacimiento?: boolean
    colegio?: boolean | ColegioDefaultArgs<ExtArgs>
    provincia?: boolean | ProvinciaDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["competidor"]>

  export type CompetidorSelectScalar = {
    id?: boolean
    usuario_id?: boolean
    colegio_id?: boolean
    provincia_id?: boolean
    carnet_identidad?: boolean
    fecha_nacimiento?: boolean
  }

  export type CompetidorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "usuario_id" | "colegio_id" | "provincia_id" | "carnet_identidad" | "fecha_nacimiento", ExtArgs["result"]["competidor"]>
  export type CompetidorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    colegio?: boolean | ColegioDefaultArgs<ExtArgs>
    provincia?: boolean | ProvinciaDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    Inscripciones?: boolean | Competidor$InscripcionesArgs<ExtArgs>
    Inscripcion?: boolean | Competidor$InscripcionArgs<ExtArgs>
    _count?: boolean | CompetidorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CompetidorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    colegio?: boolean | ColegioDefaultArgs<ExtArgs>
    provincia?: boolean | ProvinciaDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type CompetidorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    colegio?: boolean | ColegioDefaultArgs<ExtArgs>
    provincia?: boolean | ProvinciaDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $CompetidorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Competidor"
    objects: {
      colegio: Prisma.$ColegioPayload<ExtArgs>
      provincia: Prisma.$ProvinciaPayload<ExtArgs>
      usuario: Prisma.$UsuarioPayload<ExtArgs>
      Inscripciones: Prisma.$Inscripcion_tutorPayload<ExtArgs>[]
      Inscripcion: Prisma.$InscripcionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      usuario_id: string
      colegio_id: number
      provincia_id: number
      carnet_identidad: string
      fecha_nacimiento: Date
    }, ExtArgs["result"]["competidor"]>
    composites: {}
  }

  type CompetidorGetPayload<S extends boolean | null | undefined | CompetidorDefaultArgs> = $Result.GetResult<Prisma.$CompetidorPayload, S>

  type CompetidorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CompetidorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompetidorCountAggregateInputType | true
    }

  export interface CompetidorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Competidor'], meta: { name: 'Competidor' } }
    /**
     * Find zero or one Competidor that matches the filter.
     * @param {CompetidorFindUniqueArgs} args - Arguments to find a Competidor
     * @example
     * // Get one Competidor
     * const competidor = await prisma.competidor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompetidorFindUniqueArgs>(args: SelectSubset<T, CompetidorFindUniqueArgs<ExtArgs>>): Prisma__CompetidorClient<$Result.GetResult<Prisma.$CompetidorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Competidor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompetidorFindUniqueOrThrowArgs} args - Arguments to find a Competidor
     * @example
     * // Get one Competidor
     * const competidor = await prisma.competidor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompetidorFindUniqueOrThrowArgs>(args: SelectSubset<T, CompetidorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompetidorClient<$Result.GetResult<Prisma.$CompetidorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Competidor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompetidorFindFirstArgs} args - Arguments to find a Competidor
     * @example
     * // Get one Competidor
     * const competidor = await prisma.competidor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompetidorFindFirstArgs>(args?: SelectSubset<T, CompetidorFindFirstArgs<ExtArgs>>): Prisma__CompetidorClient<$Result.GetResult<Prisma.$CompetidorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Competidor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompetidorFindFirstOrThrowArgs} args - Arguments to find a Competidor
     * @example
     * // Get one Competidor
     * const competidor = await prisma.competidor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompetidorFindFirstOrThrowArgs>(args?: SelectSubset<T, CompetidorFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompetidorClient<$Result.GetResult<Prisma.$CompetidorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Competidors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompetidorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Competidors
     * const competidors = await prisma.competidor.findMany()
     * 
     * // Get first 10 Competidors
     * const competidors = await prisma.competidor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const competidorWithIdOnly = await prisma.competidor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompetidorFindManyArgs>(args?: SelectSubset<T, CompetidorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompetidorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Competidor.
     * @param {CompetidorCreateArgs} args - Arguments to create a Competidor.
     * @example
     * // Create one Competidor
     * const Competidor = await prisma.competidor.create({
     *   data: {
     *     // ... data to create a Competidor
     *   }
     * })
     * 
     */
    create<T extends CompetidorCreateArgs>(args: SelectSubset<T, CompetidorCreateArgs<ExtArgs>>): Prisma__CompetidorClient<$Result.GetResult<Prisma.$CompetidorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Competidors.
     * @param {CompetidorCreateManyArgs} args - Arguments to create many Competidors.
     * @example
     * // Create many Competidors
     * const competidor = await prisma.competidor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompetidorCreateManyArgs>(args?: SelectSubset<T, CompetidorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Competidors and returns the data saved in the database.
     * @param {CompetidorCreateManyAndReturnArgs} args - Arguments to create many Competidors.
     * @example
     * // Create many Competidors
     * const competidor = await prisma.competidor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Competidors and only return the `id`
     * const competidorWithIdOnly = await prisma.competidor.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompetidorCreateManyAndReturnArgs>(args?: SelectSubset<T, CompetidorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompetidorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Competidor.
     * @param {CompetidorDeleteArgs} args - Arguments to delete one Competidor.
     * @example
     * // Delete one Competidor
     * const Competidor = await prisma.competidor.delete({
     *   where: {
     *     // ... filter to delete one Competidor
     *   }
     * })
     * 
     */
    delete<T extends CompetidorDeleteArgs>(args: SelectSubset<T, CompetidorDeleteArgs<ExtArgs>>): Prisma__CompetidorClient<$Result.GetResult<Prisma.$CompetidorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Competidor.
     * @param {CompetidorUpdateArgs} args - Arguments to update one Competidor.
     * @example
     * // Update one Competidor
     * const competidor = await prisma.competidor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompetidorUpdateArgs>(args: SelectSubset<T, CompetidorUpdateArgs<ExtArgs>>): Prisma__CompetidorClient<$Result.GetResult<Prisma.$CompetidorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Competidors.
     * @param {CompetidorDeleteManyArgs} args - Arguments to filter Competidors to delete.
     * @example
     * // Delete a few Competidors
     * const { count } = await prisma.competidor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompetidorDeleteManyArgs>(args?: SelectSubset<T, CompetidorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Competidors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompetidorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Competidors
     * const competidor = await prisma.competidor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompetidorUpdateManyArgs>(args: SelectSubset<T, CompetidorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Competidors and returns the data updated in the database.
     * @param {CompetidorUpdateManyAndReturnArgs} args - Arguments to update many Competidors.
     * @example
     * // Update many Competidors
     * const competidor = await prisma.competidor.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Competidors and only return the `id`
     * const competidorWithIdOnly = await prisma.competidor.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CompetidorUpdateManyAndReturnArgs>(args: SelectSubset<T, CompetidorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompetidorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Competidor.
     * @param {CompetidorUpsertArgs} args - Arguments to update or create a Competidor.
     * @example
     * // Update or create a Competidor
     * const competidor = await prisma.competidor.upsert({
     *   create: {
     *     // ... data to create a Competidor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Competidor we want to update
     *   }
     * })
     */
    upsert<T extends CompetidorUpsertArgs>(args: SelectSubset<T, CompetidorUpsertArgs<ExtArgs>>): Prisma__CompetidorClient<$Result.GetResult<Prisma.$CompetidorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Competidors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompetidorCountArgs} args - Arguments to filter Competidors to count.
     * @example
     * // Count the number of Competidors
     * const count = await prisma.competidor.count({
     *   where: {
     *     // ... the filter for the Competidors we want to count
     *   }
     * })
    **/
    count<T extends CompetidorCountArgs>(
      args?: Subset<T, CompetidorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompetidorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Competidor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompetidorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompetidorAggregateArgs>(args: Subset<T, CompetidorAggregateArgs>): Prisma.PrismaPromise<GetCompetidorAggregateType<T>>

    /**
     * Group by Competidor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompetidorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompetidorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompetidorGroupByArgs['orderBy'] }
        : { orderBy?: CompetidorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompetidorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompetidorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Competidor model
   */
  readonly fields: CompetidorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Competidor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompetidorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    colegio<T extends ColegioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ColegioDefaultArgs<ExtArgs>>): Prisma__ColegioClient<$Result.GetResult<Prisma.$ColegioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    provincia<T extends ProvinciaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProvinciaDefaultArgs<ExtArgs>>): Prisma__ProvinciaClient<$Result.GetResult<Prisma.$ProvinciaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Inscripciones<T extends Competidor$InscripcionesArgs<ExtArgs> = {}>(args?: Subset<T, Competidor$InscripcionesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Inscripcion_tutorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Inscripcion<T extends Competidor$InscripcionArgs<ExtArgs> = {}>(args?: Subset<T, Competidor$InscripcionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InscripcionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Competidor model
   */
  interface CompetidorFieldRefs {
    readonly id: FieldRef<"Competidor", 'String'>
    readonly usuario_id: FieldRef<"Competidor", 'String'>
    readonly colegio_id: FieldRef<"Competidor", 'Int'>
    readonly provincia_id: FieldRef<"Competidor", 'Int'>
    readonly carnet_identidad: FieldRef<"Competidor", 'String'>
    readonly fecha_nacimiento: FieldRef<"Competidor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Competidor findUnique
   */
  export type CompetidorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Competidor
     */
    select?: CompetidorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Competidor
     */
    omit?: CompetidorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompetidorInclude<ExtArgs> | null
    /**
     * Filter, which Competidor to fetch.
     */
    where: CompetidorWhereUniqueInput
  }

  /**
   * Competidor findUniqueOrThrow
   */
  export type CompetidorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Competidor
     */
    select?: CompetidorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Competidor
     */
    omit?: CompetidorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompetidorInclude<ExtArgs> | null
    /**
     * Filter, which Competidor to fetch.
     */
    where: CompetidorWhereUniqueInput
  }

  /**
   * Competidor findFirst
   */
  export type CompetidorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Competidor
     */
    select?: CompetidorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Competidor
     */
    omit?: CompetidorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompetidorInclude<ExtArgs> | null
    /**
     * Filter, which Competidor to fetch.
     */
    where?: CompetidorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Competidors to fetch.
     */
    orderBy?: CompetidorOrderByWithRelationInput | CompetidorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Competidors.
     */
    cursor?: CompetidorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Competidors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Competidors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Competidors.
     */
    distinct?: CompetidorScalarFieldEnum | CompetidorScalarFieldEnum[]
  }

  /**
   * Competidor findFirstOrThrow
   */
  export type CompetidorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Competidor
     */
    select?: CompetidorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Competidor
     */
    omit?: CompetidorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompetidorInclude<ExtArgs> | null
    /**
     * Filter, which Competidor to fetch.
     */
    where?: CompetidorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Competidors to fetch.
     */
    orderBy?: CompetidorOrderByWithRelationInput | CompetidorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Competidors.
     */
    cursor?: CompetidorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Competidors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Competidors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Competidors.
     */
    distinct?: CompetidorScalarFieldEnum | CompetidorScalarFieldEnum[]
  }

  /**
   * Competidor findMany
   */
  export type CompetidorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Competidor
     */
    select?: CompetidorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Competidor
     */
    omit?: CompetidorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompetidorInclude<ExtArgs> | null
    /**
     * Filter, which Competidors to fetch.
     */
    where?: CompetidorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Competidors to fetch.
     */
    orderBy?: CompetidorOrderByWithRelationInput | CompetidorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Competidors.
     */
    cursor?: CompetidorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Competidors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Competidors.
     */
    skip?: number
    distinct?: CompetidorScalarFieldEnum | CompetidorScalarFieldEnum[]
  }

  /**
   * Competidor create
   */
  export type CompetidorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Competidor
     */
    select?: CompetidorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Competidor
     */
    omit?: CompetidorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompetidorInclude<ExtArgs> | null
    /**
     * The data needed to create a Competidor.
     */
    data: XOR<CompetidorCreateInput, CompetidorUncheckedCreateInput>
  }

  /**
   * Competidor createMany
   */
  export type CompetidorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Competidors.
     */
    data: CompetidorCreateManyInput | CompetidorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Competidor createManyAndReturn
   */
  export type CompetidorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Competidor
     */
    select?: CompetidorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Competidor
     */
    omit?: CompetidorOmit<ExtArgs> | null
    /**
     * The data used to create many Competidors.
     */
    data: CompetidorCreateManyInput | CompetidorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompetidorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Competidor update
   */
  export type CompetidorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Competidor
     */
    select?: CompetidorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Competidor
     */
    omit?: CompetidorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompetidorInclude<ExtArgs> | null
    /**
     * The data needed to update a Competidor.
     */
    data: XOR<CompetidorUpdateInput, CompetidorUncheckedUpdateInput>
    /**
     * Choose, which Competidor to update.
     */
    where: CompetidorWhereUniqueInput
  }

  /**
   * Competidor updateMany
   */
  export type CompetidorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Competidors.
     */
    data: XOR<CompetidorUpdateManyMutationInput, CompetidorUncheckedUpdateManyInput>
    /**
     * Filter which Competidors to update
     */
    where?: CompetidorWhereInput
    /**
     * Limit how many Competidors to update.
     */
    limit?: number
  }

  /**
   * Competidor updateManyAndReturn
   */
  export type CompetidorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Competidor
     */
    select?: CompetidorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Competidor
     */
    omit?: CompetidorOmit<ExtArgs> | null
    /**
     * The data used to update Competidors.
     */
    data: XOR<CompetidorUpdateManyMutationInput, CompetidorUncheckedUpdateManyInput>
    /**
     * Filter which Competidors to update
     */
    where?: CompetidorWhereInput
    /**
     * Limit how many Competidors to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompetidorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Competidor upsert
   */
  export type CompetidorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Competidor
     */
    select?: CompetidorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Competidor
     */
    omit?: CompetidorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompetidorInclude<ExtArgs> | null
    /**
     * The filter to search for the Competidor to update in case it exists.
     */
    where: CompetidorWhereUniqueInput
    /**
     * In case the Competidor found by the `where` argument doesn't exist, create a new Competidor with this data.
     */
    create: XOR<CompetidorCreateInput, CompetidorUncheckedCreateInput>
    /**
     * In case the Competidor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompetidorUpdateInput, CompetidorUncheckedUpdateInput>
  }

  /**
   * Competidor delete
   */
  export type CompetidorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Competidor
     */
    select?: CompetidorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Competidor
     */
    omit?: CompetidorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompetidorInclude<ExtArgs> | null
    /**
     * Filter which Competidor to delete.
     */
    where: CompetidorWhereUniqueInput
  }

  /**
   * Competidor deleteMany
   */
  export type CompetidorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Competidors to delete
     */
    where?: CompetidorWhereInput
    /**
     * Limit how many Competidors to delete.
     */
    limit?: number
  }

  /**
   * Competidor.Inscripciones
   */
  export type Competidor$InscripcionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inscripcion_tutor
     */
    select?: Inscripcion_tutorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inscripcion_tutor
     */
    omit?: Inscripcion_tutorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Inscripcion_tutorInclude<ExtArgs> | null
    where?: Inscripcion_tutorWhereInput
    orderBy?: Inscripcion_tutorOrderByWithRelationInput | Inscripcion_tutorOrderByWithRelationInput[]
    cursor?: Inscripcion_tutorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Inscripcion_tutorScalarFieldEnum | Inscripcion_tutorScalarFieldEnum[]
  }

  /**
   * Competidor.Inscripcion
   */
  export type Competidor$InscripcionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inscripcion
     */
    select?: InscripcionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inscripcion
     */
    omit?: InscripcionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InscripcionInclude<ExtArgs> | null
    where?: InscripcionWhereInput
    orderBy?: InscripcionOrderByWithRelationInput | InscripcionOrderByWithRelationInput[]
    cursor?: InscripcionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InscripcionScalarFieldEnum | InscripcionScalarFieldEnum[]
  }

  /**
   * Competidor without action
   */
  export type CompetidorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Competidor
     */
    select?: CompetidorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Competidor
     */
    omit?: CompetidorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompetidorInclude<ExtArgs> | null
  }


  /**
   * Model Tutor
   */

  export type AggregateTutor = {
    _count: TutorCountAggregateOutputType | null
    _avg: TutorAvgAggregateOutputType | null
    _sum: TutorSumAggregateOutputType | null
    _min: TutorMinAggregateOutputType | null
    _max: TutorMaxAggregateOutputType | null
  }

  export type TutorAvgAggregateOutputType = {
    area_id: number | null
  }

  export type TutorSumAggregateOutputType = {
    area_id: number | null
  }

  export type TutorMinAggregateOutputType = {
    id: string | null
    usuario_id: string | null
    carnet_identidad: string | null
    numero_celular: string | null
    area_id: number | null
  }

  export type TutorMaxAggregateOutputType = {
    id: string | null
    usuario_id: string | null
    carnet_identidad: string | null
    numero_celular: string | null
    area_id: number | null
  }

  export type TutorCountAggregateOutputType = {
    id: number
    usuario_id: number
    carnet_identidad: number
    numero_celular: number
    area_id: number
    _all: number
  }


  export type TutorAvgAggregateInputType = {
    area_id?: true
  }

  export type TutorSumAggregateInputType = {
    area_id?: true
  }

  export type TutorMinAggregateInputType = {
    id?: true
    usuario_id?: true
    carnet_identidad?: true
    numero_celular?: true
    area_id?: true
  }

  export type TutorMaxAggregateInputType = {
    id?: true
    usuario_id?: true
    carnet_identidad?: true
    numero_celular?: true
    area_id?: true
  }

  export type TutorCountAggregateInputType = {
    id?: true
    usuario_id?: true
    carnet_identidad?: true
    numero_celular?: true
    area_id?: true
    _all?: true
  }

  export type TutorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tutor to aggregate.
     */
    where?: TutorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tutors to fetch.
     */
    orderBy?: TutorOrderByWithRelationInput | TutorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TutorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tutors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tutors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tutors
    **/
    _count?: true | TutorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TutorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TutorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TutorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TutorMaxAggregateInputType
  }

  export type GetTutorAggregateType<T extends TutorAggregateArgs> = {
        [P in keyof T & keyof AggregateTutor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTutor[P]>
      : GetScalarType<T[P], AggregateTutor[P]>
  }




  export type TutorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TutorWhereInput
    orderBy?: TutorOrderByWithAggregationInput | TutorOrderByWithAggregationInput[]
    by: TutorScalarFieldEnum[] | TutorScalarFieldEnum
    having?: TutorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TutorCountAggregateInputType | true
    _avg?: TutorAvgAggregateInputType
    _sum?: TutorSumAggregateInputType
    _min?: TutorMinAggregateInputType
    _max?: TutorMaxAggregateInputType
  }

  export type TutorGroupByOutputType = {
    id: string
    usuario_id: string
    carnet_identidad: string
    numero_celular: string
    area_id: number
    _count: TutorCountAggregateOutputType | null
    _avg: TutorAvgAggregateOutputType | null
    _sum: TutorSumAggregateOutputType | null
    _min: TutorMinAggregateOutputType | null
    _max: TutorMaxAggregateOutputType | null
  }

  type GetTutorGroupByPayload<T extends TutorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TutorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TutorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TutorGroupByOutputType[P]>
            : GetScalarType<T[P], TutorGroupByOutputType[P]>
        }
      >
    >


  export type TutorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuario_id?: boolean
    carnet_identidad?: boolean
    numero_celular?: boolean
    area_id?: boolean
    Inscripciones_tutor?: boolean | Tutor$Inscripciones_tutorArgs<ExtArgs>
    area?: boolean | AreaDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    _count?: boolean | TutorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tutor"]>

  export type TutorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuario_id?: boolean
    carnet_identidad?: boolean
    numero_celular?: boolean
    area_id?: boolean
    area?: boolean | AreaDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tutor"]>

  export type TutorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuario_id?: boolean
    carnet_identidad?: boolean
    numero_celular?: boolean
    area_id?: boolean
    area?: boolean | AreaDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tutor"]>

  export type TutorSelectScalar = {
    id?: boolean
    usuario_id?: boolean
    carnet_identidad?: boolean
    numero_celular?: boolean
    area_id?: boolean
  }

  export type TutorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "usuario_id" | "carnet_identidad" | "numero_celular" | "area_id", ExtArgs["result"]["tutor"]>
  export type TutorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Inscripciones_tutor?: boolean | Tutor$Inscripciones_tutorArgs<ExtArgs>
    area?: boolean | AreaDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    _count?: boolean | TutorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TutorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    area?: boolean | AreaDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type TutorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    area?: boolean | AreaDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $TutorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tutor"
    objects: {
      Inscripciones_tutor: Prisma.$Inscripcion_tutorPayload<ExtArgs>[]
      area: Prisma.$AreaPayload<ExtArgs>
      usuario: Prisma.$UsuarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      usuario_id: string
      carnet_identidad: string
      numero_celular: string
      area_id: number
    }, ExtArgs["result"]["tutor"]>
    composites: {}
  }

  type TutorGetPayload<S extends boolean | null | undefined | TutorDefaultArgs> = $Result.GetResult<Prisma.$TutorPayload, S>

  type TutorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TutorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TutorCountAggregateInputType | true
    }

  export interface TutorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tutor'], meta: { name: 'Tutor' } }
    /**
     * Find zero or one Tutor that matches the filter.
     * @param {TutorFindUniqueArgs} args - Arguments to find a Tutor
     * @example
     * // Get one Tutor
     * const tutor = await prisma.tutor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TutorFindUniqueArgs>(args: SelectSubset<T, TutorFindUniqueArgs<ExtArgs>>): Prisma__TutorClient<$Result.GetResult<Prisma.$TutorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tutor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TutorFindUniqueOrThrowArgs} args - Arguments to find a Tutor
     * @example
     * // Get one Tutor
     * const tutor = await prisma.tutor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TutorFindUniqueOrThrowArgs>(args: SelectSubset<T, TutorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TutorClient<$Result.GetResult<Prisma.$TutorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tutor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutorFindFirstArgs} args - Arguments to find a Tutor
     * @example
     * // Get one Tutor
     * const tutor = await prisma.tutor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TutorFindFirstArgs>(args?: SelectSubset<T, TutorFindFirstArgs<ExtArgs>>): Prisma__TutorClient<$Result.GetResult<Prisma.$TutorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tutor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutorFindFirstOrThrowArgs} args - Arguments to find a Tutor
     * @example
     * // Get one Tutor
     * const tutor = await prisma.tutor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TutorFindFirstOrThrowArgs>(args?: SelectSubset<T, TutorFindFirstOrThrowArgs<ExtArgs>>): Prisma__TutorClient<$Result.GetResult<Prisma.$TutorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tutors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tutors
     * const tutors = await prisma.tutor.findMany()
     * 
     * // Get first 10 Tutors
     * const tutors = await prisma.tutor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tutorWithIdOnly = await prisma.tutor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TutorFindManyArgs>(args?: SelectSubset<T, TutorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TutorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tutor.
     * @param {TutorCreateArgs} args - Arguments to create a Tutor.
     * @example
     * // Create one Tutor
     * const Tutor = await prisma.tutor.create({
     *   data: {
     *     // ... data to create a Tutor
     *   }
     * })
     * 
     */
    create<T extends TutorCreateArgs>(args: SelectSubset<T, TutorCreateArgs<ExtArgs>>): Prisma__TutorClient<$Result.GetResult<Prisma.$TutorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tutors.
     * @param {TutorCreateManyArgs} args - Arguments to create many Tutors.
     * @example
     * // Create many Tutors
     * const tutor = await prisma.tutor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TutorCreateManyArgs>(args?: SelectSubset<T, TutorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tutors and returns the data saved in the database.
     * @param {TutorCreateManyAndReturnArgs} args - Arguments to create many Tutors.
     * @example
     * // Create many Tutors
     * const tutor = await prisma.tutor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tutors and only return the `id`
     * const tutorWithIdOnly = await prisma.tutor.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TutorCreateManyAndReturnArgs>(args?: SelectSubset<T, TutorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TutorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tutor.
     * @param {TutorDeleteArgs} args - Arguments to delete one Tutor.
     * @example
     * // Delete one Tutor
     * const Tutor = await prisma.tutor.delete({
     *   where: {
     *     // ... filter to delete one Tutor
     *   }
     * })
     * 
     */
    delete<T extends TutorDeleteArgs>(args: SelectSubset<T, TutorDeleteArgs<ExtArgs>>): Prisma__TutorClient<$Result.GetResult<Prisma.$TutorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tutor.
     * @param {TutorUpdateArgs} args - Arguments to update one Tutor.
     * @example
     * // Update one Tutor
     * const tutor = await prisma.tutor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TutorUpdateArgs>(args: SelectSubset<T, TutorUpdateArgs<ExtArgs>>): Prisma__TutorClient<$Result.GetResult<Prisma.$TutorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tutors.
     * @param {TutorDeleteManyArgs} args - Arguments to filter Tutors to delete.
     * @example
     * // Delete a few Tutors
     * const { count } = await prisma.tutor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TutorDeleteManyArgs>(args?: SelectSubset<T, TutorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tutors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tutors
     * const tutor = await prisma.tutor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TutorUpdateManyArgs>(args: SelectSubset<T, TutorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tutors and returns the data updated in the database.
     * @param {TutorUpdateManyAndReturnArgs} args - Arguments to update many Tutors.
     * @example
     * // Update many Tutors
     * const tutor = await prisma.tutor.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tutors and only return the `id`
     * const tutorWithIdOnly = await prisma.tutor.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TutorUpdateManyAndReturnArgs>(args: SelectSubset<T, TutorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TutorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tutor.
     * @param {TutorUpsertArgs} args - Arguments to update or create a Tutor.
     * @example
     * // Update or create a Tutor
     * const tutor = await prisma.tutor.upsert({
     *   create: {
     *     // ... data to create a Tutor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tutor we want to update
     *   }
     * })
     */
    upsert<T extends TutorUpsertArgs>(args: SelectSubset<T, TutorUpsertArgs<ExtArgs>>): Prisma__TutorClient<$Result.GetResult<Prisma.$TutorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tutors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutorCountArgs} args - Arguments to filter Tutors to count.
     * @example
     * // Count the number of Tutors
     * const count = await prisma.tutor.count({
     *   where: {
     *     // ... the filter for the Tutors we want to count
     *   }
     * })
    **/
    count<T extends TutorCountArgs>(
      args?: Subset<T, TutorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TutorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tutor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TutorAggregateArgs>(args: Subset<T, TutorAggregateArgs>): Prisma.PrismaPromise<GetTutorAggregateType<T>>

    /**
     * Group by Tutor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TutorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TutorGroupByArgs['orderBy'] }
        : { orderBy?: TutorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TutorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTutorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tutor model
   */
  readonly fields: TutorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tutor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TutorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Inscripciones_tutor<T extends Tutor$Inscripciones_tutorArgs<ExtArgs> = {}>(args?: Subset<T, Tutor$Inscripciones_tutorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Inscripcion_tutorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    area<T extends AreaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AreaDefaultArgs<ExtArgs>>): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tutor model
   */
  interface TutorFieldRefs {
    readonly id: FieldRef<"Tutor", 'String'>
    readonly usuario_id: FieldRef<"Tutor", 'String'>
    readonly carnet_identidad: FieldRef<"Tutor", 'String'>
    readonly numero_celular: FieldRef<"Tutor", 'String'>
    readonly area_id: FieldRef<"Tutor", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Tutor findUnique
   */
  export type TutorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tutor
     */
    select?: TutorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tutor
     */
    omit?: TutorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutorInclude<ExtArgs> | null
    /**
     * Filter, which Tutor to fetch.
     */
    where: TutorWhereUniqueInput
  }

  /**
   * Tutor findUniqueOrThrow
   */
  export type TutorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tutor
     */
    select?: TutorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tutor
     */
    omit?: TutorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutorInclude<ExtArgs> | null
    /**
     * Filter, which Tutor to fetch.
     */
    where: TutorWhereUniqueInput
  }

  /**
   * Tutor findFirst
   */
  export type TutorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tutor
     */
    select?: TutorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tutor
     */
    omit?: TutorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutorInclude<ExtArgs> | null
    /**
     * Filter, which Tutor to fetch.
     */
    where?: TutorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tutors to fetch.
     */
    orderBy?: TutorOrderByWithRelationInput | TutorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tutors.
     */
    cursor?: TutorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tutors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tutors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tutors.
     */
    distinct?: TutorScalarFieldEnum | TutorScalarFieldEnum[]
  }

  /**
   * Tutor findFirstOrThrow
   */
  export type TutorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tutor
     */
    select?: TutorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tutor
     */
    omit?: TutorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutorInclude<ExtArgs> | null
    /**
     * Filter, which Tutor to fetch.
     */
    where?: TutorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tutors to fetch.
     */
    orderBy?: TutorOrderByWithRelationInput | TutorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tutors.
     */
    cursor?: TutorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tutors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tutors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tutors.
     */
    distinct?: TutorScalarFieldEnum | TutorScalarFieldEnum[]
  }

  /**
   * Tutor findMany
   */
  export type TutorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tutor
     */
    select?: TutorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tutor
     */
    omit?: TutorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutorInclude<ExtArgs> | null
    /**
     * Filter, which Tutors to fetch.
     */
    where?: TutorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tutors to fetch.
     */
    orderBy?: TutorOrderByWithRelationInput | TutorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tutors.
     */
    cursor?: TutorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tutors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tutors.
     */
    skip?: number
    distinct?: TutorScalarFieldEnum | TutorScalarFieldEnum[]
  }

  /**
   * Tutor create
   */
  export type TutorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tutor
     */
    select?: TutorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tutor
     */
    omit?: TutorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutorInclude<ExtArgs> | null
    /**
     * The data needed to create a Tutor.
     */
    data: XOR<TutorCreateInput, TutorUncheckedCreateInput>
  }

  /**
   * Tutor createMany
   */
  export type TutorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tutors.
     */
    data: TutorCreateManyInput | TutorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tutor createManyAndReturn
   */
  export type TutorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tutor
     */
    select?: TutorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tutor
     */
    omit?: TutorOmit<ExtArgs> | null
    /**
     * The data used to create many Tutors.
     */
    data: TutorCreateManyInput | TutorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tutor update
   */
  export type TutorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tutor
     */
    select?: TutorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tutor
     */
    omit?: TutorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutorInclude<ExtArgs> | null
    /**
     * The data needed to update a Tutor.
     */
    data: XOR<TutorUpdateInput, TutorUncheckedUpdateInput>
    /**
     * Choose, which Tutor to update.
     */
    where: TutorWhereUniqueInput
  }

  /**
   * Tutor updateMany
   */
  export type TutorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tutors.
     */
    data: XOR<TutorUpdateManyMutationInput, TutorUncheckedUpdateManyInput>
    /**
     * Filter which Tutors to update
     */
    where?: TutorWhereInput
    /**
     * Limit how many Tutors to update.
     */
    limit?: number
  }

  /**
   * Tutor updateManyAndReturn
   */
  export type TutorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tutor
     */
    select?: TutorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tutor
     */
    omit?: TutorOmit<ExtArgs> | null
    /**
     * The data used to update Tutors.
     */
    data: XOR<TutorUpdateManyMutationInput, TutorUncheckedUpdateManyInput>
    /**
     * Filter which Tutors to update
     */
    where?: TutorWhereInput
    /**
     * Limit how many Tutors to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tutor upsert
   */
  export type TutorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tutor
     */
    select?: TutorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tutor
     */
    omit?: TutorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutorInclude<ExtArgs> | null
    /**
     * The filter to search for the Tutor to update in case it exists.
     */
    where: TutorWhereUniqueInput
    /**
     * In case the Tutor found by the `where` argument doesn't exist, create a new Tutor with this data.
     */
    create: XOR<TutorCreateInput, TutorUncheckedCreateInput>
    /**
     * In case the Tutor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TutorUpdateInput, TutorUncheckedUpdateInput>
  }

  /**
   * Tutor delete
   */
  export type TutorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tutor
     */
    select?: TutorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tutor
     */
    omit?: TutorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutorInclude<ExtArgs> | null
    /**
     * Filter which Tutor to delete.
     */
    where: TutorWhereUniqueInput
  }

  /**
   * Tutor deleteMany
   */
  export type TutorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tutors to delete
     */
    where?: TutorWhereInput
    /**
     * Limit how many Tutors to delete.
     */
    limit?: number
  }

  /**
   * Tutor.Inscripciones_tutor
   */
  export type Tutor$Inscripciones_tutorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inscripcion_tutor
     */
    select?: Inscripcion_tutorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inscripcion_tutor
     */
    omit?: Inscripcion_tutorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Inscripcion_tutorInclude<ExtArgs> | null
    where?: Inscripcion_tutorWhereInput
    orderBy?: Inscripcion_tutorOrderByWithRelationInput | Inscripcion_tutorOrderByWithRelationInput[]
    cursor?: Inscripcion_tutorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Inscripcion_tutorScalarFieldEnum | Inscripcion_tutorScalarFieldEnum[]
  }

  /**
   * Tutor without action
   */
  export type TutorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tutor
     */
    select?: TutorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tutor
     */
    omit?: TutorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutorInclude<ExtArgs> | null
  }


  /**
   * Model Departamento
   */

  export type AggregateDepartamento = {
    _count: DepartamentoCountAggregateOutputType | null
    _avg: DepartamentoAvgAggregateOutputType | null
    _sum: DepartamentoSumAggregateOutputType | null
    _min: DepartamentoMinAggregateOutputType | null
    _max: DepartamentoMaxAggregateOutputType | null
  }

  export type DepartamentoAvgAggregateOutputType = {
    id: number | null
  }

  export type DepartamentoSumAggregateOutputType = {
    id: number | null
  }

  export type DepartamentoMinAggregateOutputType = {
    id: number | null
    nombre_departamento: string | null
  }

  export type DepartamentoMaxAggregateOutputType = {
    id: number | null
    nombre_departamento: string | null
  }

  export type DepartamentoCountAggregateOutputType = {
    id: number
    nombre_departamento: number
    _all: number
  }


  export type DepartamentoAvgAggregateInputType = {
    id?: true
  }

  export type DepartamentoSumAggregateInputType = {
    id?: true
  }

  export type DepartamentoMinAggregateInputType = {
    id?: true
    nombre_departamento?: true
  }

  export type DepartamentoMaxAggregateInputType = {
    id?: true
    nombre_departamento?: true
  }

  export type DepartamentoCountAggregateInputType = {
    id?: true
    nombre_departamento?: true
    _all?: true
  }

  export type DepartamentoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Departamento to aggregate.
     */
    where?: DepartamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departamentos to fetch.
     */
    orderBy?: DepartamentoOrderByWithRelationInput | DepartamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DepartamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Departamentos
    **/
    _count?: true | DepartamentoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DepartamentoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DepartamentoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepartamentoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepartamentoMaxAggregateInputType
  }

  export type GetDepartamentoAggregateType<T extends DepartamentoAggregateArgs> = {
        [P in keyof T & keyof AggregateDepartamento]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepartamento[P]>
      : GetScalarType<T[P], AggregateDepartamento[P]>
  }




  export type DepartamentoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartamentoWhereInput
    orderBy?: DepartamentoOrderByWithAggregationInput | DepartamentoOrderByWithAggregationInput[]
    by: DepartamentoScalarFieldEnum[] | DepartamentoScalarFieldEnum
    having?: DepartamentoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepartamentoCountAggregateInputType | true
    _avg?: DepartamentoAvgAggregateInputType
    _sum?: DepartamentoSumAggregateInputType
    _min?: DepartamentoMinAggregateInputType
    _max?: DepartamentoMaxAggregateInputType
  }

  export type DepartamentoGroupByOutputType = {
    id: number
    nombre_departamento: string
    _count: DepartamentoCountAggregateOutputType | null
    _avg: DepartamentoAvgAggregateOutputType | null
    _sum: DepartamentoSumAggregateOutputType | null
    _min: DepartamentoMinAggregateOutputType | null
    _max: DepartamentoMaxAggregateOutputType | null
  }

  type GetDepartamentoGroupByPayload<T extends DepartamentoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepartamentoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepartamentoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepartamentoGroupByOutputType[P]>
            : GetScalarType<T[P], DepartamentoGroupByOutputType[P]>
        }
      >
    >


  export type DepartamentoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre_departamento?: boolean
    Provincia?: boolean | Departamento$ProvinciaArgs<ExtArgs>
    _count?: boolean | DepartamentoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["departamento"]>

  export type DepartamentoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre_departamento?: boolean
  }, ExtArgs["result"]["departamento"]>

  export type DepartamentoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre_departamento?: boolean
  }, ExtArgs["result"]["departamento"]>

  export type DepartamentoSelectScalar = {
    id?: boolean
    nombre_departamento?: boolean
  }

  export type DepartamentoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nombre_departamento", ExtArgs["result"]["departamento"]>
  export type DepartamentoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Provincia?: boolean | Departamento$ProvinciaArgs<ExtArgs>
    _count?: boolean | DepartamentoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DepartamentoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DepartamentoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DepartamentoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Departamento"
    objects: {
      Provincia: Prisma.$ProvinciaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre_departamento: string
    }, ExtArgs["result"]["departamento"]>
    composites: {}
  }

  type DepartamentoGetPayload<S extends boolean | null | undefined | DepartamentoDefaultArgs> = $Result.GetResult<Prisma.$DepartamentoPayload, S>

  type DepartamentoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DepartamentoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DepartamentoCountAggregateInputType | true
    }

  export interface DepartamentoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Departamento'], meta: { name: 'Departamento' } }
    /**
     * Find zero or one Departamento that matches the filter.
     * @param {DepartamentoFindUniqueArgs} args - Arguments to find a Departamento
     * @example
     * // Get one Departamento
     * const departamento = await prisma.departamento.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DepartamentoFindUniqueArgs>(args: SelectSubset<T, DepartamentoFindUniqueArgs<ExtArgs>>): Prisma__DepartamentoClient<$Result.GetResult<Prisma.$DepartamentoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Departamento that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DepartamentoFindUniqueOrThrowArgs} args - Arguments to find a Departamento
     * @example
     * // Get one Departamento
     * const departamento = await prisma.departamento.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DepartamentoFindUniqueOrThrowArgs>(args: SelectSubset<T, DepartamentoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DepartamentoClient<$Result.GetResult<Prisma.$DepartamentoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Departamento that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartamentoFindFirstArgs} args - Arguments to find a Departamento
     * @example
     * // Get one Departamento
     * const departamento = await prisma.departamento.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DepartamentoFindFirstArgs>(args?: SelectSubset<T, DepartamentoFindFirstArgs<ExtArgs>>): Prisma__DepartamentoClient<$Result.GetResult<Prisma.$DepartamentoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Departamento that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartamentoFindFirstOrThrowArgs} args - Arguments to find a Departamento
     * @example
     * // Get one Departamento
     * const departamento = await prisma.departamento.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DepartamentoFindFirstOrThrowArgs>(args?: SelectSubset<T, DepartamentoFindFirstOrThrowArgs<ExtArgs>>): Prisma__DepartamentoClient<$Result.GetResult<Prisma.$DepartamentoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Departamentos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartamentoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Departamentos
     * const departamentos = await prisma.departamento.findMany()
     * 
     * // Get first 10 Departamentos
     * const departamentos = await prisma.departamento.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const departamentoWithIdOnly = await prisma.departamento.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DepartamentoFindManyArgs>(args?: SelectSubset<T, DepartamentoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartamentoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Departamento.
     * @param {DepartamentoCreateArgs} args - Arguments to create a Departamento.
     * @example
     * // Create one Departamento
     * const Departamento = await prisma.departamento.create({
     *   data: {
     *     // ... data to create a Departamento
     *   }
     * })
     * 
     */
    create<T extends DepartamentoCreateArgs>(args: SelectSubset<T, DepartamentoCreateArgs<ExtArgs>>): Prisma__DepartamentoClient<$Result.GetResult<Prisma.$DepartamentoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Departamentos.
     * @param {DepartamentoCreateManyArgs} args - Arguments to create many Departamentos.
     * @example
     * // Create many Departamentos
     * const departamento = await prisma.departamento.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DepartamentoCreateManyArgs>(args?: SelectSubset<T, DepartamentoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Departamentos and returns the data saved in the database.
     * @param {DepartamentoCreateManyAndReturnArgs} args - Arguments to create many Departamentos.
     * @example
     * // Create many Departamentos
     * const departamento = await prisma.departamento.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Departamentos and only return the `id`
     * const departamentoWithIdOnly = await prisma.departamento.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DepartamentoCreateManyAndReturnArgs>(args?: SelectSubset<T, DepartamentoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartamentoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Departamento.
     * @param {DepartamentoDeleteArgs} args - Arguments to delete one Departamento.
     * @example
     * // Delete one Departamento
     * const Departamento = await prisma.departamento.delete({
     *   where: {
     *     // ... filter to delete one Departamento
     *   }
     * })
     * 
     */
    delete<T extends DepartamentoDeleteArgs>(args: SelectSubset<T, DepartamentoDeleteArgs<ExtArgs>>): Prisma__DepartamentoClient<$Result.GetResult<Prisma.$DepartamentoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Departamento.
     * @param {DepartamentoUpdateArgs} args - Arguments to update one Departamento.
     * @example
     * // Update one Departamento
     * const departamento = await prisma.departamento.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DepartamentoUpdateArgs>(args: SelectSubset<T, DepartamentoUpdateArgs<ExtArgs>>): Prisma__DepartamentoClient<$Result.GetResult<Prisma.$DepartamentoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Departamentos.
     * @param {DepartamentoDeleteManyArgs} args - Arguments to filter Departamentos to delete.
     * @example
     * // Delete a few Departamentos
     * const { count } = await prisma.departamento.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DepartamentoDeleteManyArgs>(args?: SelectSubset<T, DepartamentoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departamentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartamentoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Departamentos
     * const departamento = await prisma.departamento.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DepartamentoUpdateManyArgs>(args: SelectSubset<T, DepartamentoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departamentos and returns the data updated in the database.
     * @param {DepartamentoUpdateManyAndReturnArgs} args - Arguments to update many Departamentos.
     * @example
     * // Update many Departamentos
     * const departamento = await prisma.departamento.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Departamentos and only return the `id`
     * const departamentoWithIdOnly = await prisma.departamento.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DepartamentoUpdateManyAndReturnArgs>(args: SelectSubset<T, DepartamentoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartamentoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Departamento.
     * @param {DepartamentoUpsertArgs} args - Arguments to update or create a Departamento.
     * @example
     * // Update or create a Departamento
     * const departamento = await prisma.departamento.upsert({
     *   create: {
     *     // ... data to create a Departamento
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Departamento we want to update
     *   }
     * })
     */
    upsert<T extends DepartamentoUpsertArgs>(args: SelectSubset<T, DepartamentoUpsertArgs<ExtArgs>>): Prisma__DepartamentoClient<$Result.GetResult<Prisma.$DepartamentoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Departamentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartamentoCountArgs} args - Arguments to filter Departamentos to count.
     * @example
     * // Count the number of Departamentos
     * const count = await prisma.departamento.count({
     *   where: {
     *     // ... the filter for the Departamentos we want to count
     *   }
     * })
    **/
    count<T extends DepartamentoCountArgs>(
      args?: Subset<T, DepartamentoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepartamentoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Departamento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartamentoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepartamentoAggregateArgs>(args: Subset<T, DepartamentoAggregateArgs>): Prisma.PrismaPromise<GetDepartamentoAggregateType<T>>

    /**
     * Group by Departamento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartamentoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DepartamentoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DepartamentoGroupByArgs['orderBy'] }
        : { orderBy?: DepartamentoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DepartamentoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepartamentoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Departamento model
   */
  readonly fields: DepartamentoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Departamento.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DepartamentoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Provincia<T extends Departamento$ProvinciaArgs<ExtArgs> = {}>(args?: Subset<T, Departamento$ProvinciaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProvinciaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Departamento model
   */
  interface DepartamentoFieldRefs {
    readonly id: FieldRef<"Departamento", 'Int'>
    readonly nombre_departamento: FieldRef<"Departamento", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Departamento findUnique
   */
  export type DepartamentoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Departamento
     */
    select?: DepartamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Departamento
     */
    omit?: DepartamentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartamentoInclude<ExtArgs> | null
    /**
     * Filter, which Departamento to fetch.
     */
    where: DepartamentoWhereUniqueInput
  }

  /**
   * Departamento findUniqueOrThrow
   */
  export type DepartamentoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Departamento
     */
    select?: DepartamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Departamento
     */
    omit?: DepartamentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartamentoInclude<ExtArgs> | null
    /**
     * Filter, which Departamento to fetch.
     */
    where: DepartamentoWhereUniqueInput
  }

  /**
   * Departamento findFirst
   */
  export type DepartamentoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Departamento
     */
    select?: DepartamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Departamento
     */
    omit?: DepartamentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartamentoInclude<ExtArgs> | null
    /**
     * Filter, which Departamento to fetch.
     */
    where?: DepartamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departamentos to fetch.
     */
    orderBy?: DepartamentoOrderByWithRelationInput | DepartamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departamentos.
     */
    cursor?: DepartamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departamentos.
     */
    distinct?: DepartamentoScalarFieldEnum | DepartamentoScalarFieldEnum[]
  }

  /**
   * Departamento findFirstOrThrow
   */
  export type DepartamentoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Departamento
     */
    select?: DepartamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Departamento
     */
    omit?: DepartamentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartamentoInclude<ExtArgs> | null
    /**
     * Filter, which Departamento to fetch.
     */
    where?: DepartamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departamentos to fetch.
     */
    orderBy?: DepartamentoOrderByWithRelationInput | DepartamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departamentos.
     */
    cursor?: DepartamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departamentos.
     */
    distinct?: DepartamentoScalarFieldEnum | DepartamentoScalarFieldEnum[]
  }

  /**
   * Departamento findMany
   */
  export type DepartamentoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Departamento
     */
    select?: DepartamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Departamento
     */
    omit?: DepartamentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartamentoInclude<ExtArgs> | null
    /**
     * Filter, which Departamentos to fetch.
     */
    where?: DepartamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departamentos to fetch.
     */
    orderBy?: DepartamentoOrderByWithRelationInput | DepartamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Departamentos.
     */
    cursor?: DepartamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departamentos.
     */
    skip?: number
    distinct?: DepartamentoScalarFieldEnum | DepartamentoScalarFieldEnum[]
  }

  /**
   * Departamento create
   */
  export type DepartamentoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Departamento
     */
    select?: DepartamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Departamento
     */
    omit?: DepartamentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartamentoInclude<ExtArgs> | null
    /**
     * The data needed to create a Departamento.
     */
    data: XOR<DepartamentoCreateInput, DepartamentoUncheckedCreateInput>
  }

  /**
   * Departamento createMany
   */
  export type DepartamentoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Departamentos.
     */
    data: DepartamentoCreateManyInput | DepartamentoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Departamento createManyAndReturn
   */
  export type DepartamentoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Departamento
     */
    select?: DepartamentoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Departamento
     */
    omit?: DepartamentoOmit<ExtArgs> | null
    /**
     * The data used to create many Departamentos.
     */
    data: DepartamentoCreateManyInput | DepartamentoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Departamento update
   */
  export type DepartamentoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Departamento
     */
    select?: DepartamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Departamento
     */
    omit?: DepartamentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartamentoInclude<ExtArgs> | null
    /**
     * The data needed to update a Departamento.
     */
    data: XOR<DepartamentoUpdateInput, DepartamentoUncheckedUpdateInput>
    /**
     * Choose, which Departamento to update.
     */
    where: DepartamentoWhereUniqueInput
  }

  /**
   * Departamento updateMany
   */
  export type DepartamentoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Departamentos.
     */
    data: XOR<DepartamentoUpdateManyMutationInput, DepartamentoUncheckedUpdateManyInput>
    /**
     * Filter which Departamentos to update
     */
    where?: DepartamentoWhereInput
    /**
     * Limit how many Departamentos to update.
     */
    limit?: number
  }

  /**
   * Departamento updateManyAndReturn
   */
  export type DepartamentoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Departamento
     */
    select?: DepartamentoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Departamento
     */
    omit?: DepartamentoOmit<ExtArgs> | null
    /**
     * The data used to update Departamentos.
     */
    data: XOR<DepartamentoUpdateManyMutationInput, DepartamentoUncheckedUpdateManyInput>
    /**
     * Filter which Departamentos to update
     */
    where?: DepartamentoWhereInput
    /**
     * Limit how many Departamentos to update.
     */
    limit?: number
  }

  /**
   * Departamento upsert
   */
  export type DepartamentoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Departamento
     */
    select?: DepartamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Departamento
     */
    omit?: DepartamentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartamentoInclude<ExtArgs> | null
    /**
     * The filter to search for the Departamento to update in case it exists.
     */
    where: DepartamentoWhereUniqueInput
    /**
     * In case the Departamento found by the `where` argument doesn't exist, create a new Departamento with this data.
     */
    create: XOR<DepartamentoCreateInput, DepartamentoUncheckedCreateInput>
    /**
     * In case the Departamento was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DepartamentoUpdateInput, DepartamentoUncheckedUpdateInput>
  }

  /**
   * Departamento delete
   */
  export type DepartamentoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Departamento
     */
    select?: DepartamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Departamento
     */
    omit?: DepartamentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartamentoInclude<ExtArgs> | null
    /**
     * Filter which Departamento to delete.
     */
    where: DepartamentoWhereUniqueInput
  }

  /**
   * Departamento deleteMany
   */
  export type DepartamentoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Departamentos to delete
     */
    where?: DepartamentoWhereInput
    /**
     * Limit how many Departamentos to delete.
     */
    limit?: number
  }

  /**
   * Departamento.Provincia
   */
  export type Departamento$ProvinciaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provincia
     */
    select?: ProvinciaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provincia
     */
    omit?: ProvinciaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvinciaInclude<ExtArgs> | null
    where?: ProvinciaWhereInput
    orderBy?: ProvinciaOrderByWithRelationInput | ProvinciaOrderByWithRelationInput[]
    cursor?: ProvinciaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProvinciaScalarFieldEnum | ProvinciaScalarFieldEnum[]
  }

  /**
   * Departamento without action
   */
  export type DepartamentoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Departamento
     */
    select?: DepartamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Departamento
     */
    omit?: DepartamentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartamentoInclude<ExtArgs> | null
  }


  /**
   * Model Provincia
   */

  export type AggregateProvincia = {
    _count: ProvinciaCountAggregateOutputType | null
    _avg: ProvinciaAvgAggregateOutputType | null
    _sum: ProvinciaSumAggregateOutputType | null
    _min: ProvinciaMinAggregateOutputType | null
    _max: ProvinciaMaxAggregateOutputType | null
  }

  export type ProvinciaAvgAggregateOutputType = {
    id: number | null
    departamento_id: number | null
  }

  export type ProvinciaSumAggregateOutputType = {
    id: number | null
    departamento_id: number | null
  }

  export type ProvinciaMinAggregateOutputType = {
    id: number | null
    nombre_provincia: string | null
    departamento_id: number | null
  }

  export type ProvinciaMaxAggregateOutputType = {
    id: number | null
    nombre_provincia: string | null
    departamento_id: number | null
  }

  export type ProvinciaCountAggregateOutputType = {
    id: number
    nombre_provincia: number
    departamento_id: number
    _all: number
  }


  export type ProvinciaAvgAggregateInputType = {
    id?: true
    departamento_id?: true
  }

  export type ProvinciaSumAggregateInputType = {
    id?: true
    departamento_id?: true
  }

  export type ProvinciaMinAggregateInputType = {
    id?: true
    nombre_provincia?: true
    departamento_id?: true
  }

  export type ProvinciaMaxAggregateInputType = {
    id?: true
    nombre_provincia?: true
    departamento_id?: true
  }

  export type ProvinciaCountAggregateInputType = {
    id?: true
    nombre_provincia?: true
    departamento_id?: true
    _all?: true
  }

  export type ProvinciaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Provincia to aggregate.
     */
    where?: ProvinciaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Provincias to fetch.
     */
    orderBy?: ProvinciaOrderByWithRelationInput | ProvinciaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProvinciaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Provincias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Provincias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Provincias
    **/
    _count?: true | ProvinciaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProvinciaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProvinciaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProvinciaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProvinciaMaxAggregateInputType
  }

  export type GetProvinciaAggregateType<T extends ProvinciaAggregateArgs> = {
        [P in keyof T & keyof AggregateProvincia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProvincia[P]>
      : GetScalarType<T[P], AggregateProvincia[P]>
  }




  export type ProvinciaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProvinciaWhereInput
    orderBy?: ProvinciaOrderByWithAggregationInput | ProvinciaOrderByWithAggregationInput[]
    by: ProvinciaScalarFieldEnum[] | ProvinciaScalarFieldEnum
    having?: ProvinciaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProvinciaCountAggregateInputType | true
    _avg?: ProvinciaAvgAggregateInputType
    _sum?: ProvinciaSumAggregateInputType
    _min?: ProvinciaMinAggregateInputType
    _max?: ProvinciaMaxAggregateInputType
  }

  export type ProvinciaGroupByOutputType = {
    id: number
    nombre_provincia: string
    departamento_id: number
    _count: ProvinciaCountAggregateOutputType | null
    _avg: ProvinciaAvgAggregateOutputType | null
    _sum: ProvinciaSumAggregateOutputType | null
    _min: ProvinciaMinAggregateOutputType | null
    _max: ProvinciaMaxAggregateOutputType | null
  }

  type GetProvinciaGroupByPayload<T extends ProvinciaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProvinciaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProvinciaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProvinciaGroupByOutputType[P]>
            : GetScalarType<T[P], ProvinciaGroupByOutputType[P]>
        }
      >
    >


  export type ProvinciaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre_provincia?: boolean
    departamento_id?: boolean
    Colegio?: boolean | Provincia$ColegioArgs<ExtArgs>
    Competidor?: boolean | Provincia$CompetidorArgs<ExtArgs>
    departamento?: boolean | DepartamentoDefaultArgs<ExtArgs>
    _count?: boolean | ProvinciaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["provincia"]>

  export type ProvinciaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre_provincia?: boolean
    departamento_id?: boolean
    departamento?: boolean | DepartamentoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["provincia"]>

  export type ProvinciaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre_provincia?: boolean
    departamento_id?: boolean
    departamento?: boolean | DepartamentoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["provincia"]>

  export type ProvinciaSelectScalar = {
    id?: boolean
    nombre_provincia?: boolean
    departamento_id?: boolean
  }

  export type ProvinciaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nombre_provincia" | "departamento_id", ExtArgs["result"]["provincia"]>
  export type ProvinciaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Colegio?: boolean | Provincia$ColegioArgs<ExtArgs>
    Competidor?: boolean | Provincia$CompetidorArgs<ExtArgs>
    departamento?: boolean | DepartamentoDefaultArgs<ExtArgs>
    _count?: boolean | ProvinciaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProvinciaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    departamento?: boolean | DepartamentoDefaultArgs<ExtArgs>
  }
  export type ProvinciaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    departamento?: boolean | DepartamentoDefaultArgs<ExtArgs>
  }

  export type $ProvinciaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Provincia"
    objects: {
      Colegio: Prisma.$ColegioPayload<ExtArgs>[]
      Competidor: Prisma.$CompetidorPayload<ExtArgs>[]
      departamento: Prisma.$DepartamentoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre_provincia: string
      departamento_id: number
    }, ExtArgs["result"]["provincia"]>
    composites: {}
  }

  type ProvinciaGetPayload<S extends boolean | null | undefined | ProvinciaDefaultArgs> = $Result.GetResult<Prisma.$ProvinciaPayload, S>

  type ProvinciaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProvinciaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProvinciaCountAggregateInputType | true
    }

  export interface ProvinciaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Provincia'], meta: { name: 'Provincia' } }
    /**
     * Find zero or one Provincia that matches the filter.
     * @param {ProvinciaFindUniqueArgs} args - Arguments to find a Provincia
     * @example
     * // Get one Provincia
     * const provincia = await prisma.provincia.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProvinciaFindUniqueArgs>(args: SelectSubset<T, ProvinciaFindUniqueArgs<ExtArgs>>): Prisma__ProvinciaClient<$Result.GetResult<Prisma.$ProvinciaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Provincia that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProvinciaFindUniqueOrThrowArgs} args - Arguments to find a Provincia
     * @example
     * // Get one Provincia
     * const provincia = await prisma.provincia.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProvinciaFindUniqueOrThrowArgs>(args: SelectSubset<T, ProvinciaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProvinciaClient<$Result.GetResult<Prisma.$ProvinciaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Provincia that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvinciaFindFirstArgs} args - Arguments to find a Provincia
     * @example
     * // Get one Provincia
     * const provincia = await prisma.provincia.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProvinciaFindFirstArgs>(args?: SelectSubset<T, ProvinciaFindFirstArgs<ExtArgs>>): Prisma__ProvinciaClient<$Result.GetResult<Prisma.$ProvinciaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Provincia that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvinciaFindFirstOrThrowArgs} args - Arguments to find a Provincia
     * @example
     * // Get one Provincia
     * const provincia = await prisma.provincia.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProvinciaFindFirstOrThrowArgs>(args?: SelectSubset<T, ProvinciaFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProvinciaClient<$Result.GetResult<Prisma.$ProvinciaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Provincias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvinciaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Provincias
     * const provincias = await prisma.provincia.findMany()
     * 
     * // Get first 10 Provincias
     * const provincias = await prisma.provincia.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const provinciaWithIdOnly = await prisma.provincia.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProvinciaFindManyArgs>(args?: SelectSubset<T, ProvinciaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProvinciaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Provincia.
     * @param {ProvinciaCreateArgs} args - Arguments to create a Provincia.
     * @example
     * // Create one Provincia
     * const Provincia = await prisma.provincia.create({
     *   data: {
     *     // ... data to create a Provincia
     *   }
     * })
     * 
     */
    create<T extends ProvinciaCreateArgs>(args: SelectSubset<T, ProvinciaCreateArgs<ExtArgs>>): Prisma__ProvinciaClient<$Result.GetResult<Prisma.$ProvinciaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Provincias.
     * @param {ProvinciaCreateManyArgs} args - Arguments to create many Provincias.
     * @example
     * // Create many Provincias
     * const provincia = await prisma.provincia.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProvinciaCreateManyArgs>(args?: SelectSubset<T, ProvinciaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Provincias and returns the data saved in the database.
     * @param {ProvinciaCreateManyAndReturnArgs} args - Arguments to create many Provincias.
     * @example
     * // Create many Provincias
     * const provincia = await prisma.provincia.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Provincias and only return the `id`
     * const provinciaWithIdOnly = await prisma.provincia.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProvinciaCreateManyAndReturnArgs>(args?: SelectSubset<T, ProvinciaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProvinciaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Provincia.
     * @param {ProvinciaDeleteArgs} args - Arguments to delete one Provincia.
     * @example
     * // Delete one Provincia
     * const Provincia = await prisma.provincia.delete({
     *   where: {
     *     // ... filter to delete one Provincia
     *   }
     * })
     * 
     */
    delete<T extends ProvinciaDeleteArgs>(args: SelectSubset<T, ProvinciaDeleteArgs<ExtArgs>>): Prisma__ProvinciaClient<$Result.GetResult<Prisma.$ProvinciaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Provincia.
     * @param {ProvinciaUpdateArgs} args - Arguments to update one Provincia.
     * @example
     * // Update one Provincia
     * const provincia = await prisma.provincia.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProvinciaUpdateArgs>(args: SelectSubset<T, ProvinciaUpdateArgs<ExtArgs>>): Prisma__ProvinciaClient<$Result.GetResult<Prisma.$ProvinciaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Provincias.
     * @param {ProvinciaDeleteManyArgs} args - Arguments to filter Provincias to delete.
     * @example
     * // Delete a few Provincias
     * const { count } = await prisma.provincia.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProvinciaDeleteManyArgs>(args?: SelectSubset<T, ProvinciaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Provincias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvinciaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Provincias
     * const provincia = await prisma.provincia.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProvinciaUpdateManyArgs>(args: SelectSubset<T, ProvinciaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Provincias and returns the data updated in the database.
     * @param {ProvinciaUpdateManyAndReturnArgs} args - Arguments to update many Provincias.
     * @example
     * // Update many Provincias
     * const provincia = await prisma.provincia.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Provincias and only return the `id`
     * const provinciaWithIdOnly = await prisma.provincia.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProvinciaUpdateManyAndReturnArgs>(args: SelectSubset<T, ProvinciaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProvinciaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Provincia.
     * @param {ProvinciaUpsertArgs} args - Arguments to update or create a Provincia.
     * @example
     * // Update or create a Provincia
     * const provincia = await prisma.provincia.upsert({
     *   create: {
     *     // ... data to create a Provincia
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Provincia we want to update
     *   }
     * })
     */
    upsert<T extends ProvinciaUpsertArgs>(args: SelectSubset<T, ProvinciaUpsertArgs<ExtArgs>>): Prisma__ProvinciaClient<$Result.GetResult<Prisma.$ProvinciaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Provincias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvinciaCountArgs} args - Arguments to filter Provincias to count.
     * @example
     * // Count the number of Provincias
     * const count = await prisma.provincia.count({
     *   where: {
     *     // ... the filter for the Provincias we want to count
     *   }
     * })
    **/
    count<T extends ProvinciaCountArgs>(
      args?: Subset<T, ProvinciaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProvinciaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Provincia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvinciaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProvinciaAggregateArgs>(args: Subset<T, ProvinciaAggregateArgs>): Prisma.PrismaPromise<GetProvinciaAggregateType<T>>

    /**
     * Group by Provincia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvinciaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProvinciaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProvinciaGroupByArgs['orderBy'] }
        : { orderBy?: ProvinciaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProvinciaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProvinciaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Provincia model
   */
  readonly fields: ProvinciaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Provincia.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProvinciaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Colegio<T extends Provincia$ColegioArgs<ExtArgs> = {}>(args?: Subset<T, Provincia$ColegioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ColegioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Competidor<T extends Provincia$CompetidorArgs<ExtArgs> = {}>(args?: Subset<T, Provincia$CompetidorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompetidorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    departamento<T extends DepartamentoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DepartamentoDefaultArgs<ExtArgs>>): Prisma__DepartamentoClient<$Result.GetResult<Prisma.$DepartamentoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Provincia model
   */
  interface ProvinciaFieldRefs {
    readonly id: FieldRef<"Provincia", 'Int'>
    readonly nombre_provincia: FieldRef<"Provincia", 'String'>
    readonly departamento_id: FieldRef<"Provincia", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Provincia findUnique
   */
  export type ProvinciaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provincia
     */
    select?: ProvinciaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provincia
     */
    omit?: ProvinciaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvinciaInclude<ExtArgs> | null
    /**
     * Filter, which Provincia to fetch.
     */
    where: ProvinciaWhereUniqueInput
  }

  /**
   * Provincia findUniqueOrThrow
   */
  export type ProvinciaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provincia
     */
    select?: ProvinciaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provincia
     */
    omit?: ProvinciaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvinciaInclude<ExtArgs> | null
    /**
     * Filter, which Provincia to fetch.
     */
    where: ProvinciaWhereUniqueInput
  }

  /**
   * Provincia findFirst
   */
  export type ProvinciaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provincia
     */
    select?: ProvinciaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provincia
     */
    omit?: ProvinciaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvinciaInclude<ExtArgs> | null
    /**
     * Filter, which Provincia to fetch.
     */
    where?: ProvinciaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Provincias to fetch.
     */
    orderBy?: ProvinciaOrderByWithRelationInput | ProvinciaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Provincias.
     */
    cursor?: ProvinciaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Provincias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Provincias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Provincias.
     */
    distinct?: ProvinciaScalarFieldEnum | ProvinciaScalarFieldEnum[]
  }

  /**
   * Provincia findFirstOrThrow
   */
  export type ProvinciaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provincia
     */
    select?: ProvinciaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provincia
     */
    omit?: ProvinciaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvinciaInclude<ExtArgs> | null
    /**
     * Filter, which Provincia to fetch.
     */
    where?: ProvinciaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Provincias to fetch.
     */
    orderBy?: ProvinciaOrderByWithRelationInput | ProvinciaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Provincias.
     */
    cursor?: ProvinciaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Provincias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Provincias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Provincias.
     */
    distinct?: ProvinciaScalarFieldEnum | ProvinciaScalarFieldEnum[]
  }

  /**
   * Provincia findMany
   */
  export type ProvinciaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provincia
     */
    select?: ProvinciaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provincia
     */
    omit?: ProvinciaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvinciaInclude<ExtArgs> | null
    /**
     * Filter, which Provincias to fetch.
     */
    where?: ProvinciaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Provincias to fetch.
     */
    orderBy?: ProvinciaOrderByWithRelationInput | ProvinciaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Provincias.
     */
    cursor?: ProvinciaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Provincias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Provincias.
     */
    skip?: number
    distinct?: ProvinciaScalarFieldEnum | ProvinciaScalarFieldEnum[]
  }

  /**
   * Provincia create
   */
  export type ProvinciaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provincia
     */
    select?: ProvinciaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provincia
     */
    omit?: ProvinciaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvinciaInclude<ExtArgs> | null
    /**
     * The data needed to create a Provincia.
     */
    data: XOR<ProvinciaCreateInput, ProvinciaUncheckedCreateInput>
  }

  /**
   * Provincia createMany
   */
  export type ProvinciaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Provincias.
     */
    data: ProvinciaCreateManyInput | ProvinciaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Provincia createManyAndReturn
   */
  export type ProvinciaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provincia
     */
    select?: ProvinciaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Provincia
     */
    omit?: ProvinciaOmit<ExtArgs> | null
    /**
     * The data used to create many Provincias.
     */
    data: ProvinciaCreateManyInput | ProvinciaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvinciaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Provincia update
   */
  export type ProvinciaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provincia
     */
    select?: ProvinciaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provincia
     */
    omit?: ProvinciaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvinciaInclude<ExtArgs> | null
    /**
     * The data needed to update a Provincia.
     */
    data: XOR<ProvinciaUpdateInput, ProvinciaUncheckedUpdateInput>
    /**
     * Choose, which Provincia to update.
     */
    where: ProvinciaWhereUniqueInput
  }

  /**
   * Provincia updateMany
   */
  export type ProvinciaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Provincias.
     */
    data: XOR<ProvinciaUpdateManyMutationInput, ProvinciaUncheckedUpdateManyInput>
    /**
     * Filter which Provincias to update
     */
    where?: ProvinciaWhereInput
    /**
     * Limit how many Provincias to update.
     */
    limit?: number
  }

  /**
   * Provincia updateManyAndReturn
   */
  export type ProvinciaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provincia
     */
    select?: ProvinciaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Provincia
     */
    omit?: ProvinciaOmit<ExtArgs> | null
    /**
     * The data used to update Provincias.
     */
    data: XOR<ProvinciaUpdateManyMutationInput, ProvinciaUncheckedUpdateManyInput>
    /**
     * Filter which Provincias to update
     */
    where?: ProvinciaWhereInput
    /**
     * Limit how many Provincias to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvinciaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Provincia upsert
   */
  export type ProvinciaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provincia
     */
    select?: ProvinciaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provincia
     */
    omit?: ProvinciaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvinciaInclude<ExtArgs> | null
    /**
     * The filter to search for the Provincia to update in case it exists.
     */
    where: ProvinciaWhereUniqueInput
    /**
     * In case the Provincia found by the `where` argument doesn't exist, create a new Provincia with this data.
     */
    create: XOR<ProvinciaCreateInput, ProvinciaUncheckedCreateInput>
    /**
     * In case the Provincia was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProvinciaUpdateInput, ProvinciaUncheckedUpdateInput>
  }

  /**
   * Provincia delete
   */
  export type ProvinciaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provincia
     */
    select?: ProvinciaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provincia
     */
    omit?: ProvinciaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvinciaInclude<ExtArgs> | null
    /**
     * Filter which Provincia to delete.
     */
    where: ProvinciaWhereUniqueInput
  }

  /**
   * Provincia deleteMany
   */
  export type ProvinciaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Provincias to delete
     */
    where?: ProvinciaWhereInput
    /**
     * Limit how many Provincias to delete.
     */
    limit?: number
  }

  /**
   * Provincia.Colegio
   */
  export type Provincia$ColegioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Colegio
     */
    select?: ColegioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Colegio
     */
    omit?: ColegioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColegioInclude<ExtArgs> | null
    where?: ColegioWhereInput
    orderBy?: ColegioOrderByWithRelationInput | ColegioOrderByWithRelationInput[]
    cursor?: ColegioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ColegioScalarFieldEnum | ColegioScalarFieldEnum[]
  }

  /**
   * Provincia.Competidor
   */
  export type Provincia$CompetidorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Competidor
     */
    select?: CompetidorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Competidor
     */
    omit?: CompetidorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompetidorInclude<ExtArgs> | null
    where?: CompetidorWhereInput
    orderBy?: CompetidorOrderByWithRelationInput | CompetidorOrderByWithRelationInput[]
    cursor?: CompetidorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompetidorScalarFieldEnum | CompetidorScalarFieldEnum[]
  }

  /**
   * Provincia without action
   */
  export type ProvinciaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provincia
     */
    select?: ProvinciaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provincia
     */
    omit?: ProvinciaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvinciaInclude<ExtArgs> | null
  }


  /**
   * Model Colegio
   */

  export type AggregateColegio = {
    _count: ColegioCountAggregateOutputType | null
    _avg: ColegioAvgAggregateOutputType | null
    _sum: ColegioSumAggregateOutputType | null
    _min: ColegioMinAggregateOutputType | null
    _max: ColegioMaxAggregateOutputType | null
  }

  export type ColegioAvgAggregateOutputType = {
    id: number | null
    provincia_id: number | null
  }

  export type ColegioSumAggregateOutputType = {
    id: number | null
    provincia_id: number | null
  }

  export type ColegioMinAggregateOutputType = {
    id: number | null
    nombre_colegio: string | null
    provincia_id: number | null
  }

  export type ColegioMaxAggregateOutputType = {
    id: number | null
    nombre_colegio: string | null
    provincia_id: number | null
  }

  export type ColegioCountAggregateOutputType = {
    id: number
    nombre_colegio: number
    provincia_id: number
    _all: number
  }


  export type ColegioAvgAggregateInputType = {
    id?: true
    provincia_id?: true
  }

  export type ColegioSumAggregateInputType = {
    id?: true
    provincia_id?: true
  }

  export type ColegioMinAggregateInputType = {
    id?: true
    nombre_colegio?: true
    provincia_id?: true
  }

  export type ColegioMaxAggregateInputType = {
    id?: true
    nombre_colegio?: true
    provincia_id?: true
  }

  export type ColegioCountAggregateInputType = {
    id?: true
    nombre_colegio?: true
    provincia_id?: true
    _all?: true
  }

  export type ColegioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Colegio to aggregate.
     */
    where?: ColegioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Colegios to fetch.
     */
    orderBy?: ColegioOrderByWithRelationInput | ColegioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ColegioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Colegios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Colegios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Colegios
    **/
    _count?: true | ColegioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ColegioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ColegioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ColegioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ColegioMaxAggregateInputType
  }

  export type GetColegioAggregateType<T extends ColegioAggregateArgs> = {
        [P in keyof T & keyof AggregateColegio]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateColegio[P]>
      : GetScalarType<T[P], AggregateColegio[P]>
  }




  export type ColegioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ColegioWhereInput
    orderBy?: ColegioOrderByWithAggregationInput | ColegioOrderByWithAggregationInput[]
    by: ColegioScalarFieldEnum[] | ColegioScalarFieldEnum
    having?: ColegioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ColegioCountAggregateInputType | true
    _avg?: ColegioAvgAggregateInputType
    _sum?: ColegioSumAggregateInputType
    _min?: ColegioMinAggregateInputType
    _max?: ColegioMaxAggregateInputType
  }

  export type ColegioGroupByOutputType = {
    id: number
    nombre_colegio: string
    provincia_id: number
    _count: ColegioCountAggregateOutputType | null
    _avg: ColegioAvgAggregateOutputType | null
    _sum: ColegioSumAggregateOutputType | null
    _min: ColegioMinAggregateOutputType | null
    _max: ColegioMaxAggregateOutputType | null
  }

  type GetColegioGroupByPayload<T extends ColegioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ColegioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ColegioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ColegioGroupByOutputType[P]>
            : GetScalarType<T[P], ColegioGroupByOutputType[P]>
        }
      >
    >


  export type ColegioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre_colegio?: boolean
    provincia_id?: boolean
    provincia?: boolean | ProvinciaDefaultArgs<ExtArgs>
    Competidores?: boolean | Colegio$CompetidoresArgs<ExtArgs>
    _count?: boolean | ColegioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["colegio"]>

  export type ColegioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre_colegio?: boolean
    provincia_id?: boolean
    provincia?: boolean | ProvinciaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["colegio"]>

  export type ColegioSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre_colegio?: boolean
    provincia_id?: boolean
    provincia?: boolean | ProvinciaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["colegio"]>

  export type ColegioSelectScalar = {
    id?: boolean
    nombre_colegio?: boolean
    provincia_id?: boolean
  }

  export type ColegioOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nombre_colegio" | "provincia_id", ExtArgs["result"]["colegio"]>
  export type ColegioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provincia?: boolean | ProvinciaDefaultArgs<ExtArgs>
    Competidores?: boolean | Colegio$CompetidoresArgs<ExtArgs>
    _count?: boolean | ColegioCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ColegioIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provincia?: boolean | ProvinciaDefaultArgs<ExtArgs>
  }
  export type ColegioIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provincia?: boolean | ProvinciaDefaultArgs<ExtArgs>
  }

  export type $ColegioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Colegio"
    objects: {
      provincia: Prisma.$ProvinciaPayload<ExtArgs>
      Competidores: Prisma.$CompetidorPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre_colegio: string
      provincia_id: number
    }, ExtArgs["result"]["colegio"]>
    composites: {}
  }

  type ColegioGetPayload<S extends boolean | null | undefined | ColegioDefaultArgs> = $Result.GetResult<Prisma.$ColegioPayload, S>

  type ColegioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ColegioFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ColegioCountAggregateInputType | true
    }

  export interface ColegioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Colegio'], meta: { name: 'Colegio' } }
    /**
     * Find zero or one Colegio that matches the filter.
     * @param {ColegioFindUniqueArgs} args - Arguments to find a Colegio
     * @example
     * // Get one Colegio
     * const colegio = await prisma.colegio.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ColegioFindUniqueArgs>(args: SelectSubset<T, ColegioFindUniqueArgs<ExtArgs>>): Prisma__ColegioClient<$Result.GetResult<Prisma.$ColegioPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Colegio that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ColegioFindUniqueOrThrowArgs} args - Arguments to find a Colegio
     * @example
     * // Get one Colegio
     * const colegio = await prisma.colegio.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ColegioFindUniqueOrThrowArgs>(args: SelectSubset<T, ColegioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ColegioClient<$Result.GetResult<Prisma.$ColegioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Colegio that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColegioFindFirstArgs} args - Arguments to find a Colegio
     * @example
     * // Get one Colegio
     * const colegio = await prisma.colegio.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ColegioFindFirstArgs>(args?: SelectSubset<T, ColegioFindFirstArgs<ExtArgs>>): Prisma__ColegioClient<$Result.GetResult<Prisma.$ColegioPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Colegio that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColegioFindFirstOrThrowArgs} args - Arguments to find a Colegio
     * @example
     * // Get one Colegio
     * const colegio = await prisma.colegio.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ColegioFindFirstOrThrowArgs>(args?: SelectSubset<T, ColegioFindFirstOrThrowArgs<ExtArgs>>): Prisma__ColegioClient<$Result.GetResult<Prisma.$ColegioPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Colegios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColegioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Colegios
     * const colegios = await prisma.colegio.findMany()
     * 
     * // Get first 10 Colegios
     * const colegios = await prisma.colegio.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const colegioWithIdOnly = await prisma.colegio.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ColegioFindManyArgs>(args?: SelectSubset<T, ColegioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ColegioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Colegio.
     * @param {ColegioCreateArgs} args - Arguments to create a Colegio.
     * @example
     * // Create one Colegio
     * const Colegio = await prisma.colegio.create({
     *   data: {
     *     // ... data to create a Colegio
     *   }
     * })
     * 
     */
    create<T extends ColegioCreateArgs>(args: SelectSubset<T, ColegioCreateArgs<ExtArgs>>): Prisma__ColegioClient<$Result.GetResult<Prisma.$ColegioPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Colegios.
     * @param {ColegioCreateManyArgs} args - Arguments to create many Colegios.
     * @example
     * // Create many Colegios
     * const colegio = await prisma.colegio.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ColegioCreateManyArgs>(args?: SelectSubset<T, ColegioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Colegios and returns the data saved in the database.
     * @param {ColegioCreateManyAndReturnArgs} args - Arguments to create many Colegios.
     * @example
     * // Create many Colegios
     * const colegio = await prisma.colegio.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Colegios and only return the `id`
     * const colegioWithIdOnly = await prisma.colegio.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ColegioCreateManyAndReturnArgs>(args?: SelectSubset<T, ColegioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ColegioPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Colegio.
     * @param {ColegioDeleteArgs} args - Arguments to delete one Colegio.
     * @example
     * // Delete one Colegio
     * const Colegio = await prisma.colegio.delete({
     *   where: {
     *     // ... filter to delete one Colegio
     *   }
     * })
     * 
     */
    delete<T extends ColegioDeleteArgs>(args: SelectSubset<T, ColegioDeleteArgs<ExtArgs>>): Prisma__ColegioClient<$Result.GetResult<Prisma.$ColegioPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Colegio.
     * @param {ColegioUpdateArgs} args - Arguments to update one Colegio.
     * @example
     * // Update one Colegio
     * const colegio = await prisma.colegio.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ColegioUpdateArgs>(args: SelectSubset<T, ColegioUpdateArgs<ExtArgs>>): Prisma__ColegioClient<$Result.GetResult<Prisma.$ColegioPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Colegios.
     * @param {ColegioDeleteManyArgs} args - Arguments to filter Colegios to delete.
     * @example
     * // Delete a few Colegios
     * const { count } = await prisma.colegio.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ColegioDeleteManyArgs>(args?: SelectSubset<T, ColegioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Colegios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColegioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Colegios
     * const colegio = await prisma.colegio.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ColegioUpdateManyArgs>(args: SelectSubset<T, ColegioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Colegios and returns the data updated in the database.
     * @param {ColegioUpdateManyAndReturnArgs} args - Arguments to update many Colegios.
     * @example
     * // Update many Colegios
     * const colegio = await prisma.colegio.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Colegios and only return the `id`
     * const colegioWithIdOnly = await prisma.colegio.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ColegioUpdateManyAndReturnArgs>(args: SelectSubset<T, ColegioUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ColegioPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Colegio.
     * @param {ColegioUpsertArgs} args - Arguments to update or create a Colegio.
     * @example
     * // Update or create a Colegio
     * const colegio = await prisma.colegio.upsert({
     *   create: {
     *     // ... data to create a Colegio
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Colegio we want to update
     *   }
     * })
     */
    upsert<T extends ColegioUpsertArgs>(args: SelectSubset<T, ColegioUpsertArgs<ExtArgs>>): Prisma__ColegioClient<$Result.GetResult<Prisma.$ColegioPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Colegios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColegioCountArgs} args - Arguments to filter Colegios to count.
     * @example
     * // Count the number of Colegios
     * const count = await prisma.colegio.count({
     *   where: {
     *     // ... the filter for the Colegios we want to count
     *   }
     * })
    **/
    count<T extends ColegioCountArgs>(
      args?: Subset<T, ColegioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ColegioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Colegio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColegioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ColegioAggregateArgs>(args: Subset<T, ColegioAggregateArgs>): Prisma.PrismaPromise<GetColegioAggregateType<T>>

    /**
     * Group by Colegio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColegioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ColegioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ColegioGroupByArgs['orderBy'] }
        : { orderBy?: ColegioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ColegioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetColegioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Colegio model
   */
  readonly fields: ColegioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Colegio.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ColegioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    provincia<T extends ProvinciaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProvinciaDefaultArgs<ExtArgs>>): Prisma__ProvinciaClient<$Result.GetResult<Prisma.$ProvinciaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Competidores<T extends Colegio$CompetidoresArgs<ExtArgs> = {}>(args?: Subset<T, Colegio$CompetidoresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompetidorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Colegio model
   */
  interface ColegioFieldRefs {
    readonly id: FieldRef<"Colegio", 'Int'>
    readonly nombre_colegio: FieldRef<"Colegio", 'String'>
    readonly provincia_id: FieldRef<"Colegio", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Colegio findUnique
   */
  export type ColegioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Colegio
     */
    select?: ColegioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Colegio
     */
    omit?: ColegioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColegioInclude<ExtArgs> | null
    /**
     * Filter, which Colegio to fetch.
     */
    where: ColegioWhereUniqueInput
  }

  /**
   * Colegio findUniqueOrThrow
   */
  export type ColegioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Colegio
     */
    select?: ColegioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Colegio
     */
    omit?: ColegioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColegioInclude<ExtArgs> | null
    /**
     * Filter, which Colegio to fetch.
     */
    where: ColegioWhereUniqueInput
  }

  /**
   * Colegio findFirst
   */
  export type ColegioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Colegio
     */
    select?: ColegioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Colegio
     */
    omit?: ColegioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColegioInclude<ExtArgs> | null
    /**
     * Filter, which Colegio to fetch.
     */
    where?: ColegioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Colegios to fetch.
     */
    orderBy?: ColegioOrderByWithRelationInput | ColegioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Colegios.
     */
    cursor?: ColegioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Colegios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Colegios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Colegios.
     */
    distinct?: ColegioScalarFieldEnum | ColegioScalarFieldEnum[]
  }

  /**
   * Colegio findFirstOrThrow
   */
  export type ColegioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Colegio
     */
    select?: ColegioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Colegio
     */
    omit?: ColegioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColegioInclude<ExtArgs> | null
    /**
     * Filter, which Colegio to fetch.
     */
    where?: ColegioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Colegios to fetch.
     */
    orderBy?: ColegioOrderByWithRelationInput | ColegioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Colegios.
     */
    cursor?: ColegioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Colegios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Colegios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Colegios.
     */
    distinct?: ColegioScalarFieldEnum | ColegioScalarFieldEnum[]
  }

  /**
   * Colegio findMany
   */
  export type ColegioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Colegio
     */
    select?: ColegioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Colegio
     */
    omit?: ColegioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColegioInclude<ExtArgs> | null
    /**
     * Filter, which Colegios to fetch.
     */
    where?: ColegioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Colegios to fetch.
     */
    orderBy?: ColegioOrderByWithRelationInput | ColegioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Colegios.
     */
    cursor?: ColegioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Colegios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Colegios.
     */
    skip?: number
    distinct?: ColegioScalarFieldEnum | ColegioScalarFieldEnum[]
  }

  /**
   * Colegio create
   */
  export type ColegioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Colegio
     */
    select?: ColegioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Colegio
     */
    omit?: ColegioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColegioInclude<ExtArgs> | null
    /**
     * The data needed to create a Colegio.
     */
    data: XOR<ColegioCreateInput, ColegioUncheckedCreateInput>
  }

  /**
   * Colegio createMany
   */
  export type ColegioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Colegios.
     */
    data: ColegioCreateManyInput | ColegioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Colegio createManyAndReturn
   */
  export type ColegioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Colegio
     */
    select?: ColegioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Colegio
     */
    omit?: ColegioOmit<ExtArgs> | null
    /**
     * The data used to create many Colegios.
     */
    data: ColegioCreateManyInput | ColegioCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColegioIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Colegio update
   */
  export type ColegioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Colegio
     */
    select?: ColegioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Colegio
     */
    omit?: ColegioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColegioInclude<ExtArgs> | null
    /**
     * The data needed to update a Colegio.
     */
    data: XOR<ColegioUpdateInput, ColegioUncheckedUpdateInput>
    /**
     * Choose, which Colegio to update.
     */
    where: ColegioWhereUniqueInput
  }

  /**
   * Colegio updateMany
   */
  export type ColegioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Colegios.
     */
    data: XOR<ColegioUpdateManyMutationInput, ColegioUncheckedUpdateManyInput>
    /**
     * Filter which Colegios to update
     */
    where?: ColegioWhereInput
    /**
     * Limit how many Colegios to update.
     */
    limit?: number
  }

  /**
   * Colegio updateManyAndReturn
   */
  export type ColegioUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Colegio
     */
    select?: ColegioSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Colegio
     */
    omit?: ColegioOmit<ExtArgs> | null
    /**
     * The data used to update Colegios.
     */
    data: XOR<ColegioUpdateManyMutationInput, ColegioUncheckedUpdateManyInput>
    /**
     * Filter which Colegios to update
     */
    where?: ColegioWhereInput
    /**
     * Limit how many Colegios to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColegioIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Colegio upsert
   */
  export type ColegioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Colegio
     */
    select?: ColegioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Colegio
     */
    omit?: ColegioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColegioInclude<ExtArgs> | null
    /**
     * The filter to search for the Colegio to update in case it exists.
     */
    where: ColegioWhereUniqueInput
    /**
     * In case the Colegio found by the `where` argument doesn't exist, create a new Colegio with this data.
     */
    create: XOR<ColegioCreateInput, ColegioUncheckedCreateInput>
    /**
     * In case the Colegio was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ColegioUpdateInput, ColegioUncheckedUpdateInput>
  }

  /**
   * Colegio delete
   */
  export type ColegioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Colegio
     */
    select?: ColegioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Colegio
     */
    omit?: ColegioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColegioInclude<ExtArgs> | null
    /**
     * Filter which Colegio to delete.
     */
    where: ColegioWhereUniqueInput
  }

  /**
   * Colegio deleteMany
   */
  export type ColegioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Colegios to delete
     */
    where?: ColegioWhereInput
    /**
     * Limit how many Colegios to delete.
     */
    limit?: number
  }

  /**
   * Colegio.Competidores
   */
  export type Colegio$CompetidoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Competidor
     */
    select?: CompetidorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Competidor
     */
    omit?: CompetidorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompetidorInclude<ExtArgs> | null
    where?: CompetidorWhereInput
    orderBy?: CompetidorOrderByWithRelationInput | CompetidorOrderByWithRelationInput[]
    cursor?: CompetidorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompetidorScalarFieldEnum | CompetidorScalarFieldEnum[]
  }

  /**
   * Colegio without action
   */
  export type ColegioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Colegio
     */
    select?: ColegioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Colegio
     */
    omit?: ColegioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColegioInclude<ExtArgs> | null
  }


  /**
   * Model Convocatoria
   */

  export type AggregateConvocatoria = {
    _count: ConvocatoriaCountAggregateOutputType | null
    _avg: ConvocatoriaAvgAggregateOutputType | null
    _sum: ConvocatoriaSumAggregateOutputType | null
    _min: ConvocatoriaMinAggregateOutputType | null
    _max: ConvocatoriaMaxAggregateOutputType | null
  }

  export type ConvocatoriaAvgAggregateOutputType = {
    id: number | null
    id_estado_convocatoria: number | null
  }

  export type ConvocatoriaSumAggregateOutputType = {
    id: number | null
    id_estado_convocatoria: number | null
  }

  export type ConvocatoriaMinAggregateOutputType = {
    id: number | null
    nombre_convocatoria: string | null
    id_estado_convocatoria: number | null
    fecha_inicio: Date | null
    fecha_fin: Date | null
    pago_fin: Date | null
    pago_inicio: Date | null
    competicion_inicio: Date | null
    competicion_fin: Date | null
    descripcion_convocatoria: string | null
  }

  export type ConvocatoriaMaxAggregateOutputType = {
    id: number | null
    nombre_convocatoria: string | null
    id_estado_convocatoria: number | null
    fecha_inicio: Date | null
    fecha_fin: Date | null
    pago_fin: Date | null
    pago_inicio: Date | null
    competicion_inicio: Date | null
    competicion_fin: Date | null
    descripcion_convocatoria: string | null
  }

  export type ConvocatoriaCountAggregateOutputType = {
    id: number
    nombre_convocatoria: number
    id_estado_convocatoria: number
    fecha_inicio: number
    fecha_fin: number
    pago_fin: number
    pago_inicio: number
    competicion_inicio: number
    competicion_fin: number
    descripcion_convocatoria: number
    _all: number
  }


  export type ConvocatoriaAvgAggregateInputType = {
    id?: true
    id_estado_convocatoria?: true
  }

  export type ConvocatoriaSumAggregateInputType = {
    id?: true
    id_estado_convocatoria?: true
  }

  export type ConvocatoriaMinAggregateInputType = {
    id?: true
    nombre_convocatoria?: true
    id_estado_convocatoria?: true
    fecha_inicio?: true
    fecha_fin?: true
    pago_fin?: true
    pago_inicio?: true
    competicion_inicio?: true
    competicion_fin?: true
    descripcion_convocatoria?: true
  }

  export type ConvocatoriaMaxAggregateInputType = {
    id?: true
    nombre_convocatoria?: true
    id_estado_convocatoria?: true
    fecha_inicio?: true
    fecha_fin?: true
    pago_fin?: true
    pago_inicio?: true
    competicion_inicio?: true
    competicion_fin?: true
    descripcion_convocatoria?: true
  }

  export type ConvocatoriaCountAggregateInputType = {
    id?: true
    nombre_convocatoria?: true
    id_estado_convocatoria?: true
    fecha_inicio?: true
    fecha_fin?: true
    pago_fin?: true
    pago_inicio?: true
    competicion_inicio?: true
    competicion_fin?: true
    descripcion_convocatoria?: true
    _all?: true
  }

  export type ConvocatoriaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Convocatoria to aggregate.
     */
    where?: ConvocatoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Convocatorias to fetch.
     */
    orderBy?: ConvocatoriaOrderByWithRelationInput | ConvocatoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConvocatoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Convocatorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Convocatorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Convocatorias
    **/
    _count?: true | ConvocatoriaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConvocatoriaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConvocatoriaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConvocatoriaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConvocatoriaMaxAggregateInputType
  }

  export type GetConvocatoriaAggregateType<T extends ConvocatoriaAggregateArgs> = {
        [P in keyof T & keyof AggregateConvocatoria]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConvocatoria[P]>
      : GetScalarType<T[P], AggregateConvocatoria[P]>
  }




  export type ConvocatoriaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConvocatoriaWhereInput
    orderBy?: ConvocatoriaOrderByWithAggregationInput | ConvocatoriaOrderByWithAggregationInput[]
    by: ConvocatoriaScalarFieldEnum[] | ConvocatoriaScalarFieldEnum
    having?: ConvocatoriaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConvocatoriaCountAggregateInputType | true
    _avg?: ConvocatoriaAvgAggregateInputType
    _sum?: ConvocatoriaSumAggregateInputType
    _min?: ConvocatoriaMinAggregateInputType
    _max?: ConvocatoriaMaxAggregateInputType
  }

  export type ConvocatoriaGroupByOutputType = {
    id: number
    nombre_convocatoria: string
    id_estado_convocatoria: number
    fecha_inicio: Date
    fecha_fin: Date
    pago_fin: Date
    pago_inicio: Date
    competicion_inicio: Date
    competicion_fin: Date
    descripcion_convocatoria: string
    _count: ConvocatoriaCountAggregateOutputType | null
    _avg: ConvocatoriaAvgAggregateOutputType | null
    _sum: ConvocatoriaSumAggregateOutputType | null
    _min: ConvocatoriaMinAggregateOutputType | null
    _max: ConvocatoriaMaxAggregateOutputType | null
  }

  type GetConvocatoriaGroupByPayload<T extends ConvocatoriaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConvocatoriaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConvocatoriaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConvocatoriaGroupByOutputType[P]>
            : GetScalarType<T[P], ConvocatoriaGroupByOutputType[P]>
        }
      >
    >


  export type ConvocatoriaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre_convocatoria?: boolean
    id_estado_convocatoria?: boolean
    fecha_inicio?: boolean
    fecha_fin?: boolean
    pago_fin?: boolean
    pago_inicio?: boolean
    competicion_inicio?: boolean
    competicion_fin?: boolean
    descripcion_convocatoria?: boolean
    Area_convocatoria?: boolean | Convocatoria$Area_convocatoriaArgs<ExtArgs>
    estado_convocatoria?: boolean | estado_convocatoriaDefaultArgs<ExtArgs>
    Inscripcion?: boolean | Convocatoria$InscripcionArgs<ExtArgs>
    _count?: boolean | ConvocatoriaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["convocatoria"]>

  export type ConvocatoriaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre_convocatoria?: boolean
    id_estado_convocatoria?: boolean
    fecha_inicio?: boolean
    fecha_fin?: boolean
    pago_fin?: boolean
    pago_inicio?: boolean
    competicion_inicio?: boolean
    competicion_fin?: boolean
    descripcion_convocatoria?: boolean
    estado_convocatoria?: boolean | estado_convocatoriaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["convocatoria"]>

  export type ConvocatoriaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre_convocatoria?: boolean
    id_estado_convocatoria?: boolean
    fecha_inicio?: boolean
    fecha_fin?: boolean
    pago_fin?: boolean
    pago_inicio?: boolean
    competicion_inicio?: boolean
    competicion_fin?: boolean
    descripcion_convocatoria?: boolean
    estado_convocatoria?: boolean | estado_convocatoriaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["convocatoria"]>

  export type ConvocatoriaSelectScalar = {
    id?: boolean
    nombre_convocatoria?: boolean
    id_estado_convocatoria?: boolean
    fecha_inicio?: boolean
    fecha_fin?: boolean
    pago_fin?: boolean
    pago_inicio?: boolean
    competicion_inicio?: boolean
    competicion_fin?: boolean
    descripcion_convocatoria?: boolean
  }

  export type ConvocatoriaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nombre_convocatoria" | "id_estado_convocatoria" | "fecha_inicio" | "fecha_fin" | "pago_fin" | "pago_inicio" | "competicion_inicio" | "competicion_fin" | "descripcion_convocatoria", ExtArgs["result"]["convocatoria"]>
  export type ConvocatoriaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Area_convocatoria?: boolean | Convocatoria$Area_convocatoriaArgs<ExtArgs>
    estado_convocatoria?: boolean | estado_convocatoriaDefaultArgs<ExtArgs>
    Inscripcion?: boolean | Convocatoria$InscripcionArgs<ExtArgs>
    _count?: boolean | ConvocatoriaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ConvocatoriaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estado_convocatoria?: boolean | estado_convocatoriaDefaultArgs<ExtArgs>
  }
  export type ConvocatoriaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estado_convocatoria?: boolean | estado_convocatoriaDefaultArgs<ExtArgs>
  }

  export type $ConvocatoriaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Convocatoria"
    objects: {
      Area_convocatoria: Prisma.$Area_convocatoriaPayload<ExtArgs>[]
      estado_convocatoria: Prisma.$estado_convocatoriaPayload<ExtArgs>
      Inscripcion: Prisma.$InscripcionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre_convocatoria: string
      id_estado_convocatoria: number
      fecha_inicio: Date
      fecha_fin: Date
      pago_fin: Date
      pago_inicio: Date
      competicion_inicio: Date
      competicion_fin: Date
      descripcion_convocatoria: string
    }, ExtArgs["result"]["convocatoria"]>
    composites: {}
  }

  type ConvocatoriaGetPayload<S extends boolean | null | undefined | ConvocatoriaDefaultArgs> = $Result.GetResult<Prisma.$ConvocatoriaPayload, S>

  type ConvocatoriaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConvocatoriaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConvocatoriaCountAggregateInputType | true
    }

  export interface ConvocatoriaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Convocatoria'], meta: { name: 'Convocatoria' } }
    /**
     * Find zero or one Convocatoria that matches the filter.
     * @param {ConvocatoriaFindUniqueArgs} args - Arguments to find a Convocatoria
     * @example
     * // Get one Convocatoria
     * const convocatoria = await prisma.convocatoria.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConvocatoriaFindUniqueArgs>(args: SelectSubset<T, ConvocatoriaFindUniqueArgs<ExtArgs>>): Prisma__ConvocatoriaClient<$Result.GetResult<Prisma.$ConvocatoriaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Convocatoria that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConvocatoriaFindUniqueOrThrowArgs} args - Arguments to find a Convocatoria
     * @example
     * // Get one Convocatoria
     * const convocatoria = await prisma.convocatoria.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConvocatoriaFindUniqueOrThrowArgs>(args: SelectSubset<T, ConvocatoriaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConvocatoriaClient<$Result.GetResult<Prisma.$ConvocatoriaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Convocatoria that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConvocatoriaFindFirstArgs} args - Arguments to find a Convocatoria
     * @example
     * // Get one Convocatoria
     * const convocatoria = await prisma.convocatoria.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConvocatoriaFindFirstArgs>(args?: SelectSubset<T, ConvocatoriaFindFirstArgs<ExtArgs>>): Prisma__ConvocatoriaClient<$Result.GetResult<Prisma.$ConvocatoriaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Convocatoria that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConvocatoriaFindFirstOrThrowArgs} args - Arguments to find a Convocatoria
     * @example
     * // Get one Convocatoria
     * const convocatoria = await prisma.convocatoria.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConvocatoriaFindFirstOrThrowArgs>(args?: SelectSubset<T, ConvocatoriaFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConvocatoriaClient<$Result.GetResult<Prisma.$ConvocatoriaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Convocatorias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConvocatoriaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Convocatorias
     * const convocatorias = await prisma.convocatoria.findMany()
     * 
     * // Get first 10 Convocatorias
     * const convocatorias = await prisma.convocatoria.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const convocatoriaWithIdOnly = await prisma.convocatoria.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConvocatoriaFindManyArgs>(args?: SelectSubset<T, ConvocatoriaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConvocatoriaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Convocatoria.
     * @param {ConvocatoriaCreateArgs} args - Arguments to create a Convocatoria.
     * @example
     * // Create one Convocatoria
     * const Convocatoria = await prisma.convocatoria.create({
     *   data: {
     *     // ... data to create a Convocatoria
     *   }
     * })
     * 
     */
    create<T extends ConvocatoriaCreateArgs>(args: SelectSubset<T, ConvocatoriaCreateArgs<ExtArgs>>): Prisma__ConvocatoriaClient<$Result.GetResult<Prisma.$ConvocatoriaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Convocatorias.
     * @param {ConvocatoriaCreateManyArgs} args - Arguments to create many Convocatorias.
     * @example
     * // Create many Convocatorias
     * const convocatoria = await prisma.convocatoria.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConvocatoriaCreateManyArgs>(args?: SelectSubset<T, ConvocatoriaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Convocatorias and returns the data saved in the database.
     * @param {ConvocatoriaCreateManyAndReturnArgs} args - Arguments to create many Convocatorias.
     * @example
     * // Create many Convocatorias
     * const convocatoria = await prisma.convocatoria.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Convocatorias and only return the `id`
     * const convocatoriaWithIdOnly = await prisma.convocatoria.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConvocatoriaCreateManyAndReturnArgs>(args?: SelectSubset<T, ConvocatoriaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConvocatoriaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Convocatoria.
     * @param {ConvocatoriaDeleteArgs} args - Arguments to delete one Convocatoria.
     * @example
     * // Delete one Convocatoria
     * const Convocatoria = await prisma.convocatoria.delete({
     *   where: {
     *     // ... filter to delete one Convocatoria
     *   }
     * })
     * 
     */
    delete<T extends ConvocatoriaDeleteArgs>(args: SelectSubset<T, ConvocatoriaDeleteArgs<ExtArgs>>): Prisma__ConvocatoriaClient<$Result.GetResult<Prisma.$ConvocatoriaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Convocatoria.
     * @param {ConvocatoriaUpdateArgs} args - Arguments to update one Convocatoria.
     * @example
     * // Update one Convocatoria
     * const convocatoria = await prisma.convocatoria.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConvocatoriaUpdateArgs>(args: SelectSubset<T, ConvocatoriaUpdateArgs<ExtArgs>>): Prisma__ConvocatoriaClient<$Result.GetResult<Prisma.$ConvocatoriaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Convocatorias.
     * @param {ConvocatoriaDeleteManyArgs} args - Arguments to filter Convocatorias to delete.
     * @example
     * // Delete a few Convocatorias
     * const { count } = await prisma.convocatoria.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConvocatoriaDeleteManyArgs>(args?: SelectSubset<T, ConvocatoriaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Convocatorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConvocatoriaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Convocatorias
     * const convocatoria = await prisma.convocatoria.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConvocatoriaUpdateManyArgs>(args: SelectSubset<T, ConvocatoriaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Convocatorias and returns the data updated in the database.
     * @param {ConvocatoriaUpdateManyAndReturnArgs} args - Arguments to update many Convocatorias.
     * @example
     * // Update many Convocatorias
     * const convocatoria = await prisma.convocatoria.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Convocatorias and only return the `id`
     * const convocatoriaWithIdOnly = await prisma.convocatoria.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConvocatoriaUpdateManyAndReturnArgs>(args: SelectSubset<T, ConvocatoriaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConvocatoriaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Convocatoria.
     * @param {ConvocatoriaUpsertArgs} args - Arguments to update or create a Convocatoria.
     * @example
     * // Update or create a Convocatoria
     * const convocatoria = await prisma.convocatoria.upsert({
     *   create: {
     *     // ... data to create a Convocatoria
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Convocatoria we want to update
     *   }
     * })
     */
    upsert<T extends ConvocatoriaUpsertArgs>(args: SelectSubset<T, ConvocatoriaUpsertArgs<ExtArgs>>): Prisma__ConvocatoriaClient<$Result.GetResult<Prisma.$ConvocatoriaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Convocatorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConvocatoriaCountArgs} args - Arguments to filter Convocatorias to count.
     * @example
     * // Count the number of Convocatorias
     * const count = await prisma.convocatoria.count({
     *   where: {
     *     // ... the filter for the Convocatorias we want to count
     *   }
     * })
    **/
    count<T extends ConvocatoriaCountArgs>(
      args?: Subset<T, ConvocatoriaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConvocatoriaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Convocatoria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConvocatoriaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConvocatoriaAggregateArgs>(args: Subset<T, ConvocatoriaAggregateArgs>): Prisma.PrismaPromise<GetConvocatoriaAggregateType<T>>

    /**
     * Group by Convocatoria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConvocatoriaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConvocatoriaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConvocatoriaGroupByArgs['orderBy'] }
        : { orderBy?: ConvocatoriaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConvocatoriaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConvocatoriaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Convocatoria model
   */
  readonly fields: ConvocatoriaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Convocatoria.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConvocatoriaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Area_convocatoria<T extends Convocatoria$Area_convocatoriaArgs<ExtArgs> = {}>(args?: Subset<T, Convocatoria$Area_convocatoriaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Area_convocatoriaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    estado_convocatoria<T extends estado_convocatoriaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, estado_convocatoriaDefaultArgs<ExtArgs>>): Prisma__estado_convocatoriaClient<$Result.GetResult<Prisma.$estado_convocatoriaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Inscripcion<T extends Convocatoria$InscripcionArgs<ExtArgs> = {}>(args?: Subset<T, Convocatoria$InscripcionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InscripcionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Convocatoria model
   */
  interface ConvocatoriaFieldRefs {
    readonly id: FieldRef<"Convocatoria", 'Int'>
    readonly nombre_convocatoria: FieldRef<"Convocatoria", 'String'>
    readonly id_estado_convocatoria: FieldRef<"Convocatoria", 'Int'>
    readonly fecha_inicio: FieldRef<"Convocatoria", 'DateTime'>
    readonly fecha_fin: FieldRef<"Convocatoria", 'DateTime'>
    readonly pago_fin: FieldRef<"Convocatoria", 'DateTime'>
    readonly pago_inicio: FieldRef<"Convocatoria", 'DateTime'>
    readonly competicion_inicio: FieldRef<"Convocatoria", 'DateTime'>
    readonly competicion_fin: FieldRef<"Convocatoria", 'DateTime'>
    readonly descripcion_convocatoria: FieldRef<"Convocatoria", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Convocatoria findUnique
   */
  export type ConvocatoriaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Convocatoria
     */
    select?: ConvocatoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Convocatoria
     */
    omit?: ConvocatoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConvocatoriaInclude<ExtArgs> | null
    /**
     * Filter, which Convocatoria to fetch.
     */
    where: ConvocatoriaWhereUniqueInput
  }

  /**
   * Convocatoria findUniqueOrThrow
   */
  export type ConvocatoriaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Convocatoria
     */
    select?: ConvocatoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Convocatoria
     */
    omit?: ConvocatoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConvocatoriaInclude<ExtArgs> | null
    /**
     * Filter, which Convocatoria to fetch.
     */
    where: ConvocatoriaWhereUniqueInput
  }

  /**
   * Convocatoria findFirst
   */
  export type ConvocatoriaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Convocatoria
     */
    select?: ConvocatoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Convocatoria
     */
    omit?: ConvocatoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConvocatoriaInclude<ExtArgs> | null
    /**
     * Filter, which Convocatoria to fetch.
     */
    where?: ConvocatoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Convocatorias to fetch.
     */
    orderBy?: ConvocatoriaOrderByWithRelationInput | ConvocatoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Convocatorias.
     */
    cursor?: ConvocatoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Convocatorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Convocatorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Convocatorias.
     */
    distinct?: ConvocatoriaScalarFieldEnum | ConvocatoriaScalarFieldEnum[]
  }

  /**
   * Convocatoria findFirstOrThrow
   */
  export type ConvocatoriaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Convocatoria
     */
    select?: ConvocatoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Convocatoria
     */
    omit?: ConvocatoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConvocatoriaInclude<ExtArgs> | null
    /**
     * Filter, which Convocatoria to fetch.
     */
    where?: ConvocatoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Convocatorias to fetch.
     */
    orderBy?: ConvocatoriaOrderByWithRelationInput | ConvocatoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Convocatorias.
     */
    cursor?: ConvocatoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Convocatorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Convocatorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Convocatorias.
     */
    distinct?: ConvocatoriaScalarFieldEnum | ConvocatoriaScalarFieldEnum[]
  }

  /**
   * Convocatoria findMany
   */
  export type ConvocatoriaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Convocatoria
     */
    select?: ConvocatoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Convocatoria
     */
    omit?: ConvocatoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConvocatoriaInclude<ExtArgs> | null
    /**
     * Filter, which Convocatorias to fetch.
     */
    where?: ConvocatoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Convocatorias to fetch.
     */
    orderBy?: ConvocatoriaOrderByWithRelationInput | ConvocatoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Convocatorias.
     */
    cursor?: ConvocatoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Convocatorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Convocatorias.
     */
    skip?: number
    distinct?: ConvocatoriaScalarFieldEnum | ConvocatoriaScalarFieldEnum[]
  }

  /**
   * Convocatoria create
   */
  export type ConvocatoriaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Convocatoria
     */
    select?: ConvocatoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Convocatoria
     */
    omit?: ConvocatoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConvocatoriaInclude<ExtArgs> | null
    /**
     * The data needed to create a Convocatoria.
     */
    data: XOR<ConvocatoriaCreateInput, ConvocatoriaUncheckedCreateInput>
  }

  /**
   * Convocatoria createMany
   */
  export type ConvocatoriaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Convocatorias.
     */
    data: ConvocatoriaCreateManyInput | ConvocatoriaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Convocatoria createManyAndReturn
   */
  export type ConvocatoriaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Convocatoria
     */
    select?: ConvocatoriaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Convocatoria
     */
    omit?: ConvocatoriaOmit<ExtArgs> | null
    /**
     * The data used to create many Convocatorias.
     */
    data: ConvocatoriaCreateManyInput | ConvocatoriaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConvocatoriaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Convocatoria update
   */
  export type ConvocatoriaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Convocatoria
     */
    select?: ConvocatoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Convocatoria
     */
    omit?: ConvocatoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConvocatoriaInclude<ExtArgs> | null
    /**
     * The data needed to update a Convocatoria.
     */
    data: XOR<ConvocatoriaUpdateInput, ConvocatoriaUncheckedUpdateInput>
    /**
     * Choose, which Convocatoria to update.
     */
    where: ConvocatoriaWhereUniqueInput
  }

  /**
   * Convocatoria updateMany
   */
  export type ConvocatoriaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Convocatorias.
     */
    data: XOR<ConvocatoriaUpdateManyMutationInput, ConvocatoriaUncheckedUpdateManyInput>
    /**
     * Filter which Convocatorias to update
     */
    where?: ConvocatoriaWhereInput
    /**
     * Limit how many Convocatorias to update.
     */
    limit?: number
  }

  /**
   * Convocatoria updateManyAndReturn
   */
  export type ConvocatoriaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Convocatoria
     */
    select?: ConvocatoriaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Convocatoria
     */
    omit?: ConvocatoriaOmit<ExtArgs> | null
    /**
     * The data used to update Convocatorias.
     */
    data: XOR<ConvocatoriaUpdateManyMutationInput, ConvocatoriaUncheckedUpdateManyInput>
    /**
     * Filter which Convocatorias to update
     */
    where?: ConvocatoriaWhereInput
    /**
     * Limit how many Convocatorias to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConvocatoriaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Convocatoria upsert
   */
  export type ConvocatoriaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Convocatoria
     */
    select?: ConvocatoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Convocatoria
     */
    omit?: ConvocatoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConvocatoriaInclude<ExtArgs> | null
    /**
     * The filter to search for the Convocatoria to update in case it exists.
     */
    where: ConvocatoriaWhereUniqueInput
    /**
     * In case the Convocatoria found by the `where` argument doesn't exist, create a new Convocatoria with this data.
     */
    create: XOR<ConvocatoriaCreateInput, ConvocatoriaUncheckedCreateInput>
    /**
     * In case the Convocatoria was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConvocatoriaUpdateInput, ConvocatoriaUncheckedUpdateInput>
  }

  /**
   * Convocatoria delete
   */
  export type ConvocatoriaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Convocatoria
     */
    select?: ConvocatoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Convocatoria
     */
    omit?: ConvocatoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConvocatoriaInclude<ExtArgs> | null
    /**
     * Filter which Convocatoria to delete.
     */
    where: ConvocatoriaWhereUniqueInput
  }

  /**
   * Convocatoria deleteMany
   */
  export type ConvocatoriaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Convocatorias to delete
     */
    where?: ConvocatoriaWhereInput
    /**
     * Limit how many Convocatorias to delete.
     */
    limit?: number
  }

  /**
   * Convocatoria.Area_convocatoria
   */
  export type Convocatoria$Area_convocatoriaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area_convocatoria
     */
    select?: Area_convocatoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Area_convocatoria
     */
    omit?: Area_convocatoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Area_convocatoriaInclude<ExtArgs> | null
    where?: Area_convocatoriaWhereInput
    orderBy?: Area_convocatoriaOrderByWithRelationInput | Area_convocatoriaOrderByWithRelationInput[]
    cursor?: Area_convocatoriaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Area_convocatoriaScalarFieldEnum | Area_convocatoriaScalarFieldEnum[]
  }

  /**
   * Convocatoria.Inscripcion
   */
  export type Convocatoria$InscripcionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inscripcion
     */
    select?: InscripcionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inscripcion
     */
    omit?: InscripcionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InscripcionInclude<ExtArgs> | null
    where?: InscripcionWhereInput
    orderBy?: InscripcionOrderByWithRelationInput | InscripcionOrderByWithRelationInput[]
    cursor?: InscripcionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InscripcionScalarFieldEnum | InscripcionScalarFieldEnum[]
  }

  /**
   * Convocatoria without action
   */
  export type ConvocatoriaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Convocatoria
     */
    select?: ConvocatoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Convocatoria
     */
    omit?: ConvocatoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConvocatoriaInclude<ExtArgs> | null
  }


  /**
   * Model Area
   */

  export type AggregateArea = {
    _count: AreaCountAggregateOutputType | null
    _avg: AreaAvgAggregateOutputType | null
    _sum: AreaSumAggregateOutputType | null
    _min: AreaMinAggregateOutputType | null
    _max: AreaMaxAggregateOutputType | null
  }

  export type AreaAvgAggregateOutputType = {
    id: number | null
    costo: Decimal | null
  }

  export type AreaSumAggregateOutputType = {
    id: number | null
    costo: Decimal | null
  }

  export type AreaMinAggregateOutputType = {
    id: number | null
    nombre_area: string | null
    descripcion_area: string | null
    costo: Decimal | null
  }

  export type AreaMaxAggregateOutputType = {
    id: number | null
    nombre_area: string | null
    descripcion_area: string | null
    costo: Decimal | null
  }

  export type AreaCountAggregateOutputType = {
    id: number
    nombre_area: number
    descripcion_area: number
    costo: number
    _all: number
  }


  export type AreaAvgAggregateInputType = {
    id?: true
    costo?: true
  }

  export type AreaSumAggregateInputType = {
    id?: true
    costo?: true
  }

  export type AreaMinAggregateInputType = {
    id?: true
    nombre_area?: true
    descripcion_area?: true
    costo?: true
  }

  export type AreaMaxAggregateInputType = {
    id?: true
    nombre_area?: true
    descripcion_area?: true
    costo?: true
  }

  export type AreaCountAggregateInputType = {
    id?: true
    nombre_area?: true
    descripcion_area?: true
    costo?: true
    _all?: true
  }

  export type AreaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Area to aggregate.
     */
    where?: AreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Areas to fetch.
     */
    orderBy?: AreaOrderByWithRelationInput | AreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Areas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Areas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Areas
    **/
    _count?: true | AreaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AreaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AreaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AreaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AreaMaxAggregateInputType
  }

  export type GetAreaAggregateType<T extends AreaAggregateArgs> = {
        [P in keyof T & keyof AggregateArea]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArea[P]>
      : GetScalarType<T[P], AggregateArea[P]>
  }




  export type AreaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AreaWhereInput
    orderBy?: AreaOrderByWithAggregationInput | AreaOrderByWithAggregationInput[]
    by: AreaScalarFieldEnum[] | AreaScalarFieldEnum
    having?: AreaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AreaCountAggregateInputType | true
    _avg?: AreaAvgAggregateInputType
    _sum?: AreaSumAggregateInputType
    _min?: AreaMinAggregateInputType
    _max?: AreaMaxAggregateInputType
  }

  export type AreaGroupByOutputType = {
    id: number
    nombre_area: string
    descripcion_area: string
    costo: Decimal
    _count: AreaCountAggregateOutputType | null
    _avg: AreaAvgAggregateOutputType | null
    _sum: AreaSumAggregateOutputType | null
    _min: AreaMinAggregateOutputType | null
    _max: AreaMaxAggregateOutputType | null
  }

  type GetAreaGroupByPayload<T extends AreaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AreaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AreaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AreaGroupByOutputType[P]>
            : GetScalarType<T[P], AreaGroupByOutputType[P]>
        }
      >
    >


  export type AreaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre_area?: boolean
    descripcion_area?: boolean
    costo?: boolean
    Area_convocatoria?: boolean | Area$Area_convocatoriaArgs<ExtArgs>
    area_categoria?: boolean | Area$area_categoriaArgs<ExtArgs>
    Tutor?: boolean | Area$TutorArgs<ExtArgs>
    Inscripcion?: boolean | Area$InscripcionArgs<ExtArgs>
    _count?: boolean | AreaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["area"]>

  export type AreaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre_area?: boolean
    descripcion_area?: boolean
    costo?: boolean
  }, ExtArgs["result"]["area"]>

  export type AreaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre_area?: boolean
    descripcion_area?: boolean
    costo?: boolean
  }, ExtArgs["result"]["area"]>

  export type AreaSelectScalar = {
    id?: boolean
    nombre_area?: boolean
    descripcion_area?: boolean
    costo?: boolean
  }

  export type AreaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nombre_area" | "descripcion_area" | "costo", ExtArgs["result"]["area"]>
  export type AreaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Area_convocatoria?: boolean | Area$Area_convocatoriaArgs<ExtArgs>
    area_categoria?: boolean | Area$area_categoriaArgs<ExtArgs>
    Tutor?: boolean | Area$TutorArgs<ExtArgs>
    Inscripcion?: boolean | Area$InscripcionArgs<ExtArgs>
    _count?: boolean | AreaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AreaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AreaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AreaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Area"
    objects: {
      Area_convocatoria: Prisma.$Area_convocatoriaPayload<ExtArgs>[]
      area_categoria: Prisma.$Categoria_areaPayload<ExtArgs>[]
      Tutor: Prisma.$TutorPayload<ExtArgs>[]
      Inscripcion: Prisma.$InscripcionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre_area: string
      descripcion_area: string
      costo: Prisma.Decimal
    }, ExtArgs["result"]["area"]>
    composites: {}
  }

  type AreaGetPayload<S extends boolean | null | undefined | AreaDefaultArgs> = $Result.GetResult<Prisma.$AreaPayload, S>

  type AreaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AreaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AreaCountAggregateInputType | true
    }

  export interface AreaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Area'], meta: { name: 'Area' } }
    /**
     * Find zero or one Area that matches the filter.
     * @param {AreaFindUniqueArgs} args - Arguments to find a Area
     * @example
     * // Get one Area
     * const area = await prisma.area.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AreaFindUniqueArgs>(args: SelectSubset<T, AreaFindUniqueArgs<ExtArgs>>): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Area that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AreaFindUniqueOrThrowArgs} args - Arguments to find a Area
     * @example
     * // Get one Area
     * const area = await prisma.area.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AreaFindUniqueOrThrowArgs>(args: SelectSubset<T, AreaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Area that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaFindFirstArgs} args - Arguments to find a Area
     * @example
     * // Get one Area
     * const area = await prisma.area.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AreaFindFirstArgs>(args?: SelectSubset<T, AreaFindFirstArgs<ExtArgs>>): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Area that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaFindFirstOrThrowArgs} args - Arguments to find a Area
     * @example
     * // Get one Area
     * const area = await prisma.area.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AreaFindFirstOrThrowArgs>(args?: SelectSubset<T, AreaFindFirstOrThrowArgs<ExtArgs>>): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Areas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Areas
     * const areas = await prisma.area.findMany()
     * 
     * // Get first 10 Areas
     * const areas = await prisma.area.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const areaWithIdOnly = await prisma.area.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AreaFindManyArgs>(args?: SelectSubset<T, AreaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Area.
     * @param {AreaCreateArgs} args - Arguments to create a Area.
     * @example
     * // Create one Area
     * const Area = await prisma.area.create({
     *   data: {
     *     // ... data to create a Area
     *   }
     * })
     * 
     */
    create<T extends AreaCreateArgs>(args: SelectSubset<T, AreaCreateArgs<ExtArgs>>): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Areas.
     * @param {AreaCreateManyArgs} args - Arguments to create many Areas.
     * @example
     * // Create many Areas
     * const area = await prisma.area.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AreaCreateManyArgs>(args?: SelectSubset<T, AreaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Areas and returns the data saved in the database.
     * @param {AreaCreateManyAndReturnArgs} args - Arguments to create many Areas.
     * @example
     * // Create many Areas
     * const area = await prisma.area.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Areas and only return the `id`
     * const areaWithIdOnly = await prisma.area.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AreaCreateManyAndReturnArgs>(args?: SelectSubset<T, AreaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Area.
     * @param {AreaDeleteArgs} args - Arguments to delete one Area.
     * @example
     * // Delete one Area
     * const Area = await prisma.area.delete({
     *   where: {
     *     // ... filter to delete one Area
     *   }
     * })
     * 
     */
    delete<T extends AreaDeleteArgs>(args: SelectSubset<T, AreaDeleteArgs<ExtArgs>>): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Area.
     * @param {AreaUpdateArgs} args - Arguments to update one Area.
     * @example
     * // Update one Area
     * const area = await prisma.area.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AreaUpdateArgs>(args: SelectSubset<T, AreaUpdateArgs<ExtArgs>>): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Areas.
     * @param {AreaDeleteManyArgs} args - Arguments to filter Areas to delete.
     * @example
     * // Delete a few Areas
     * const { count } = await prisma.area.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AreaDeleteManyArgs>(args?: SelectSubset<T, AreaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Areas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Areas
     * const area = await prisma.area.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AreaUpdateManyArgs>(args: SelectSubset<T, AreaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Areas and returns the data updated in the database.
     * @param {AreaUpdateManyAndReturnArgs} args - Arguments to update many Areas.
     * @example
     * // Update many Areas
     * const area = await prisma.area.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Areas and only return the `id`
     * const areaWithIdOnly = await prisma.area.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AreaUpdateManyAndReturnArgs>(args: SelectSubset<T, AreaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Area.
     * @param {AreaUpsertArgs} args - Arguments to update or create a Area.
     * @example
     * // Update or create a Area
     * const area = await prisma.area.upsert({
     *   create: {
     *     // ... data to create a Area
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Area we want to update
     *   }
     * })
     */
    upsert<T extends AreaUpsertArgs>(args: SelectSubset<T, AreaUpsertArgs<ExtArgs>>): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Areas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaCountArgs} args - Arguments to filter Areas to count.
     * @example
     * // Count the number of Areas
     * const count = await prisma.area.count({
     *   where: {
     *     // ... the filter for the Areas we want to count
     *   }
     * })
    **/
    count<T extends AreaCountArgs>(
      args?: Subset<T, AreaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AreaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Area.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AreaAggregateArgs>(args: Subset<T, AreaAggregateArgs>): Prisma.PrismaPromise<GetAreaAggregateType<T>>

    /**
     * Group by Area.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AreaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AreaGroupByArgs['orderBy'] }
        : { orderBy?: AreaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AreaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAreaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Area model
   */
  readonly fields: AreaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Area.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AreaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Area_convocatoria<T extends Area$Area_convocatoriaArgs<ExtArgs> = {}>(args?: Subset<T, Area$Area_convocatoriaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Area_convocatoriaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    area_categoria<T extends Area$area_categoriaArgs<ExtArgs> = {}>(args?: Subset<T, Area$area_categoriaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Categoria_areaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Tutor<T extends Area$TutorArgs<ExtArgs> = {}>(args?: Subset<T, Area$TutorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TutorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Inscripcion<T extends Area$InscripcionArgs<ExtArgs> = {}>(args?: Subset<T, Area$InscripcionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InscripcionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Area model
   */
  interface AreaFieldRefs {
    readonly id: FieldRef<"Area", 'Int'>
    readonly nombre_area: FieldRef<"Area", 'String'>
    readonly descripcion_area: FieldRef<"Area", 'String'>
    readonly costo: FieldRef<"Area", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * Area findUnique
   */
  export type AreaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Area
     */
    omit?: AreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * Filter, which Area to fetch.
     */
    where: AreaWhereUniqueInput
  }

  /**
   * Area findUniqueOrThrow
   */
  export type AreaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Area
     */
    omit?: AreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * Filter, which Area to fetch.
     */
    where: AreaWhereUniqueInput
  }

  /**
   * Area findFirst
   */
  export type AreaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Area
     */
    omit?: AreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * Filter, which Area to fetch.
     */
    where?: AreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Areas to fetch.
     */
    orderBy?: AreaOrderByWithRelationInput | AreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Areas.
     */
    cursor?: AreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Areas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Areas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Areas.
     */
    distinct?: AreaScalarFieldEnum | AreaScalarFieldEnum[]
  }

  /**
   * Area findFirstOrThrow
   */
  export type AreaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Area
     */
    omit?: AreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * Filter, which Area to fetch.
     */
    where?: AreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Areas to fetch.
     */
    orderBy?: AreaOrderByWithRelationInput | AreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Areas.
     */
    cursor?: AreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Areas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Areas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Areas.
     */
    distinct?: AreaScalarFieldEnum | AreaScalarFieldEnum[]
  }

  /**
   * Area findMany
   */
  export type AreaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Area
     */
    omit?: AreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * Filter, which Areas to fetch.
     */
    where?: AreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Areas to fetch.
     */
    orderBy?: AreaOrderByWithRelationInput | AreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Areas.
     */
    cursor?: AreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Areas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Areas.
     */
    skip?: number
    distinct?: AreaScalarFieldEnum | AreaScalarFieldEnum[]
  }

  /**
   * Area create
   */
  export type AreaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Area
     */
    omit?: AreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * The data needed to create a Area.
     */
    data: XOR<AreaCreateInput, AreaUncheckedCreateInput>
  }

  /**
   * Area createMany
   */
  export type AreaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Areas.
     */
    data: AreaCreateManyInput | AreaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Area createManyAndReturn
   */
  export type AreaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Area
     */
    omit?: AreaOmit<ExtArgs> | null
    /**
     * The data used to create many Areas.
     */
    data: AreaCreateManyInput | AreaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Area update
   */
  export type AreaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Area
     */
    omit?: AreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * The data needed to update a Area.
     */
    data: XOR<AreaUpdateInput, AreaUncheckedUpdateInput>
    /**
     * Choose, which Area to update.
     */
    where: AreaWhereUniqueInput
  }

  /**
   * Area updateMany
   */
  export type AreaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Areas.
     */
    data: XOR<AreaUpdateManyMutationInput, AreaUncheckedUpdateManyInput>
    /**
     * Filter which Areas to update
     */
    where?: AreaWhereInput
    /**
     * Limit how many Areas to update.
     */
    limit?: number
  }

  /**
   * Area updateManyAndReturn
   */
  export type AreaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Area
     */
    omit?: AreaOmit<ExtArgs> | null
    /**
     * The data used to update Areas.
     */
    data: XOR<AreaUpdateManyMutationInput, AreaUncheckedUpdateManyInput>
    /**
     * Filter which Areas to update
     */
    where?: AreaWhereInput
    /**
     * Limit how many Areas to update.
     */
    limit?: number
  }

  /**
   * Area upsert
   */
  export type AreaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Area
     */
    omit?: AreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * The filter to search for the Area to update in case it exists.
     */
    where: AreaWhereUniqueInput
    /**
     * In case the Area found by the `where` argument doesn't exist, create a new Area with this data.
     */
    create: XOR<AreaCreateInput, AreaUncheckedCreateInput>
    /**
     * In case the Area was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AreaUpdateInput, AreaUncheckedUpdateInput>
  }

  /**
   * Area delete
   */
  export type AreaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Area
     */
    omit?: AreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * Filter which Area to delete.
     */
    where: AreaWhereUniqueInput
  }

  /**
   * Area deleteMany
   */
  export type AreaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Areas to delete
     */
    where?: AreaWhereInput
    /**
     * Limit how many Areas to delete.
     */
    limit?: number
  }

  /**
   * Area.Area_convocatoria
   */
  export type Area$Area_convocatoriaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area_convocatoria
     */
    select?: Area_convocatoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Area_convocatoria
     */
    omit?: Area_convocatoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Area_convocatoriaInclude<ExtArgs> | null
    where?: Area_convocatoriaWhereInput
    orderBy?: Area_convocatoriaOrderByWithRelationInput | Area_convocatoriaOrderByWithRelationInput[]
    cursor?: Area_convocatoriaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Area_convocatoriaScalarFieldEnum | Area_convocatoriaScalarFieldEnum[]
  }

  /**
   * Area.area_categoria
   */
  export type Area$area_categoriaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria_area
     */
    select?: Categoria_areaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categoria_area
     */
    omit?: Categoria_areaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Categoria_areaInclude<ExtArgs> | null
    where?: Categoria_areaWhereInput
    orderBy?: Categoria_areaOrderByWithRelationInput | Categoria_areaOrderByWithRelationInput[]
    cursor?: Categoria_areaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Categoria_areaScalarFieldEnum | Categoria_areaScalarFieldEnum[]
  }

  /**
   * Area.Tutor
   */
  export type Area$TutorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tutor
     */
    select?: TutorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tutor
     */
    omit?: TutorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutorInclude<ExtArgs> | null
    where?: TutorWhereInput
    orderBy?: TutorOrderByWithRelationInput | TutorOrderByWithRelationInput[]
    cursor?: TutorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TutorScalarFieldEnum | TutorScalarFieldEnum[]
  }

  /**
   * Area.Inscripcion
   */
  export type Area$InscripcionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inscripcion
     */
    select?: InscripcionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inscripcion
     */
    omit?: InscripcionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InscripcionInclude<ExtArgs> | null
    where?: InscripcionWhereInput
    orderBy?: InscripcionOrderByWithRelationInput | InscripcionOrderByWithRelationInput[]
    cursor?: InscripcionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InscripcionScalarFieldEnum | InscripcionScalarFieldEnum[]
  }

  /**
   * Area without action
   */
  export type AreaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Area
     */
    omit?: AreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
  }


  /**
   * Model Categoria
   */

  export type AggregateCategoria = {
    _count: CategoriaCountAggregateOutputType | null
    _avg: CategoriaAvgAggregateOutputType | null
    _sum: CategoriaSumAggregateOutputType | null
    _min: CategoriaMinAggregateOutputType | null
    _max: CategoriaMaxAggregateOutputType | null
  }

  export type CategoriaAvgAggregateOutputType = {
    id: number | null
    grado_min_id: number | null
    grado_max_id: number | null
  }

  export type CategoriaSumAggregateOutputType = {
    id: number | null
    grado_min_id: number | null
    grado_max_id: number | null
  }

  export type CategoriaMinAggregateOutputType = {
    id: number | null
    nombre_categoria: string | null
    grado_min_id: number | null
    grado_max_id: number | null
    descripcion_cat: string | null
  }

  export type CategoriaMaxAggregateOutputType = {
    id: number | null
    nombre_categoria: string | null
    grado_min_id: number | null
    grado_max_id: number | null
    descripcion_cat: string | null
  }

  export type CategoriaCountAggregateOutputType = {
    id: number
    nombre_categoria: number
    grado_min_id: number
    grado_max_id: number
    descripcion_cat: number
    _all: number
  }


  export type CategoriaAvgAggregateInputType = {
    id?: true
    grado_min_id?: true
    grado_max_id?: true
  }

  export type CategoriaSumAggregateInputType = {
    id?: true
    grado_min_id?: true
    grado_max_id?: true
  }

  export type CategoriaMinAggregateInputType = {
    id?: true
    nombre_categoria?: true
    grado_min_id?: true
    grado_max_id?: true
    descripcion_cat?: true
  }

  export type CategoriaMaxAggregateInputType = {
    id?: true
    nombre_categoria?: true
    grado_min_id?: true
    grado_max_id?: true
    descripcion_cat?: true
  }

  export type CategoriaCountAggregateInputType = {
    id?: true
    nombre_categoria?: true
    grado_min_id?: true
    grado_max_id?: true
    descripcion_cat?: true
    _all?: true
  }

  export type CategoriaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categoria to aggregate.
     */
    where?: CategoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categorias to fetch.
     */
    orderBy?: CategoriaOrderByWithRelationInput | CategoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categorias
    **/
    _count?: true | CategoriaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoriaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategoriaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoriaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoriaMaxAggregateInputType
  }

  export type GetCategoriaAggregateType<T extends CategoriaAggregateArgs> = {
        [P in keyof T & keyof AggregateCategoria]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategoria[P]>
      : GetScalarType<T[P], AggregateCategoria[P]>
  }




  export type CategoriaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoriaWhereInput
    orderBy?: CategoriaOrderByWithAggregationInput | CategoriaOrderByWithAggregationInput[]
    by: CategoriaScalarFieldEnum[] | CategoriaScalarFieldEnum
    having?: CategoriaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoriaCountAggregateInputType | true
    _avg?: CategoriaAvgAggregateInputType
    _sum?: CategoriaSumAggregateInputType
    _min?: CategoriaMinAggregateInputType
    _max?: CategoriaMaxAggregateInputType
  }

  export type CategoriaGroupByOutputType = {
    id: number
    nombre_categoria: string
    grado_min_id: number
    grado_max_id: number
    descripcion_cat: string
    _count: CategoriaCountAggregateOutputType | null
    _avg: CategoriaAvgAggregateOutputType | null
    _sum: CategoriaSumAggregateOutputType | null
    _min: CategoriaMinAggregateOutputType | null
    _max: CategoriaMaxAggregateOutputType | null
  }

  type GetCategoriaGroupByPayload<T extends CategoriaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoriaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoriaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoriaGroupByOutputType[P]>
            : GetScalarType<T[P], CategoriaGroupByOutputType[P]>
        }
      >
    >


  export type CategoriaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre_categoria?: boolean
    grado_min_id?: boolean
    grado_max_id?: boolean
    descripcion_cat?: boolean
    grado_max?: boolean | GradoDefaultArgs<ExtArgs>
    grado_min?: boolean | GradoDefaultArgs<ExtArgs>
    Categoria_convocatoria?: boolean | Categoria$Categoria_convocatoriaArgs<ExtArgs>
    Inscripcion?: boolean | Categoria$InscripcionArgs<ExtArgs>
    _count?: boolean | CategoriaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["categoria"]>

  export type CategoriaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre_categoria?: boolean
    grado_min_id?: boolean
    grado_max_id?: boolean
    descripcion_cat?: boolean
    grado_max?: boolean | GradoDefaultArgs<ExtArgs>
    grado_min?: boolean | GradoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["categoria"]>

  export type CategoriaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre_categoria?: boolean
    grado_min_id?: boolean
    grado_max_id?: boolean
    descripcion_cat?: boolean
    grado_max?: boolean | GradoDefaultArgs<ExtArgs>
    grado_min?: boolean | GradoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["categoria"]>

  export type CategoriaSelectScalar = {
    id?: boolean
    nombre_categoria?: boolean
    grado_min_id?: boolean
    grado_max_id?: boolean
    descripcion_cat?: boolean
  }

  export type CategoriaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nombre_categoria" | "grado_min_id" | "grado_max_id" | "descripcion_cat", ExtArgs["result"]["categoria"]>
  export type CategoriaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    grado_max?: boolean | GradoDefaultArgs<ExtArgs>
    grado_min?: boolean | GradoDefaultArgs<ExtArgs>
    Categoria_convocatoria?: boolean | Categoria$Categoria_convocatoriaArgs<ExtArgs>
    Inscripcion?: boolean | Categoria$InscripcionArgs<ExtArgs>
    _count?: boolean | CategoriaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CategoriaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    grado_max?: boolean | GradoDefaultArgs<ExtArgs>
    grado_min?: boolean | GradoDefaultArgs<ExtArgs>
  }
  export type CategoriaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    grado_max?: boolean | GradoDefaultArgs<ExtArgs>
    grado_min?: boolean | GradoDefaultArgs<ExtArgs>
  }

  export type $CategoriaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Categoria"
    objects: {
      grado_max: Prisma.$GradoPayload<ExtArgs>
      grado_min: Prisma.$GradoPayload<ExtArgs>
      Categoria_convocatoria: Prisma.$Categoria_areaPayload<ExtArgs>[]
      Inscripcion: Prisma.$InscripcionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre_categoria: string
      grado_min_id: number
      grado_max_id: number
      descripcion_cat: string
    }, ExtArgs["result"]["categoria"]>
    composites: {}
  }

  type CategoriaGetPayload<S extends boolean | null | undefined | CategoriaDefaultArgs> = $Result.GetResult<Prisma.$CategoriaPayload, S>

  type CategoriaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CategoriaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoriaCountAggregateInputType | true
    }

  export interface CategoriaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Categoria'], meta: { name: 'Categoria' } }
    /**
     * Find zero or one Categoria that matches the filter.
     * @param {CategoriaFindUniqueArgs} args - Arguments to find a Categoria
     * @example
     * // Get one Categoria
     * const categoria = await prisma.categoria.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoriaFindUniqueArgs>(args: SelectSubset<T, CategoriaFindUniqueArgs<ExtArgs>>): Prisma__CategoriaClient<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Categoria that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoriaFindUniqueOrThrowArgs} args - Arguments to find a Categoria
     * @example
     * // Get one Categoria
     * const categoria = await prisma.categoria.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoriaFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoriaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoriaClient<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Categoria that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaFindFirstArgs} args - Arguments to find a Categoria
     * @example
     * // Get one Categoria
     * const categoria = await prisma.categoria.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoriaFindFirstArgs>(args?: SelectSubset<T, CategoriaFindFirstArgs<ExtArgs>>): Prisma__CategoriaClient<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Categoria that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaFindFirstOrThrowArgs} args - Arguments to find a Categoria
     * @example
     * // Get one Categoria
     * const categoria = await prisma.categoria.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoriaFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoriaFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoriaClient<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categorias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categorias
     * const categorias = await prisma.categoria.findMany()
     * 
     * // Get first 10 Categorias
     * const categorias = await prisma.categoria.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoriaWithIdOnly = await prisma.categoria.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoriaFindManyArgs>(args?: SelectSubset<T, CategoriaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Categoria.
     * @param {CategoriaCreateArgs} args - Arguments to create a Categoria.
     * @example
     * // Create one Categoria
     * const Categoria = await prisma.categoria.create({
     *   data: {
     *     // ... data to create a Categoria
     *   }
     * })
     * 
     */
    create<T extends CategoriaCreateArgs>(args: SelectSubset<T, CategoriaCreateArgs<ExtArgs>>): Prisma__CategoriaClient<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categorias.
     * @param {CategoriaCreateManyArgs} args - Arguments to create many Categorias.
     * @example
     * // Create many Categorias
     * const categoria = await prisma.categoria.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoriaCreateManyArgs>(args?: SelectSubset<T, CategoriaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categorias and returns the data saved in the database.
     * @param {CategoriaCreateManyAndReturnArgs} args - Arguments to create many Categorias.
     * @example
     * // Create many Categorias
     * const categoria = await prisma.categoria.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categorias and only return the `id`
     * const categoriaWithIdOnly = await prisma.categoria.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoriaCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoriaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Categoria.
     * @param {CategoriaDeleteArgs} args - Arguments to delete one Categoria.
     * @example
     * // Delete one Categoria
     * const Categoria = await prisma.categoria.delete({
     *   where: {
     *     // ... filter to delete one Categoria
     *   }
     * })
     * 
     */
    delete<T extends CategoriaDeleteArgs>(args: SelectSubset<T, CategoriaDeleteArgs<ExtArgs>>): Prisma__CategoriaClient<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Categoria.
     * @param {CategoriaUpdateArgs} args - Arguments to update one Categoria.
     * @example
     * // Update one Categoria
     * const categoria = await prisma.categoria.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoriaUpdateArgs>(args: SelectSubset<T, CategoriaUpdateArgs<ExtArgs>>): Prisma__CategoriaClient<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categorias.
     * @param {CategoriaDeleteManyArgs} args - Arguments to filter Categorias to delete.
     * @example
     * // Delete a few Categorias
     * const { count } = await prisma.categoria.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoriaDeleteManyArgs>(args?: SelectSubset<T, CategoriaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categorias
     * const categoria = await prisma.categoria.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoriaUpdateManyArgs>(args: SelectSubset<T, CategoriaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categorias and returns the data updated in the database.
     * @param {CategoriaUpdateManyAndReturnArgs} args - Arguments to update many Categorias.
     * @example
     * // Update many Categorias
     * const categoria = await prisma.categoria.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Categorias and only return the `id`
     * const categoriaWithIdOnly = await prisma.categoria.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CategoriaUpdateManyAndReturnArgs>(args: SelectSubset<T, CategoriaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Categoria.
     * @param {CategoriaUpsertArgs} args - Arguments to update or create a Categoria.
     * @example
     * // Update or create a Categoria
     * const categoria = await prisma.categoria.upsert({
     *   create: {
     *     // ... data to create a Categoria
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Categoria we want to update
     *   }
     * })
     */
    upsert<T extends CategoriaUpsertArgs>(args: SelectSubset<T, CategoriaUpsertArgs<ExtArgs>>): Prisma__CategoriaClient<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaCountArgs} args - Arguments to filter Categorias to count.
     * @example
     * // Count the number of Categorias
     * const count = await prisma.categoria.count({
     *   where: {
     *     // ... the filter for the Categorias we want to count
     *   }
     * })
    **/
    count<T extends CategoriaCountArgs>(
      args?: Subset<T, CategoriaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoriaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Categoria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoriaAggregateArgs>(args: Subset<T, CategoriaAggregateArgs>): Prisma.PrismaPromise<GetCategoriaAggregateType<T>>

    /**
     * Group by Categoria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoriaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoriaGroupByArgs['orderBy'] }
        : { orderBy?: CategoriaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoriaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoriaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Categoria model
   */
  readonly fields: CategoriaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Categoria.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoriaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    grado_max<T extends GradoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GradoDefaultArgs<ExtArgs>>): Prisma__GradoClient<$Result.GetResult<Prisma.$GradoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    grado_min<T extends GradoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GradoDefaultArgs<ExtArgs>>): Prisma__GradoClient<$Result.GetResult<Prisma.$GradoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Categoria_convocatoria<T extends Categoria$Categoria_convocatoriaArgs<ExtArgs> = {}>(args?: Subset<T, Categoria$Categoria_convocatoriaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Categoria_areaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Inscripcion<T extends Categoria$InscripcionArgs<ExtArgs> = {}>(args?: Subset<T, Categoria$InscripcionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InscripcionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Categoria model
   */
  interface CategoriaFieldRefs {
    readonly id: FieldRef<"Categoria", 'Int'>
    readonly nombre_categoria: FieldRef<"Categoria", 'String'>
    readonly grado_min_id: FieldRef<"Categoria", 'Int'>
    readonly grado_max_id: FieldRef<"Categoria", 'Int'>
    readonly descripcion_cat: FieldRef<"Categoria", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Categoria findUnique
   */
  export type CategoriaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categoria
     */
    omit?: CategoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaInclude<ExtArgs> | null
    /**
     * Filter, which Categoria to fetch.
     */
    where: CategoriaWhereUniqueInput
  }

  /**
   * Categoria findUniqueOrThrow
   */
  export type CategoriaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categoria
     */
    omit?: CategoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaInclude<ExtArgs> | null
    /**
     * Filter, which Categoria to fetch.
     */
    where: CategoriaWhereUniqueInput
  }

  /**
   * Categoria findFirst
   */
  export type CategoriaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categoria
     */
    omit?: CategoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaInclude<ExtArgs> | null
    /**
     * Filter, which Categoria to fetch.
     */
    where?: CategoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categorias to fetch.
     */
    orderBy?: CategoriaOrderByWithRelationInput | CategoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categorias.
     */
    cursor?: CategoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categorias.
     */
    distinct?: CategoriaScalarFieldEnum | CategoriaScalarFieldEnum[]
  }

  /**
   * Categoria findFirstOrThrow
   */
  export type CategoriaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categoria
     */
    omit?: CategoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaInclude<ExtArgs> | null
    /**
     * Filter, which Categoria to fetch.
     */
    where?: CategoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categorias to fetch.
     */
    orderBy?: CategoriaOrderByWithRelationInput | CategoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categorias.
     */
    cursor?: CategoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categorias.
     */
    distinct?: CategoriaScalarFieldEnum | CategoriaScalarFieldEnum[]
  }

  /**
   * Categoria findMany
   */
  export type CategoriaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categoria
     */
    omit?: CategoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaInclude<ExtArgs> | null
    /**
     * Filter, which Categorias to fetch.
     */
    where?: CategoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categorias to fetch.
     */
    orderBy?: CategoriaOrderByWithRelationInput | CategoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categorias.
     */
    cursor?: CategoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categorias.
     */
    skip?: number
    distinct?: CategoriaScalarFieldEnum | CategoriaScalarFieldEnum[]
  }

  /**
   * Categoria create
   */
  export type CategoriaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categoria
     */
    omit?: CategoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaInclude<ExtArgs> | null
    /**
     * The data needed to create a Categoria.
     */
    data: XOR<CategoriaCreateInput, CategoriaUncheckedCreateInput>
  }

  /**
   * Categoria createMany
   */
  export type CategoriaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categorias.
     */
    data: CategoriaCreateManyInput | CategoriaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Categoria createManyAndReturn
   */
  export type CategoriaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Categoria
     */
    omit?: CategoriaOmit<ExtArgs> | null
    /**
     * The data used to create many Categorias.
     */
    data: CategoriaCreateManyInput | CategoriaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Categoria update
   */
  export type CategoriaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categoria
     */
    omit?: CategoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaInclude<ExtArgs> | null
    /**
     * The data needed to update a Categoria.
     */
    data: XOR<CategoriaUpdateInput, CategoriaUncheckedUpdateInput>
    /**
     * Choose, which Categoria to update.
     */
    where: CategoriaWhereUniqueInput
  }

  /**
   * Categoria updateMany
   */
  export type CategoriaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categorias.
     */
    data: XOR<CategoriaUpdateManyMutationInput, CategoriaUncheckedUpdateManyInput>
    /**
     * Filter which Categorias to update
     */
    where?: CategoriaWhereInput
    /**
     * Limit how many Categorias to update.
     */
    limit?: number
  }

  /**
   * Categoria updateManyAndReturn
   */
  export type CategoriaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Categoria
     */
    omit?: CategoriaOmit<ExtArgs> | null
    /**
     * The data used to update Categorias.
     */
    data: XOR<CategoriaUpdateManyMutationInput, CategoriaUncheckedUpdateManyInput>
    /**
     * Filter which Categorias to update
     */
    where?: CategoriaWhereInput
    /**
     * Limit how many Categorias to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Categoria upsert
   */
  export type CategoriaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categoria
     */
    omit?: CategoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaInclude<ExtArgs> | null
    /**
     * The filter to search for the Categoria to update in case it exists.
     */
    where: CategoriaWhereUniqueInput
    /**
     * In case the Categoria found by the `where` argument doesn't exist, create a new Categoria with this data.
     */
    create: XOR<CategoriaCreateInput, CategoriaUncheckedCreateInput>
    /**
     * In case the Categoria was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoriaUpdateInput, CategoriaUncheckedUpdateInput>
  }

  /**
   * Categoria delete
   */
  export type CategoriaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categoria
     */
    omit?: CategoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaInclude<ExtArgs> | null
    /**
     * Filter which Categoria to delete.
     */
    where: CategoriaWhereUniqueInput
  }

  /**
   * Categoria deleteMany
   */
  export type CategoriaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categorias to delete
     */
    where?: CategoriaWhereInput
    /**
     * Limit how many Categorias to delete.
     */
    limit?: number
  }

  /**
   * Categoria.Categoria_convocatoria
   */
  export type Categoria$Categoria_convocatoriaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria_area
     */
    select?: Categoria_areaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categoria_area
     */
    omit?: Categoria_areaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Categoria_areaInclude<ExtArgs> | null
    where?: Categoria_areaWhereInput
    orderBy?: Categoria_areaOrderByWithRelationInput | Categoria_areaOrderByWithRelationInput[]
    cursor?: Categoria_areaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Categoria_areaScalarFieldEnum | Categoria_areaScalarFieldEnum[]
  }

  /**
   * Categoria.Inscripcion
   */
  export type Categoria$InscripcionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inscripcion
     */
    select?: InscripcionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inscripcion
     */
    omit?: InscripcionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InscripcionInclude<ExtArgs> | null
    where?: InscripcionWhereInput
    orderBy?: InscripcionOrderByWithRelationInput | InscripcionOrderByWithRelationInput[]
    cursor?: InscripcionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InscripcionScalarFieldEnum | InscripcionScalarFieldEnum[]
  }

  /**
   * Categoria without action
   */
  export type CategoriaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categoria
     */
    omit?: CategoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaInclude<ExtArgs> | null
  }


  /**
   * Model Grado
   */

  export type AggregateGrado = {
    _count: GradoCountAggregateOutputType | null
    _avg: GradoAvgAggregateOutputType | null
    _sum: GradoSumAggregateOutputType | null
    _min: GradoMinAggregateOutputType | null
    _max: GradoMaxAggregateOutputType | null
  }

  export type GradoAvgAggregateOutputType = {
    id: number | null
    id_nivel: number | null
  }

  export type GradoSumAggregateOutputType = {
    id: number | null
    id_nivel: number | null
  }

  export type GradoMinAggregateOutputType = {
    id: number | null
    nombre_grado: string | null
    id_nivel: number | null
  }

  export type GradoMaxAggregateOutputType = {
    id: number | null
    nombre_grado: string | null
    id_nivel: number | null
  }

  export type GradoCountAggregateOutputType = {
    id: number
    nombre_grado: number
    id_nivel: number
    _all: number
  }


  export type GradoAvgAggregateInputType = {
    id?: true
    id_nivel?: true
  }

  export type GradoSumAggregateInputType = {
    id?: true
    id_nivel?: true
  }

  export type GradoMinAggregateInputType = {
    id?: true
    nombre_grado?: true
    id_nivel?: true
  }

  export type GradoMaxAggregateInputType = {
    id?: true
    nombre_grado?: true
    id_nivel?: true
  }

  export type GradoCountAggregateInputType = {
    id?: true
    nombre_grado?: true
    id_nivel?: true
    _all?: true
  }

  export type GradoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Grado to aggregate.
     */
    where?: GradoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grados to fetch.
     */
    orderBy?: GradoOrderByWithRelationInput | GradoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GradoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Grados
    **/
    _count?: true | GradoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GradoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GradoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GradoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GradoMaxAggregateInputType
  }

  export type GetGradoAggregateType<T extends GradoAggregateArgs> = {
        [P in keyof T & keyof AggregateGrado]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGrado[P]>
      : GetScalarType<T[P], AggregateGrado[P]>
  }




  export type GradoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GradoWhereInput
    orderBy?: GradoOrderByWithAggregationInput | GradoOrderByWithAggregationInput[]
    by: GradoScalarFieldEnum[] | GradoScalarFieldEnum
    having?: GradoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GradoCountAggregateInputType | true
    _avg?: GradoAvgAggregateInputType
    _sum?: GradoSumAggregateInputType
    _min?: GradoMinAggregateInputType
    _max?: GradoMaxAggregateInputType
  }

  export type GradoGroupByOutputType = {
    id: number
    nombre_grado: string
    id_nivel: number
    _count: GradoCountAggregateOutputType | null
    _avg: GradoAvgAggregateOutputType | null
    _sum: GradoSumAggregateOutputType | null
    _min: GradoMinAggregateOutputType | null
    _max: GradoMaxAggregateOutputType | null
  }

  type GetGradoGroupByPayload<T extends GradoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GradoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GradoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GradoGroupByOutputType[P]>
            : GetScalarType<T[P], GradoGroupByOutputType[P]>
        }
      >
    >


  export type GradoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre_grado?: boolean
    id_nivel?: boolean
    categorias_max?: boolean | Grado$categorias_maxArgs<ExtArgs>
    categorias_min?: boolean | Grado$categorias_minArgs<ExtArgs>
    nivel?: boolean | NivelDefaultArgs<ExtArgs>
    _count?: boolean | GradoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["grado"]>

  export type GradoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre_grado?: boolean
    id_nivel?: boolean
    nivel?: boolean | NivelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["grado"]>

  export type GradoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre_grado?: boolean
    id_nivel?: boolean
    nivel?: boolean | NivelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["grado"]>

  export type GradoSelectScalar = {
    id?: boolean
    nombre_grado?: boolean
    id_nivel?: boolean
  }

  export type GradoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nombre_grado" | "id_nivel", ExtArgs["result"]["grado"]>
  export type GradoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categorias_max?: boolean | Grado$categorias_maxArgs<ExtArgs>
    categorias_min?: boolean | Grado$categorias_minArgs<ExtArgs>
    nivel?: boolean | NivelDefaultArgs<ExtArgs>
    _count?: boolean | GradoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GradoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nivel?: boolean | NivelDefaultArgs<ExtArgs>
  }
  export type GradoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nivel?: boolean | NivelDefaultArgs<ExtArgs>
  }

  export type $GradoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Grado"
    objects: {
      categorias_max: Prisma.$CategoriaPayload<ExtArgs>[]
      categorias_min: Prisma.$CategoriaPayload<ExtArgs>[]
      nivel: Prisma.$NivelPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre_grado: string
      id_nivel: number
    }, ExtArgs["result"]["grado"]>
    composites: {}
  }

  type GradoGetPayload<S extends boolean | null | undefined | GradoDefaultArgs> = $Result.GetResult<Prisma.$GradoPayload, S>

  type GradoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GradoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GradoCountAggregateInputType | true
    }

  export interface GradoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Grado'], meta: { name: 'Grado' } }
    /**
     * Find zero or one Grado that matches the filter.
     * @param {GradoFindUniqueArgs} args - Arguments to find a Grado
     * @example
     * // Get one Grado
     * const grado = await prisma.grado.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GradoFindUniqueArgs>(args: SelectSubset<T, GradoFindUniqueArgs<ExtArgs>>): Prisma__GradoClient<$Result.GetResult<Prisma.$GradoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Grado that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GradoFindUniqueOrThrowArgs} args - Arguments to find a Grado
     * @example
     * // Get one Grado
     * const grado = await prisma.grado.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GradoFindUniqueOrThrowArgs>(args: SelectSubset<T, GradoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GradoClient<$Result.GetResult<Prisma.$GradoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Grado that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradoFindFirstArgs} args - Arguments to find a Grado
     * @example
     * // Get one Grado
     * const grado = await prisma.grado.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GradoFindFirstArgs>(args?: SelectSubset<T, GradoFindFirstArgs<ExtArgs>>): Prisma__GradoClient<$Result.GetResult<Prisma.$GradoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Grado that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradoFindFirstOrThrowArgs} args - Arguments to find a Grado
     * @example
     * // Get one Grado
     * const grado = await prisma.grado.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GradoFindFirstOrThrowArgs>(args?: SelectSubset<T, GradoFindFirstOrThrowArgs<ExtArgs>>): Prisma__GradoClient<$Result.GetResult<Prisma.$GradoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Grados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Grados
     * const grados = await prisma.grado.findMany()
     * 
     * // Get first 10 Grados
     * const grados = await prisma.grado.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gradoWithIdOnly = await prisma.grado.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GradoFindManyArgs>(args?: SelectSubset<T, GradoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Grado.
     * @param {GradoCreateArgs} args - Arguments to create a Grado.
     * @example
     * // Create one Grado
     * const Grado = await prisma.grado.create({
     *   data: {
     *     // ... data to create a Grado
     *   }
     * })
     * 
     */
    create<T extends GradoCreateArgs>(args: SelectSubset<T, GradoCreateArgs<ExtArgs>>): Prisma__GradoClient<$Result.GetResult<Prisma.$GradoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Grados.
     * @param {GradoCreateManyArgs} args - Arguments to create many Grados.
     * @example
     * // Create many Grados
     * const grado = await prisma.grado.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GradoCreateManyArgs>(args?: SelectSubset<T, GradoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Grados and returns the data saved in the database.
     * @param {GradoCreateManyAndReturnArgs} args - Arguments to create many Grados.
     * @example
     * // Create many Grados
     * const grado = await prisma.grado.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Grados and only return the `id`
     * const gradoWithIdOnly = await prisma.grado.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GradoCreateManyAndReturnArgs>(args?: SelectSubset<T, GradoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Grado.
     * @param {GradoDeleteArgs} args - Arguments to delete one Grado.
     * @example
     * // Delete one Grado
     * const Grado = await prisma.grado.delete({
     *   where: {
     *     // ... filter to delete one Grado
     *   }
     * })
     * 
     */
    delete<T extends GradoDeleteArgs>(args: SelectSubset<T, GradoDeleteArgs<ExtArgs>>): Prisma__GradoClient<$Result.GetResult<Prisma.$GradoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Grado.
     * @param {GradoUpdateArgs} args - Arguments to update one Grado.
     * @example
     * // Update one Grado
     * const grado = await prisma.grado.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GradoUpdateArgs>(args: SelectSubset<T, GradoUpdateArgs<ExtArgs>>): Prisma__GradoClient<$Result.GetResult<Prisma.$GradoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Grados.
     * @param {GradoDeleteManyArgs} args - Arguments to filter Grados to delete.
     * @example
     * // Delete a few Grados
     * const { count } = await prisma.grado.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GradoDeleteManyArgs>(args?: SelectSubset<T, GradoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Grados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Grados
     * const grado = await prisma.grado.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GradoUpdateManyArgs>(args: SelectSubset<T, GradoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Grados and returns the data updated in the database.
     * @param {GradoUpdateManyAndReturnArgs} args - Arguments to update many Grados.
     * @example
     * // Update many Grados
     * const grado = await prisma.grado.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Grados and only return the `id`
     * const gradoWithIdOnly = await prisma.grado.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GradoUpdateManyAndReturnArgs>(args: SelectSubset<T, GradoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Grado.
     * @param {GradoUpsertArgs} args - Arguments to update or create a Grado.
     * @example
     * // Update or create a Grado
     * const grado = await prisma.grado.upsert({
     *   create: {
     *     // ... data to create a Grado
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Grado we want to update
     *   }
     * })
     */
    upsert<T extends GradoUpsertArgs>(args: SelectSubset<T, GradoUpsertArgs<ExtArgs>>): Prisma__GradoClient<$Result.GetResult<Prisma.$GradoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Grados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradoCountArgs} args - Arguments to filter Grados to count.
     * @example
     * // Count the number of Grados
     * const count = await prisma.grado.count({
     *   where: {
     *     // ... the filter for the Grados we want to count
     *   }
     * })
    **/
    count<T extends GradoCountArgs>(
      args?: Subset<T, GradoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GradoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Grado.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GradoAggregateArgs>(args: Subset<T, GradoAggregateArgs>): Prisma.PrismaPromise<GetGradoAggregateType<T>>

    /**
     * Group by Grado.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GradoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GradoGroupByArgs['orderBy'] }
        : { orderBy?: GradoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GradoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGradoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Grado model
   */
  readonly fields: GradoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Grado.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GradoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    categorias_max<T extends Grado$categorias_maxArgs<ExtArgs> = {}>(args?: Subset<T, Grado$categorias_maxArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    categorias_min<T extends Grado$categorias_minArgs<ExtArgs> = {}>(args?: Subset<T, Grado$categorias_minArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    nivel<T extends NivelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NivelDefaultArgs<ExtArgs>>): Prisma__NivelClient<$Result.GetResult<Prisma.$NivelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Grado model
   */
  interface GradoFieldRefs {
    readonly id: FieldRef<"Grado", 'Int'>
    readonly nombre_grado: FieldRef<"Grado", 'String'>
    readonly id_nivel: FieldRef<"Grado", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Grado findUnique
   */
  export type GradoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grado
     */
    select?: GradoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grado
     */
    omit?: GradoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradoInclude<ExtArgs> | null
    /**
     * Filter, which Grado to fetch.
     */
    where: GradoWhereUniqueInput
  }

  /**
   * Grado findUniqueOrThrow
   */
  export type GradoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grado
     */
    select?: GradoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grado
     */
    omit?: GradoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradoInclude<ExtArgs> | null
    /**
     * Filter, which Grado to fetch.
     */
    where: GradoWhereUniqueInput
  }

  /**
   * Grado findFirst
   */
  export type GradoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grado
     */
    select?: GradoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grado
     */
    omit?: GradoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradoInclude<ExtArgs> | null
    /**
     * Filter, which Grado to fetch.
     */
    where?: GradoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grados to fetch.
     */
    orderBy?: GradoOrderByWithRelationInput | GradoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Grados.
     */
    cursor?: GradoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Grados.
     */
    distinct?: GradoScalarFieldEnum | GradoScalarFieldEnum[]
  }

  /**
   * Grado findFirstOrThrow
   */
  export type GradoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grado
     */
    select?: GradoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grado
     */
    omit?: GradoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradoInclude<ExtArgs> | null
    /**
     * Filter, which Grado to fetch.
     */
    where?: GradoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grados to fetch.
     */
    orderBy?: GradoOrderByWithRelationInput | GradoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Grados.
     */
    cursor?: GradoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Grados.
     */
    distinct?: GradoScalarFieldEnum | GradoScalarFieldEnum[]
  }

  /**
   * Grado findMany
   */
  export type GradoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grado
     */
    select?: GradoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grado
     */
    omit?: GradoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradoInclude<ExtArgs> | null
    /**
     * Filter, which Grados to fetch.
     */
    where?: GradoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grados to fetch.
     */
    orderBy?: GradoOrderByWithRelationInput | GradoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Grados.
     */
    cursor?: GradoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grados.
     */
    skip?: number
    distinct?: GradoScalarFieldEnum | GradoScalarFieldEnum[]
  }

  /**
   * Grado create
   */
  export type GradoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grado
     */
    select?: GradoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grado
     */
    omit?: GradoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradoInclude<ExtArgs> | null
    /**
     * The data needed to create a Grado.
     */
    data: XOR<GradoCreateInput, GradoUncheckedCreateInput>
  }

  /**
   * Grado createMany
   */
  export type GradoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Grados.
     */
    data: GradoCreateManyInput | GradoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Grado createManyAndReturn
   */
  export type GradoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grado
     */
    select?: GradoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Grado
     */
    omit?: GradoOmit<ExtArgs> | null
    /**
     * The data used to create many Grados.
     */
    data: GradoCreateManyInput | GradoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Grado update
   */
  export type GradoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grado
     */
    select?: GradoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grado
     */
    omit?: GradoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradoInclude<ExtArgs> | null
    /**
     * The data needed to update a Grado.
     */
    data: XOR<GradoUpdateInput, GradoUncheckedUpdateInput>
    /**
     * Choose, which Grado to update.
     */
    where: GradoWhereUniqueInput
  }

  /**
   * Grado updateMany
   */
  export type GradoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Grados.
     */
    data: XOR<GradoUpdateManyMutationInput, GradoUncheckedUpdateManyInput>
    /**
     * Filter which Grados to update
     */
    where?: GradoWhereInput
    /**
     * Limit how many Grados to update.
     */
    limit?: number
  }

  /**
   * Grado updateManyAndReturn
   */
  export type GradoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grado
     */
    select?: GradoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Grado
     */
    omit?: GradoOmit<ExtArgs> | null
    /**
     * The data used to update Grados.
     */
    data: XOR<GradoUpdateManyMutationInput, GradoUncheckedUpdateManyInput>
    /**
     * Filter which Grados to update
     */
    where?: GradoWhereInput
    /**
     * Limit how many Grados to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Grado upsert
   */
  export type GradoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grado
     */
    select?: GradoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grado
     */
    omit?: GradoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradoInclude<ExtArgs> | null
    /**
     * The filter to search for the Grado to update in case it exists.
     */
    where: GradoWhereUniqueInput
    /**
     * In case the Grado found by the `where` argument doesn't exist, create a new Grado with this data.
     */
    create: XOR<GradoCreateInput, GradoUncheckedCreateInput>
    /**
     * In case the Grado was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GradoUpdateInput, GradoUncheckedUpdateInput>
  }

  /**
   * Grado delete
   */
  export type GradoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grado
     */
    select?: GradoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grado
     */
    omit?: GradoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradoInclude<ExtArgs> | null
    /**
     * Filter which Grado to delete.
     */
    where: GradoWhereUniqueInput
  }

  /**
   * Grado deleteMany
   */
  export type GradoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Grados to delete
     */
    where?: GradoWhereInput
    /**
     * Limit how many Grados to delete.
     */
    limit?: number
  }

  /**
   * Grado.categorias_max
   */
  export type Grado$categorias_maxArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categoria
     */
    omit?: CategoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaInclude<ExtArgs> | null
    where?: CategoriaWhereInput
    orderBy?: CategoriaOrderByWithRelationInput | CategoriaOrderByWithRelationInput[]
    cursor?: CategoriaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoriaScalarFieldEnum | CategoriaScalarFieldEnum[]
  }

  /**
   * Grado.categorias_min
   */
  export type Grado$categorias_minArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categoria
     */
    omit?: CategoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaInclude<ExtArgs> | null
    where?: CategoriaWhereInput
    orderBy?: CategoriaOrderByWithRelationInput | CategoriaOrderByWithRelationInput[]
    cursor?: CategoriaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoriaScalarFieldEnum | CategoriaScalarFieldEnum[]
  }

  /**
   * Grado without action
   */
  export type GradoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grado
     */
    select?: GradoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grado
     */
    omit?: GradoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradoInclude<ExtArgs> | null
  }


  /**
   * Model Pago
   */

  export type AggregatePago = {
    _count: PagoCountAggregateOutputType | null
    _avg: PagoAvgAggregateOutputType | null
    _sum: PagoSumAggregateOutputType | null
    _min: PagoMinAggregateOutputType | null
    _max: PagoMaxAggregateOutputType | null
  }

  export type PagoAvgAggregateOutputType = {
    id: number | null
    inscripcion_id: number | null
    monto: Decimal | null
    metodo_pago_id: number | null
  }

  export type PagoSumAggregateOutputType = {
    id: number | null
    inscripcion_id: number | null
    monto: Decimal | null
    metodo_pago_id: number | null
  }

  export type PagoMinAggregateOutputType = {
    id: number | null
    inscripcion_id: number | null
    monto: Decimal | null
    estado: string | null
    codigo_pago: string | null
    fecha_pago: Date | null
    metodo_pago_id: number | null
  }

  export type PagoMaxAggregateOutputType = {
    id: number | null
    inscripcion_id: number | null
    monto: Decimal | null
    estado: string | null
    codigo_pago: string | null
    fecha_pago: Date | null
    metodo_pago_id: number | null
  }

  export type PagoCountAggregateOutputType = {
    id: number
    inscripcion_id: number
    monto: number
    estado: number
    codigo_pago: number
    fecha_pago: number
    metodo_pago_id: number
    _all: number
  }


  export type PagoAvgAggregateInputType = {
    id?: true
    inscripcion_id?: true
    monto?: true
    metodo_pago_id?: true
  }

  export type PagoSumAggregateInputType = {
    id?: true
    inscripcion_id?: true
    monto?: true
    metodo_pago_id?: true
  }

  export type PagoMinAggregateInputType = {
    id?: true
    inscripcion_id?: true
    monto?: true
    estado?: true
    codigo_pago?: true
    fecha_pago?: true
    metodo_pago_id?: true
  }

  export type PagoMaxAggregateInputType = {
    id?: true
    inscripcion_id?: true
    monto?: true
    estado?: true
    codigo_pago?: true
    fecha_pago?: true
    metodo_pago_id?: true
  }

  export type PagoCountAggregateInputType = {
    id?: true
    inscripcion_id?: true
    monto?: true
    estado?: true
    codigo_pago?: true
    fecha_pago?: true
    metodo_pago_id?: true
    _all?: true
  }

  export type PagoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pago to aggregate.
     */
    where?: PagoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pagos to fetch.
     */
    orderBy?: PagoOrderByWithRelationInput | PagoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PagoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pagos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pagos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pagos
    **/
    _count?: true | PagoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PagoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PagoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PagoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PagoMaxAggregateInputType
  }

  export type GetPagoAggregateType<T extends PagoAggregateArgs> = {
        [P in keyof T & keyof AggregatePago]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePago[P]>
      : GetScalarType<T[P], AggregatePago[P]>
  }




  export type PagoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PagoWhereInput
    orderBy?: PagoOrderByWithAggregationInput | PagoOrderByWithAggregationInput[]
    by: PagoScalarFieldEnum[] | PagoScalarFieldEnum
    having?: PagoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PagoCountAggregateInputType | true
    _avg?: PagoAvgAggregateInputType
    _sum?: PagoSumAggregateInputType
    _min?: PagoMinAggregateInputType
    _max?: PagoMaxAggregateInputType
  }

  export type PagoGroupByOutputType = {
    id: number
    inscripcion_id: number
    monto: Decimal
    estado: string
    codigo_pago: string
    fecha_pago: Date
    metodo_pago_id: number
    _count: PagoCountAggregateOutputType | null
    _avg: PagoAvgAggregateOutputType | null
    _sum: PagoSumAggregateOutputType | null
    _min: PagoMinAggregateOutputType | null
    _max: PagoMaxAggregateOutputType | null
  }

  type GetPagoGroupByPayload<T extends PagoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PagoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PagoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PagoGroupByOutputType[P]>
            : GetScalarType<T[P], PagoGroupByOutputType[P]>
        }
      >
    >


  export type PagoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inscripcion_id?: boolean
    monto?: boolean
    estado?: boolean
    codigo_pago?: boolean
    fecha_pago?: boolean
    metodo_pago_id?: boolean
    inscripcion?: boolean | InscripcionDefaultArgs<ExtArgs>
    metodo_pago?: boolean | Metodo_pagoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pago"]>

  export type PagoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inscripcion_id?: boolean
    monto?: boolean
    estado?: boolean
    codigo_pago?: boolean
    fecha_pago?: boolean
    metodo_pago_id?: boolean
    inscripcion?: boolean | InscripcionDefaultArgs<ExtArgs>
    metodo_pago?: boolean | Metodo_pagoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pago"]>

  export type PagoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inscripcion_id?: boolean
    monto?: boolean
    estado?: boolean
    codigo_pago?: boolean
    fecha_pago?: boolean
    metodo_pago_id?: boolean
    inscripcion?: boolean | InscripcionDefaultArgs<ExtArgs>
    metodo_pago?: boolean | Metodo_pagoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pago"]>

  export type PagoSelectScalar = {
    id?: boolean
    inscripcion_id?: boolean
    monto?: boolean
    estado?: boolean
    codigo_pago?: boolean
    fecha_pago?: boolean
    metodo_pago_id?: boolean
  }

  export type PagoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "inscripcion_id" | "monto" | "estado" | "codigo_pago" | "fecha_pago" | "metodo_pago_id", ExtArgs["result"]["pago"]>
  export type PagoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inscripcion?: boolean | InscripcionDefaultArgs<ExtArgs>
    metodo_pago?: boolean | Metodo_pagoDefaultArgs<ExtArgs>
  }
  export type PagoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inscripcion?: boolean | InscripcionDefaultArgs<ExtArgs>
    metodo_pago?: boolean | Metodo_pagoDefaultArgs<ExtArgs>
  }
  export type PagoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inscripcion?: boolean | InscripcionDefaultArgs<ExtArgs>
    metodo_pago?: boolean | Metodo_pagoDefaultArgs<ExtArgs>
  }

  export type $PagoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Pago"
    objects: {
      inscripcion: Prisma.$InscripcionPayload<ExtArgs>
      metodo_pago: Prisma.$Metodo_pagoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      inscripcion_id: number
      monto: Prisma.Decimal
      estado: string
      codigo_pago: string
      fecha_pago: Date
      metodo_pago_id: number
    }, ExtArgs["result"]["pago"]>
    composites: {}
  }

  type PagoGetPayload<S extends boolean | null | undefined | PagoDefaultArgs> = $Result.GetResult<Prisma.$PagoPayload, S>

  type PagoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PagoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PagoCountAggregateInputType | true
    }

  export interface PagoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Pago'], meta: { name: 'Pago' } }
    /**
     * Find zero or one Pago that matches the filter.
     * @param {PagoFindUniqueArgs} args - Arguments to find a Pago
     * @example
     * // Get one Pago
     * const pago = await prisma.pago.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PagoFindUniqueArgs>(args: SelectSubset<T, PagoFindUniqueArgs<ExtArgs>>): Prisma__PagoClient<$Result.GetResult<Prisma.$PagoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Pago that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PagoFindUniqueOrThrowArgs} args - Arguments to find a Pago
     * @example
     * // Get one Pago
     * const pago = await prisma.pago.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PagoFindUniqueOrThrowArgs>(args: SelectSubset<T, PagoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PagoClient<$Result.GetResult<Prisma.$PagoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pago that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagoFindFirstArgs} args - Arguments to find a Pago
     * @example
     * // Get one Pago
     * const pago = await prisma.pago.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PagoFindFirstArgs>(args?: SelectSubset<T, PagoFindFirstArgs<ExtArgs>>): Prisma__PagoClient<$Result.GetResult<Prisma.$PagoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pago that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagoFindFirstOrThrowArgs} args - Arguments to find a Pago
     * @example
     * // Get one Pago
     * const pago = await prisma.pago.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PagoFindFirstOrThrowArgs>(args?: SelectSubset<T, PagoFindFirstOrThrowArgs<ExtArgs>>): Prisma__PagoClient<$Result.GetResult<Prisma.$PagoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Pagos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pagos
     * const pagos = await prisma.pago.findMany()
     * 
     * // Get first 10 Pagos
     * const pagos = await prisma.pago.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pagoWithIdOnly = await prisma.pago.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PagoFindManyArgs>(args?: SelectSubset<T, PagoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Pago.
     * @param {PagoCreateArgs} args - Arguments to create a Pago.
     * @example
     * // Create one Pago
     * const Pago = await prisma.pago.create({
     *   data: {
     *     // ... data to create a Pago
     *   }
     * })
     * 
     */
    create<T extends PagoCreateArgs>(args: SelectSubset<T, PagoCreateArgs<ExtArgs>>): Prisma__PagoClient<$Result.GetResult<Prisma.$PagoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Pagos.
     * @param {PagoCreateManyArgs} args - Arguments to create many Pagos.
     * @example
     * // Create many Pagos
     * const pago = await prisma.pago.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PagoCreateManyArgs>(args?: SelectSubset<T, PagoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pagos and returns the data saved in the database.
     * @param {PagoCreateManyAndReturnArgs} args - Arguments to create many Pagos.
     * @example
     * // Create many Pagos
     * const pago = await prisma.pago.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pagos and only return the `id`
     * const pagoWithIdOnly = await prisma.pago.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PagoCreateManyAndReturnArgs>(args?: SelectSubset<T, PagoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Pago.
     * @param {PagoDeleteArgs} args - Arguments to delete one Pago.
     * @example
     * // Delete one Pago
     * const Pago = await prisma.pago.delete({
     *   where: {
     *     // ... filter to delete one Pago
     *   }
     * })
     * 
     */
    delete<T extends PagoDeleteArgs>(args: SelectSubset<T, PagoDeleteArgs<ExtArgs>>): Prisma__PagoClient<$Result.GetResult<Prisma.$PagoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Pago.
     * @param {PagoUpdateArgs} args - Arguments to update one Pago.
     * @example
     * // Update one Pago
     * const pago = await prisma.pago.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PagoUpdateArgs>(args: SelectSubset<T, PagoUpdateArgs<ExtArgs>>): Prisma__PagoClient<$Result.GetResult<Prisma.$PagoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Pagos.
     * @param {PagoDeleteManyArgs} args - Arguments to filter Pagos to delete.
     * @example
     * // Delete a few Pagos
     * const { count } = await prisma.pago.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PagoDeleteManyArgs>(args?: SelectSubset<T, PagoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pagos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pagos
     * const pago = await prisma.pago.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PagoUpdateManyArgs>(args: SelectSubset<T, PagoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pagos and returns the data updated in the database.
     * @param {PagoUpdateManyAndReturnArgs} args - Arguments to update many Pagos.
     * @example
     * // Update many Pagos
     * const pago = await prisma.pago.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Pagos and only return the `id`
     * const pagoWithIdOnly = await prisma.pago.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PagoUpdateManyAndReturnArgs>(args: SelectSubset<T, PagoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Pago.
     * @param {PagoUpsertArgs} args - Arguments to update or create a Pago.
     * @example
     * // Update or create a Pago
     * const pago = await prisma.pago.upsert({
     *   create: {
     *     // ... data to create a Pago
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pago we want to update
     *   }
     * })
     */
    upsert<T extends PagoUpsertArgs>(args: SelectSubset<T, PagoUpsertArgs<ExtArgs>>): Prisma__PagoClient<$Result.GetResult<Prisma.$PagoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Pagos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagoCountArgs} args - Arguments to filter Pagos to count.
     * @example
     * // Count the number of Pagos
     * const count = await prisma.pago.count({
     *   where: {
     *     // ... the filter for the Pagos we want to count
     *   }
     * })
    **/
    count<T extends PagoCountArgs>(
      args?: Subset<T, PagoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PagoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pago.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PagoAggregateArgs>(args: Subset<T, PagoAggregateArgs>): Prisma.PrismaPromise<GetPagoAggregateType<T>>

    /**
     * Group by Pago.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PagoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PagoGroupByArgs['orderBy'] }
        : { orderBy?: PagoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PagoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPagoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Pago model
   */
  readonly fields: PagoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Pago.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PagoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    inscripcion<T extends InscripcionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InscripcionDefaultArgs<ExtArgs>>): Prisma__InscripcionClient<$Result.GetResult<Prisma.$InscripcionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    metodo_pago<T extends Metodo_pagoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, Metodo_pagoDefaultArgs<ExtArgs>>): Prisma__Metodo_pagoClient<$Result.GetResult<Prisma.$Metodo_pagoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Pago model
   */
  interface PagoFieldRefs {
    readonly id: FieldRef<"Pago", 'Int'>
    readonly inscripcion_id: FieldRef<"Pago", 'Int'>
    readonly monto: FieldRef<"Pago", 'Decimal'>
    readonly estado: FieldRef<"Pago", 'String'>
    readonly codigo_pago: FieldRef<"Pago", 'String'>
    readonly fecha_pago: FieldRef<"Pago", 'DateTime'>
    readonly metodo_pago_id: FieldRef<"Pago", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Pago findUnique
   */
  export type PagoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pago
     */
    select?: PagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pago
     */
    omit?: PagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoInclude<ExtArgs> | null
    /**
     * Filter, which Pago to fetch.
     */
    where: PagoWhereUniqueInput
  }

  /**
   * Pago findUniqueOrThrow
   */
  export type PagoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pago
     */
    select?: PagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pago
     */
    omit?: PagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoInclude<ExtArgs> | null
    /**
     * Filter, which Pago to fetch.
     */
    where: PagoWhereUniqueInput
  }

  /**
   * Pago findFirst
   */
  export type PagoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pago
     */
    select?: PagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pago
     */
    omit?: PagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoInclude<ExtArgs> | null
    /**
     * Filter, which Pago to fetch.
     */
    where?: PagoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pagos to fetch.
     */
    orderBy?: PagoOrderByWithRelationInput | PagoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pagos.
     */
    cursor?: PagoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pagos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pagos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pagos.
     */
    distinct?: PagoScalarFieldEnum | PagoScalarFieldEnum[]
  }

  /**
   * Pago findFirstOrThrow
   */
  export type PagoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pago
     */
    select?: PagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pago
     */
    omit?: PagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoInclude<ExtArgs> | null
    /**
     * Filter, which Pago to fetch.
     */
    where?: PagoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pagos to fetch.
     */
    orderBy?: PagoOrderByWithRelationInput | PagoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pagos.
     */
    cursor?: PagoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pagos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pagos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pagos.
     */
    distinct?: PagoScalarFieldEnum | PagoScalarFieldEnum[]
  }

  /**
   * Pago findMany
   */
  export type PagoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pago
     */
    select?: PagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pago
     */
    omit?: PagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoInclude<ExtArgs> | null
    /**
     * Filter, which Pagos to fetch.
     */
    where?: PagoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pagos to fetch.
     */
    orderBy?: PagoOrderByWithRelationInput | PagoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pagos.
     */
    cursor?: PagoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pagos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pagos.
     */
    skip?: number
    distinct?: PagoScalarFieldEnum | PagoScalarFieldEnum[]
  }

  /**
   * Pago create
   */
  export type PagoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pago
     */
    select?: PagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pago
     */
    omit?: PagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoInclude<ExtArgs> | null
    /**
     * The data needed to create a Pago.
     */
    data: XOR<PagoCreateInput, PagoUncheckedCreateInput>
  }

  /**
   * Pago createMany
   */
  export type PagoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pagos.
     */
    data: PagoCreateManyInput | PagoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Pago createManyAndReturn
   */
  export type PagoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pago
     */
    select?: PagoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Pago
     */
    omit?: PagoOmit<ExtArgs> | null
    /**
     * The data used to create many Pagos.
     */
    data: PagoCreateManyInput | PagoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Pago update
   */
  export type PagoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pago
     */
    select?: PagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pago
     */
    omit?: PagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoInclude<ExtArgs> | null
    /**
     * The data needed to update a Pago.
     */
    data: XOR<PagoUpdateInput, PagoUncheckedUpdateInput>
    /**
     * Choose, which Pago to update.
     */
    where: PagoWhereUniqueInput
  }

  /**
   * Pago updateMany
   */
  export type PagoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pagos.
     */
    data: XOR<PagoUpdateManyMutationInput, PagoUncheckedUpdateManyInput>
    /**
     * Filter which Pagos to update
     */
    where?: PagoWhereInput
    /**
     * Limit how many Pagos to update.
     */
    limit?: number
  }

  /**
   * Pago updateManyAndReturn
   */
  export type PagoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pago
     */
    select?: PagoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Pago
     */
    omit?: PagoOmit<ExtArgs> | null
    /**
     * The data used to update Pagos.
     */
    data: XOR<PagoUpdateManyMutationInput, PagoUncheckedUpdateManyInput>
    /**
     * Filter which Pagos to update
     */
    where?: PagoWhereInput
    /**
     * Limit how many Pagos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Pago upsert
   */
  export type PagoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pago
     */
    select?: PagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pago
     */
    omit?: PagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoInclude<ExtArgs> | null
    /**
     * The filter to search for the Pago to update in case it exists.
     */
    where: PagoWhereUniqueInput
    /**
     * In case the Pago found by the `where` argument doesn't exist, create a new Pago with this data.
     */
    create: XOR<PagoCreateInput, PagoUncheckedCreateInput>
    /**
     * In case the Pago was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PagoUpdateInput, PagoUncheckedUpdateInput>
  }

  /**
   * Pago delete
   */
  export type PagoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pago
     */
    select?: PagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pago
     */
    omit?: PagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoInclude<ExtArgs> | null
    /**
     * Filter which Pago to delete.
     */
    where: PagoWhereUniqueInput
  }

  /**
   * Pago deleteMany
   */
  export type PagoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pagos to delete
     */
    where?: PagoWhereInput
    /**
     * Limit how many Pagos to delete.
     */
    limit?: number
  }

  /**
   * Pago without action
   */
  export type PagoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pago
     */
    select?: PagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pago
     */
    omit?: PagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoInclude<ExtArgs> | null
  }


  /**
   * Model Area_convocatoria
   */

  export type AggregateArea_convocatoria = {
    _count: Area_convocatoriaCountAggregateOutputType | null
    _avg: Area_convocatoriaAvgAggregateOutputType | null
    _sum: Area_convocatoriaSumAggregateOutputType | null
    _min: Area_convocatoriaMinAggregateOutputType | null
    _max: Area_convocatoriaMaxAggregateOutputType | null
  }

  export type Area_convocatoriaAvgAggregateOutputType = {
    id: number | null
    area_id: number | null
    convocatoria_id: number | null
  }

  export type Area_convocatoriaSumAggregateOutputType = {
    id: number | null
    area_id: number | null
    convocatoria_id: number | null
  }

  export type Area_convocatoriaMinAggregateOutputType = {
    id: number | null
    area_id: number | null
    convocatoria_id: number | null
  }

  export type Area_convocatoriaMaxAggregateOutputType = {
    id: number | null
    area_id: number | null
    convocatoria_id: number | null
  }

  export type Area_convocatoriaCountAggregateOutputType = {
    id: number
    area_id: number
    convocatoria_id: number
    _all: number
  }


  export type Area_convocatoriaAvgAggregateInputType = {
    id?: true
    area_id?: true
    convocatoria_id?: true
  }

  export type Area_convocatoriaSumAggregateInputType = {
    id?: true
    area_id?: true
    convocatoria_id?: true
  }

  export type Area_convocatoriaMinAggregateInputType = {
    id?: true
    area_id?: true
    convocatoria_id?: true
  }

  export type Area_convocatoriaMaxAggregateInputType = {
    id?: true
    area_id?: true
    convocatoria_id?: true
  }

  export type Area_convocatoriaCountAggregateInputType = {
    id?: true
    area_id?: true
    convocatoria_id?: true
    _all?: true
  }

  export type Area_convocatoriaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Area_convocatoria to aggregate.
     */
    where?: Area_convocatoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Area_convocatorias to fetch.
     */
    orderBy?: Area_convocatoriaOrderByWithRelationInput | Area_convocatoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Area_convocatoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Area_convocatorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Area_convocatorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Area_convocatorias
    **/
    _count?: true | Area_convocatoriaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Area_convocatoriaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Area_convocatoriaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Area_convocatoriaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Area_convocatoriaMaxAggregateInputType
  }

  export type GetArea_convocatoriaAggregateType<T extends Area_convocatoriaAggregateArgs> = {
        [P in keyof T & keyof AggregateArea_convocatoria]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArea_convocatoria[P]>
      : GetScalarType<T[P], AggregateArea_convocatoria[P]>
  }




  export type Area_convocatoriaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Area_convocatoriaWhereInput
    orderBy?: Area_convocatoriaOrderByWithAggregationInput | Area_convocatoriaOrderByWithAggregationInput[]
    by: Area_convocatoriaScalarFieldEnum[] | Area_convocatoriaScalarFieldEnum
    having?: Area_convocatoriaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Area_convocatoriaCountAggregateInputType | true
    _avg?: Area_convocatoriaAvgAggregateInputType
    _sum?: Area_convocatoriaSumAggregateInputType
    _min?: Area_convocatoriaMinAggregateInputType
    _max?: Area_convocatoriaMaxAggregateInputType
  }

  export type Area_convocatoriaGroupByOutputType = {
    id: number
    area_id: number
    convocatoria_id: number
    _count: Area_convocatoriaCountAggregateOutputType | null
    _avg: Area_convocatoriaAvgAggregateOutputType | null
    _sum: Area_convocatoriaSumAggregateOutputType | null
    _min: Area_convocatoriaMinAggregateOutputType | null
    _max: Area_convocatoriaMaxAggregateOutputType | null
  }

  type GetArea_convocatoriaGroupByPayload<T extends Area_convocatoriaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Area_convocatoriaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Area_convocatoriaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Area_convocatoriaGroupByOutputType[P]>
            : GetScalarType<T[P], Area_convocatoriaGroupByOutputType[P]>
        }
      >
    >


  export type Area_convocatoriaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    area_id?: boolean
    convocatoria_id?: boolean
    area?: boolean | AreaDefaultArgs<ExtArgs>
    convocatoria?: boolean | ConvocatoriaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["area_convocatoria"]>

  export type Area_convocatoriaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    area_id?: boolean
    convocatoria_id?: boolean
    area?: boolean | AreaDefaultArgs<ExtArgs>
    convocatoria?: boolean | ConvocatoriaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["area_convocatoria"]>

  export type Area_convocatoriaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    area_id?: boolean
    convocatoria_id?: boolean
    area?: boolean | AreaDefaultArgs<ExtArgs>
    convocatoria?: boolean | ConvocatoriaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["area_convocatoria"]>

  export type Area_convocatoriaSelectScalar = {
    id?: boolean
    area_id?: boolean
    convocatoria_id?: boolean
  }

  export type Area_convocatoriaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "area_id" | "convocatoria_id", ExtArgs["result"]["area_convocatoria"]>
  export type Area_convocatoriaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    area?: boolean | AreaDefaultArgs<ExtArgs>
    convocatoria?: boolean | ConvocatoriaDefaultArgs<ExtArgs>
  }
  export type Area_convocatoriaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    area?: boolean | AreaDefaultArgs<ExtArgs>
    convocatoria?: boolean | ConvocatoriaDefaultArgs<ExtArgs>
  }
  export type Area_convocatoriaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    area?: boolean | AreaDefaultArgs<ExtArgs>
    convocatoria?: boolean | ConvocatoriaDefaultArgs<ExtArgs>
  }

  export type $Area_convocatoriaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Area_convocatoria"
    objects: {
      area: Prisma.$AreaPayload<ExtArgs>
      convocatoria: Prisma.$ConvocatoriaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      area_id: number
      convocatoria_id: number
    }, ExtArgs["result"]["area_convocatoria"]>
    composites: {}
  }

  type Area_convocatoriaGetPayload<S extends boolean | null | undefined | Area_convocatoriaDefaultArgs> = $Result.GetResult<Prisma.$Area_convocatoriaPayload, S>

  type Area_convocatoriaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Area_convocatoriaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Area_convocatoriaCountAggregateInputType | true
    }

  export interface Area_convocatoriaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Area_convocatoria'], meta: { name: 'Area_convocatoria' } }
    /**
     * Find zero or one Area_convocatoria that matches the filter.
     * @param {Area_convocatoriaFindUniqueArgs} args - Arguments to find a Area_convocatoria
     * @example
     * // Get one Area_convocatoria
     * const area_convocatoria = await prisma.area_convocatoria.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Area_convocatoriaFindUniqueArgs>(args: SelectSubset<T, Area_convocatoriaFindUniqueArgs<ExtArgs>>): Prisma__Area_convocatoriaClient<$Result.GetResult<Prisma.$Area_convocatoriaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Area_convocatoria that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Area_convocatoriaFindUniqueOrThrowArgs} args - Arguments to find a Area_convocatoria
     * @example
     * // Get one Area_convocatoria
     * const area_convocatoria = await prisma.area_convocatoria.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Area_convocatoriaFindUniqueOrThrowArgs>(args: SelectSubset<T, Area_convocatoriaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Area_convocatoriaClient<$Result.GetResult<Prisma.$Area_convocatoriaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Area_convocatoria that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Area_convocatoriaFindFirstArgs} args - Arguments to find a Area_convocatoria
     * @example
     * // Get one Area_convocatoria
     * const area_convocatoria = await prisma.area_convocatoria.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Area_convocatoriaFindFirstArgs>(args?: SelectSubset<T, Area_convocatoriaFindFirstArgs<ExtArgs>>): Prisma__Area_convocatoriaClient<$Result.GetResult<Prisma.$Area_convocatoriaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Area_convocatoria that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Area_convocatoriaFindFirstOrThrowArgs} args - Arguments to find a Area_convocatoria
     * @example
     * // Get one Area_convocatoria
     * const area_convocatoria = await prisma.area_convocatoria.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Area_convocatoriaFindFirstOrThrowArgs>(args?: SelectSubset<T, Area_convocatoriaFindFirstOrThrowArgs<ExtArgs>>): Prisma__Area_convocatoriaClient<$Result.GetResult<Prisma.$Area_convocatoriaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Area_convocatorias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Area_convocatoriaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Area_convocatorias
     * const area_convocatorias = await prisma.area_convocatoria.findMany()
     * 
     * // Get first 10 Area_convocatorias
     * const area_convocatorias = await prisma.area_convocatoria.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const area_convocatoriaWithIdOnly = await prisma.area_convocatoria.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Area_convocatoriaFindManyArgs>(args?: SelectSubset<T, Area_convocatoriaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Area_convocatoriaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Area_convocatoria.
     * @param {Area_convocatoriaCreateArgs} args - Arguments to create a Area_convocatoria.
     * @example
     * // Create one Area_convocatoria
     * const Area_convocatoria = await prisma.area_convocatoria.create({
     *   data: {
     *     // ... data to create a Area_convocatoria
     *   }
     * })
     * 
     */
    create<T extends Area_convocatoriaCreateArgs>(args: SelectSubset<T, Area_convocatoriaCreateArgs<ExtArgs>>): Prisma__Area_convocatoriaClient<$Result.GetResult<Prisma.$Area_convocatoriaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Area_convocatorias.
     * @param {Area_convocatoriaCreateManyArgs} args - Arguments to create many Area_convocatorias.
     * @example
     * // Create many Area_convocatorias
     * const area_convocatoria = await prisma.area_convocatoria.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Area_convocatoriaCreateManyArgs>(args?: SelectSubset<T, Area_convocatoriaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Area_convocatorias and returns the data saved in the database.
     * @param {Area_convocatoriaCreateManyAndReturnArgs} args - Arguments to create many Area_convocatorias.
     * @example
     * // Create many Area_convocatorias
     * const area_convocatoria = await prisma.area_convocatoria.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Area_convocatorias and only return the `id`
     * const area_convocatoriaWithIdOnly = await prisma.area_convocatoria.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Area_convocatoriaCreateManyAndReturnArgs>(args?: SelectSubset<T, Area_convocatoriaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Area_convocatoriaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Area_convocatoria.
     * @param {Area_convocatoriaDeleteArgs} args - Arguments to delete one Area_convocatoria.
     * @example
     * // Delete one Area_convocatoria
     * const Area_convocatoria = await prisma.area_convocatoria.delete({
     *   where: {
     *     // ... filter to delete one Area_convocatoria
     *   }
     * })
     * 
     */
    delete<T extends Area_convocatoriaDeleteArgs>(args: SelectSubset<T, Area_convocatoriaDeleteArgs<ExtArgs>>): Prisma__Area_convocatoriaClient<$Result.GetResult<Prisma.$Area_convocatoriaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Area_convocatoria.
     * @param {Area_convocatoriaUpdateArgs} args - Arguments to update one Area_convocatoria.
     * @example
     * // Update one Area_convocatoria
     * const area_convocatoria = await prisma.area_convocatoria.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Area_convocatoriaUpdateArgs>(args: SelectSubset<T, Area_convocatoriaUpdateArgs<ExtArgs>>): Prisma__Area_convocatoriaClient<$Result.GetResult<Prisma.$Area_convocatoriaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Area_convocatorias.
     * @param {Area_convocatoriaDeleteManyArgs} args - Arguments to filter Area_convocatorias to delete.
     * @example
     * // Delete a few Area_convocatorias
     * const { count } = await prisma.area_convocatoria.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Area_convocatoriaDeleteManyArgs>(args?: SelectSubset<T, Area_convocatoriaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Area_convocatorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Area_convocatoriaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Area_convocatorias
     * const area_convocatoria = await prisma.area_convocatoria.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Area_convocatoriaUpdateManyArgs>(args: SelectSubset<T, Area_convocatoriaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Area_convocatorias and returns the data updated in the database.
     * @param {Area_convocatoriaUpdateManyAndReturnArgs} args - Arguments to update many Area_convocatorias.
     * @example
     * // Update many Area_convocatorias
     * const area_convocatoria = await prisma.area_convocatoria.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Area_convocatorias and only return the `id`
     * const area_convocatoriaWithIdOnly = await prisma.area_convocatoria.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends Area_convocatoriaUpdateManyAndReturnArgs>(args: SelectSubset<T, Area_convocatoriaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Area_convocatoriaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Area_convocatoria.
     * @param {Area_convocatoriaUpsertArgs} args - Arguments to update or create a Area_convocatoria.
     * @example
     * // Update or create a Area_convocatoria
     * const area_convocatoria = await prisma.area_convocatoria.upsert({
     *   create: {
     *     // ... data to create a Area_convocatoria
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Area_convocatoria we want to update
     *   }
     * })
     */
    upsert<T extends Area_convocatoriaUpsertArgs>(args: SelectSubset<T, Area_convocatoriaUpsertArgs<ExtArgs>>): Prisma__Area_convocatoriaClient<$Result.GetResult<Prisma.$Area_convocatoriaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Area_convocatorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Area_convocatoriaCountArgs} args - Arguments to filter Area_convocatorias to count.
     * @example
     * // Count the number of Area_convocatorias
     * const count = await prisma.area_convocatoria.count({
     *   where: {
     *     // ... the filter for the Area_convocatorias we want to count
     *   }
     * })
    **/
    count<T extends Area_convocatoriaCountArgs>(
      args?: Subset<T, Area_convocatoriaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Area_convocatoriaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Area_convocatoria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Area_convocatoriaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Area_convocatoriaAggregateArgs>(args: Subset<T, Area_convocatoriaAggregateArgs>): Prisma.PrismaPromise<GetArea_convocatoriaAggregateType<T>>

    /**
     * Group by Area_convocatoria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Area_convocatoriaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Area_convocatoriaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Area_convocatoriaGroupByArgs['orderBy'] }
        : { orderBy?: Area_convocatoriaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Area_convocatoriaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetArea_convocatoriaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Area_convocatoria model
   */
  readonly fields: Area_convocatoriaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Area_convocatoria.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Area_convocatoriaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    area<T extends AreaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AreaDefaultArgs<ExtArgs>>): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    convocatoria<T extends ConvocatoriaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConvocatoriaDefaultArgs<ExtArgs>>): Prisma__ConvocatoriaClient<$Result.GetResult<Prisma.$ConvocatoriaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Area_convocatoria model
   */
  interface Area_convocatoriaFieldRefs {
    readonly id: FieldRef<"Area_convocatoria", 'Int'>
    readonly area_id: FieldRef<"Area_convocatoria", 'Int'>
    readonly convocatoria_id: FieldRef<"Area_convocatoria", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Area_convocatoria findUnique
   */
  export type Area_convocatoriaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area_convocatoria
     */
    select?: Area_convocatoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Area_convocatoria
     */
    omit?: Area_convocatoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Area_convocatoriaInclude<ExtArgs> | null
    /**
     * Filter, which Area_convocatoria to fetch.
     */
    where: Area_convocatoriaWhereUniqueInput
  }

  /**
   * Area_convocatoria findUniqueOrThrow
   */
  export type Area_convocatoriaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area_convocatoria
     */
    select?: Area_convocatoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Area_convocatoria
     */
    omit?: Area_convocatoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Area_convocatoriaInclude<ExtArgs> | null
    /**
     * Filter, which Area_convocatoria to fetch.
     */
    where: Area_convocatoriaWhereUniqueInput
  }

  /**
   * Area_convocatoria findFirst
   */
  export type Area_convocatoriaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area_convocatoria
     */
    select?: Area_convocatoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Area_convocatoria
     */
    omit?: Area_convocatoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Area_convocatoriaInclude<ExtArgs> | null
    /**
     * Filter, which Area_convocatoria to fetch.
     */
    where?: Area_convocatoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Area_convocatorias to fetch.
     */
    orderBy?: Area_convocatoriaOrderByWithRelationInput | Area_convocatoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Area_convocatorias.
     */
    cursor?: Area_convocatoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Area_convocatorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Area_convocatorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Area_convocatorias.
     */
    distinct?: Area_convocatoriaScalarFieldEnum | Area_convocatoriaScalarFieldEnum[]
  }

  /**
   * Area_convocatoria findFirstOrThrow
   */
  export type Area_convocatoriaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area_convocatoria
     */
    select?: Area_convocatoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Area_convocatoria
     */
    omit?: Area_convocatoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Area_convocatoriaInclude<ExtArgs> | null
    /**
     * Filter, which Area_convocatoria to fetch.
     */
    where?: Area_convocatoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Area_convocatorias to fetch.
     */
    orderBy?: Area_convocatoriaOrderByWithRelationInput | Area_convocatoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Area_convocatorias.
     */
    cursor?: Area_convocatoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Area_convocatorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Area_convocatorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Area_convocatorias.
     */
    distinct?: Area_convocatoriaScalarFieldEnum | Area_convocatoriaScalarFieldEnum[]
  }

  /**
   * Area_convocatoria findMany
   */
  export type Area_convocatoriaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area_convocatoria
     */
    select?: Area_convocatoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Area_convocatoria
     */
    omit?: Area_convocatoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Area_convocatoriaInclude<ExtArgs> | null
    /**
     * Filter, which Area_convocatorias to fetch.
     */
    where?: Area_convocatoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Area_convocatorias to fetch.
     */
    orderBy?: Area_convocatoriaOrderByWithRelationInput | Area_convocatoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Area_convocatorias.
     */
    cursor?: Area_convocatoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Area_convocatorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Area_convocatorias.
     */
    skip?: number
    distinct?: Area_convocatoriaScalarFieldEnum | Area_convocatoriaScalarFieldEnum[]
  }

  /**
   * Area_convocatoria create
   */
  export type Area_convocatoriaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area_convocatoria
     */
    select?: Area_convocatoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Area_convocatoria
     */
    omit?: Area_convocatoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Area_convocatoriaInclude<ExtArgs> | null
    /**
     * The data needed to create a Area_convocatoria.
     */
    data: XOR<Area_convocatoriaCreateInput, Area_convocatoriaUncheckedCreateInput>
  }

  /**
   * Area_convocatoria createMany
   */
  export type Area_convocatoriaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Area_convocatorias.
     */
    data: Area_convocatoriaCreateManyInput | Area_convocatoriaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Area_convocatoria createManyAndReturn
   */
  export type Area_convocatoriaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area_convocatoria
     */
    select?: Area_convocatoriaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Area_convocatoria
     */
    omit?: Area_convocatoriaOmit<ExtArgs> | null
    /**
     * The data used to create many Area_convocatorias.
     */
    data: Area_convocatoriaCreateManyInput | Area_convocatoriaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Area_convocatoriaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Area_convocatoria update
   */
  export type Area_convocatoriaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area_convocatoria
     */
    select?: Area_convocatoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Area_convocatoria
     */
    omit?: Area_convocatoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Area_convocatoriaInclude<ExtArgs> | null
    /**
     * The data needed to update a Area_convocatoria.
     */
    data: XOR<Area_convocatoriaUpdateInput, Area_convocatoriaUncheckedUpdateInput>
    /**
     * Choose, which Area_convocatoria to update.
     */
    where: Area_convocatoriaWhereUniqueInput
  }

  /**
   * Area_convocatoria updateMany
   */
  export type Area_convocatoriaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Area_convocatorias.
     */
    data: XOR<Area_convocatoriaUpdateManyMutationInput, Area_convocatoriaUncheckedUpdateManyInput>
    /**
     * Filter which Area_convocatorias to update
     */
    where?: Area_convocatoriaWhereInput
    /**
     * Limit how many Area_convocatorias to update.
     */
    limit?: number
  }

  /**
   * Area_convocatoria updateManyAndReturn
   */
  export type Area_convocatoriaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area_convocatoria
     */
    select?: Area_convocatoriaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Area_convocatoria
     */
    omit?: Area_convocatoriaOmit<ExtArgs> | null
    /**
     * The data used to update Area_convocatorias.
     */
    data: XOR<Area_convocatoriaUpdateManyMutationInput, Area_convocatoriaUncheckedUpdateManyInput>
    /**
     * Filter which Area_convocatorias to update
     */
    where?: Area_convocatoriaWhereInput
    /**
     * Limit how many Area_convocatorias to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Area_convocatoriaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Area_convocatoria upsert
   */
  export type Area_convocatoriaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area_convocatoria
     */
    select?: Area_convocatoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Area_convocatoria
     */
    omit?: Area_convocatoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Area_convocatoriaInclude<ExtArgs> | null
    /**
     * The filter to search for the Area_convocatoria to update in case it exists.
     */
    where: Area_convocatoriaWhereUniqueInput
    /**
     * In case the Area_convocatoria found by the `where` argument doesn't exist, create a new Area_convocatoria with this data.
     */
    create: XOR<Area_convocatoriaCreateInput, Area_convocatoriaUncheckedCreateInput>
    /**
     * In case the Area_convocatoria was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Area_convocatoriaUpdateInput, Area_convocatoriaUncheckedUpdateInput>
  }

  /**
   * Area_convocatoria delete
   */
  export type Area_convocatoriaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area_convocatoria
     */
    select?: Area_convocatoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Area_convocatoria
     */
    omit?: Area_convocatoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Area_convocatoriaInclude<ExtArgs> | null
    /**
     * Filter which Area_convocatoria to delete.
     */
    where: Area_convocatoriaWhereUniqueInput
  }

  /**
   * Area_convocatoria deleteMany
   */
  export type Area_convocatoriaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Area_convocatorias to delete
     */
    where?: Area_convocatoriaWhereInput
    /**
     * Limit how many Area_convocatorias to delete.
     */
    limit?: number
  }

  /**
   * Area_convocatoria without action
   */
  export type Area_convocatoriaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area_convocatoria
     */
    select?: Area_convocatoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Area_convocatoria
     */
    omit?: Area_convocatoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Area_convocatoriaInclude<ExtArgs> | null
  }


  /**
   * Model Categoria_area
   */

  export type AggregateCategoria_area = {
    _count: Categoria_areaCountAggregateOutputType | null
    _avg: Categoria_areaAvgAggregateOutputType | null
    _sum: Categoria_areaSumAggregateOutputType | null
    _min: Categoria_areaMinAggregateOutputType | null
    _max: Categoria_areaMaxAggregateOutputType | null
  }

  export type Categoria_areaAvgAggregateOutputType = {
    id: number | null
    categoria_id: number | null
    area_id: number | null
  }

  export type Categoria_areaSumAggregateOutputType = {
    id: number | null
    categoria_id: number | null
    area_id: number | null
  }

  export type Categoria_areaMinAggregateOutputType = {
    id: number | null
    categoria_id: number | null
    area_id: number | null
  }

  export type Categoria_areaMaxAggregateOutputType = {
    id: number | null
    categoria_id: number | null
    area_id: number | null
  }

  export type Categoria_areaCountAggregateOutputType = {
    id: number
    categoria_id: number
    area_id: number
    _all: number
  }


  export type Categoria_areaAvgAggregateInputType = {
    id?: true
    categoria_id?: true
    area_id?: true
  }

  export type Categoria_areaSumAggregateInputType = {
    id?: true
    categoria_id?: true
    area_id?: true
  }

  export type Categoria_areaMinAggregateInputType = {
    id?: true
    categoria_id?: true
    area_id?: true
  }

  export type Categoria_areaMaxAggregateInputType = {
    id?: true
    categoria_id?: true
    area_id?: true
  }

  export type Categoria_areaCountAggregateInputType = {
    id?: true
    categoria_id?: true
    area_id?: true
    _all?: true
  }

  export type Categoria_areaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categoria_area to aggregate.
     */
    where?: Categoria_areaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categoria_areas to fetch.
     */
    orderBy?: Categoria_areaOrderByWithRelationInput | Categoria_areaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Categoria_areaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categoria_areas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categoria_areas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categoria_areas
    **/
    _count?: true | Categoria_areaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Categoria_areaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Categoria_areaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Categoria_areaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Categoria_areaMaxAggregateInputType
  }

  export type GetCategoria_areaAggregateType<T extends Categoria_areaAggregateArgs> = {
        [P in keyof T & keyof AggregateCategoria_area]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategoria_area[P]>
      : GetScalarType<T[P], AggregateCategoria_area[P]>
  }




  export type Categoria_areaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Categoria_areaWhereInput
    orderBy?: Categoria_areaOrderByWithAggregationInput | Categoria_areaOrderByWithAggregationInput[]
    by: Categoria_areaScalarFieldEnum[] | Categoria_areaScalarFieldEnum
    having?: Categoria_areaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Categoria_areaCountAggregateInputType | true
    _avg?: Categoria_areaAvgAggregateInputType
    _sum?: Categoria_areaSumAggregateInputType
    _min?: Categoria_areaMinAggregateInputType
    _max?: Categoria_areaMaxAggregateInputType
  }

  export type Categoria_areaGroupByOutputType = {
    id: number
    categoria_id: number
    area_id: number
    _count: Categoria_areaCountAggregateOutputType | null
    _avg: Categoria_areaAvgAggregateOutputType | null
    _sum: Categoria_areaSumAggregateOutputType | null
    _min: Categoria_areaMinAggregateOutputType | null
    _max: Categoria_areaMaxAggregateOutputType | null
  }

  type GetCategoria_areaGroupByPayload<T extends Categoria_areaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Categoria_areaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Categoria_areaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Categoria_areaGroupByOutputType[P]>
            : GetScalarType<T[P], Categoria_areaGroupByOutputType[P]>
        }
      >
    >


  export type Categoria_areaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    categoria_id?: boolean
    area_id?: boolean
    area?: boolean | AreaDefaultArgs<ExtArgs>
    categoria?: boolean | CategoriaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["categoria_area"]>

  export type Categoria_areaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    categoria_id?: boolean
    area_id?: boolean
    area?: boolean | AreaDefaultArgs<ExtArgs>
    categoria?: boolean | CategoriaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["categoria_area"]>

  export type Categoria_areaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    categoria_id?: boolean
    area_id?: boolean
    area?: boolean | AreaDefaultArgs<ExtArgs>
    categoria?: boolean | CategoriaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["categoria_area"]>

  export type Categoria_areaSelectScalar = {
    id?: boolean
    categoria_id?: boolean
    area_id?: boolean
  }

  export type Categoria_areaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "categoria_id" | "area_id", ExtArgs["result"]["categoria_area"]>
  export type Categoria_areaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    area?: boolean | AreaDefaultArgs<ExtArgs>
    categoria?: boolean | CategoriaDefaultArgs<ExtArgs>
  }
  export type Categoria_areaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    area?: boolean | AreaDefaultArgs<ExtArgs>
    categoria?: boolean | CategoriaDefaultArgs<ExtArgs>
  }
  export type Categoria_areaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    area?: boolean | AreaDefaultArgs<ExtArgs>
    categoria?: boolean | CategoriaDefaultArgs<ExtArgs>
  }

  export type $Categoria_areaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Categoria_area"
    objects: {
      area: Prisma.$AreaPayload<ExtArgs>
      categoria: Prisma.$CategoriaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      categoria_id: number
      area_id: number
    }, ExtArgs["result"]["categoria_area"]>
    composites: {}
  }

  type Categoria_areaGetPayload<S extends boolean | null | undefined | Categoria_areaDefaultArgs> = $Result.GetResult<Prisma.$Categoria_areaPayload, S>

  type Categoria_areaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Categoria_areaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Categoria_areaCountAggregateInputType | true
    }

  export interface Categoria_areaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Categoria_area'], meta: { name: 'Categoria_area' } }
    /**
     * Find zero or one Categoria_area that matches the filter.
     * @param {Categoria_areaFindUniqueArgs} args - Arguments to find a Categoria_area
     * @example
     * // Get one Categoria_area
     * const categoria_area = await prisma.categoria_area.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Categoria_areaFindUniqueArgs>(args: SelectSubset<T, Categoria_areaFindUniqueArgs<ExtArgs>>): Prisma__Categoria_areaClient<$Result.GetResult<Prisma.$Categoria_areaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Categoria_area that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Categoria_areaFindUniqueOrThrowArgs} args - Arguments to find a Categoria_area
     * @example
     * // Get one Categoria_area
     * const categoria_area = await prisma.categoria_area.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Categoria_areaFindUniqueOrThrowArgs>(args: SelectSubset<T, Categoria_areaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Categoria_areaClient<$Result.GetResult<Prisma.$Categoria_areaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Categoria_area that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Categoria_areaFindFirstArgs} args - Arguments to find a Categoria_area
     * @example
     * // Get one Categoria_area
     * const categoria_area = await prisma.categoria_area.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Categoria_areaFindFirstArgs>(args?: SelectSubset<T, Categoria_areaFindFirstArgs<ExtArgs>>): Prisma__Categoria_areaClient<$Result.GetResult<Prisma.$Categoria_areaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Categoria_area that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Categoria_areaFindFirstOrThrowArgs} args - Arguments to find a Categoria_area
     * @example
     * // Get one Categoria_area
     * const categoria_area = await prisma.categoria_area.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Categoria_areaFindFirstOrThrowArgs>(args?: SelectSubset<T, Categoria_areaFindFirstOrThrowArgs<ExtArgs>>): Prisma__Categoria_areaClient<$Result.GetResult<Prisma.$Categoria_areaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categoria_areas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Categoria_areaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categoria_areas
     * const categoria_areas = await prisma.categoria_area.findMany()
     * 
     * // Get first 10 Categoria_areas
     * const categoria_areas = await prisma.categoria_area.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoria_areaWithIdOnly = await prisma.categoria_area.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Categoria_areaFindManyArgs>(args?: SelectSubset<T, Categoria_areaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Categoria_areaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Categoria_area.
     * @param {Categoria_areaCreateArgs} args - Arguments to create a Categoria_area.
     * @example
     * // Create one Categoria_area
     * const Categoria_area = await prisma.categoria_area.create({
     *   data: {
     *     // ... data to create a Categoria_area
     *   }
     * })
     * 
     */
    create<T extends Categoria_areaCreateArgs>(args: SelectSubset<T, Categoria_areaCreateArgs<ExtArgs>>): Prisma__Categoria_areaClient<$Result.GetResult<Prisma.$Categoria_areaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categoria_areas.
     * @param {Categoria_areaCreateManyArgs} args - Arguments to create many Categoria_areas.
     * @example
     * // Create many Categoria_areas
     * const categoria_area = await prisma.categoria_area.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Categoria_areaCreateManyArgs>(args?: SelectSubset<T, Categoria_areaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categoria_areas and returns the data saved in the database.
     * @param {Categoria_areaCreateManyAndReturnArgs} args - Arguments to create many Categoria_areas.
     * @example
     * // Create many Categoria_areas
     * const categoria_area = await prisma.categoria_area.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categoria_areas and only return the `id`
     * const categoria_areaWithIdOnly = await prisma.categoria_area.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Categoria_areaCreateManyAndReturnArgs>(args?: SelectSubset<T, Categoria_areaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Categoria_areaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Categoria_area.
     * @param {Categoria_areaDeleteArgs} args - Arguments to delete one Categoria_area.
     * @example
     * // Delete one Categoria_area
     * const Categoria_area = await prisma.categoria_area.delete({
     *   where: {
     *     // ... filter to delete one Categoria_area
     *   }
     * })
     * 
     */
    delete<T extends Categoria_areaDeleteArgs>(args: SelectSubset<T, Categoria_areaDeleteArgs<ExtArgs>>): Prisma__Categoria_areaClient<$Result.GetResult<Prisma.$Categoria_areaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Categoria_area.
     * @param {Categoria_areaUpdateArgs} args - Arguments to update one Categoria_area.
     * @example
     * // Update one Categoria_area
     * const categoria_area = await prisma.categoria_area.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Categoria_areaUpdateArgs>(args: SelectSubset<T, Categoria_areaUpdateArgs<ExtArgs>>): Prisma__Categoria_areaClient<$Result.GetResult<Prisma.$Categoria_areaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categoria_areas.
     * @param {Categoria_areaDeleteManyArgs} args - Arguments to filter Categoria_areas to delete.
     * @example
     * // Delete a few Categoria_areas
     * const { count } = await prisma.categoria_area.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Categoria_areaDeleteManyArgs>(args?: SelectSubset<T, Categoria_areaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categoria_areas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Categoria_areaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categoria_areas
     * const categoria_area = await prisma.categoria_area.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Categoria_areaUpdateManyArgs>(args: SelectSubset<T, Categoria_areaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categoria_areas and returns the data updated in the database.
     * @param {Categoria_areaUpdateManyAndReturnArgs} args - Arguments to update many Categoria_areas.
     * @example
     * // Update many Categoria_areas
     * const categoria_area = await prisma.categoria_area.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Categoria_areas and only return the `id`
     * const categoria_areaWithIdOnly = await prisma.categoria_area.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends Categoria_areaUpdateManyAndReturnArgs>(args: SelectSubset<T, Categoria_areaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Categoria_areaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Categoria_area.
     * @param {Categoria_areaUpsertArgs} args - Arguments to update or create a Categoria_area.
     * @example
     * // Update or create a Categoria_area
     * const categoria_area = await prisma.categoria_area.upsert({
     *   create: {
     *     // ... data to create a Categoria_area
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Categoria_area we want to update
     *   }
     * })
     */
    upsert<T extends Categoria_areaUpsertArgs>(args: SelectSubset<T, Categoria_areaUpsertArgs<ExtArgs>>): Prisma__Categoria_areaClient<$Result.GetResult<Prisma.$Categoria_areaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categoria_areas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Categoria_areaCountArgs} args - Arguments to filter Categoria_areas to count.
     * @example
     * // Count the number of Categoria_areas
     * const count = await prisma.categoria_area.count({
     *   where: {
     *     // ... the filter for the Categoria_areas we want to count
     *   }
     * })
    **/
    count<T extends Categoria_areaCountArgs>(
      args?: Subset<T, Categoria_areaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Categoria_areaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Categoria_area.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Categoria_areaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Categoria_areaAggregateArgs>(args: Subset<T, Categoria_areaAggregateArgs>): Prisma.PrismaPromise<GetCategoria_areaAggregateType<T>>

    /**
     * Group by Categoria_area.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Categoria_areaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Categoria_areaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Categoria_areaGroupByArgs['orderBy'] }
        : { orderBy?: Categoria_areaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Categoria_areaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoria_areaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Categoria_area model
   */
  readonly fields: Categoria_areaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Categoria_area.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Categoria_areaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    area<T extends AreaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AreaDefaultArgs<ExtArgs>>): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    categoria<T extends CategoriaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoriaDefaultArgs<ExtArgs>>): Prisma__CategoriaClient<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Categoria_area model
   */
  interface Categoria_areaFieldRefs {
    readonly id: FieldRef<"Categoria_area", 'Int'>
    readonly categoria_id: FieldRef<"Categoria_area", 'Int'>
    readonly area_id: FieldRef<"Categoria_area", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Categoria_area findUnique
   */
  export type Categoria_areaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria_area
     */
    select?: Categoria_areaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categoria_area
     */
    omit?: Categoria_areaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Categoria_areaInclude<ExtArgs> | null
    /**
     * Filter, which Categoria_area to fetch.
     */
    where: Categoria_areaWhereUniqueInput
  }

  /**
   * Categoria_area findUniqueOrThrow
   */
  export type Categoria_areaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria_area
     */
    select?: Categoria_areaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categoria_area
     */
    omit?: Categoria_areaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Categoria_areaInclude<ExtArgs> | null
    /**
     * Filter, which Categoria_area to fetch.
     */
    where: Categoria_areaWhereUniqueInput
  }

  /**
   * Categoria_area findFirst
   */
  export type Categoria_areaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria_area
     */
    select?: Categoria_areaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categoria_area
     */
    omit?: Categoria_areaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Categoria_areaInclude<ExtArgs> | null
    /**
     * Filter, which Categoria_area to fetch.
     */
    where?: Categoria_areaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categoria_areas to fetch.
     */
    orderBy?: Categoria_areaOrderByWithRelationInput | Categoria_areaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categoria_areas.
     */
    cursor?: Categoria_areaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categoria_areas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categoria_areas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categoria_areas.
     */
    distinct?: Categoria_areaScalarFieldEnum | Categoria_areaScalarFieldEnum[]
  }

  /**
   * Categoria_area findFirstOrThrow
   */
  export type Categoria_areaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria_area
     */
    select?: Categoria_areaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categoria_area
     */
    omit?: Categoria_areaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Categoria_areaInclude<ExtArgs> | null
    /**
     * Filter, which Categoria_area to fetch.
     */
    where?: Categoria_areaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categoria_areas to fetch.
     */
    orderBy?: Categoria_areaOrderByWithRelationInput | Categoria_areaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categoria_areas.
     */
    cursor?: Categoria_areaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categoria_areas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categoria_areas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categoria_areas.
     */
    distinct?: Categoria_areaScalarFieldEnum | Categoria_areaScalarFieldEnum[]
  }

  /**
   * Categoria_area findMany
   */
  export type Categoria_areaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria_area
     */
    select?: Categoria_areaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categoria_area
     */
    omit?: Categoria_areaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Categoria_areaInclude<ExtArgs> | null
    /**
     * Filter, which Categoria_areas to fetch.
     */
    where?: Categoria_areaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categoria_areas to fetch.
     */
    orderBy?: Categoria_areaOrderByWithRelationInput | Categoria_areaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categoria_areas.
     */
    cursor?: Categoria_areaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categoria_areas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categoria_areas.
     */
    skip?: number
    distinct?: Categoria_areaScalarFieldEnum | Categoria_areaScalarFieldEnum[]
  }

  /**
   * Categoria_area create
   */
  export type Categoria_areaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria_area
     */
    select?: Categoria_areaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categoria_area
     */
    omit?: Categoria_areaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Categoria_areaInclude<ExtArgs> | null
    /**
     * The data needed to create a Categoria_area.
     */
    data: XOR<Categoria_areaCreateInput, Categoria_areaUncheckedCreateInput>
  }

  /**
   * Categoria_area createMany
   */
  export type Categoria_areaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categoria_areas.
     */
    data: Categoria_areaCreateManyInput | Categoria_areaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Categoria_area createManyAndReturn
   */
  export type Categoria_areaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria_area
     */
    select?: Categoria_areaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Categoria_area
     */
    omit?: Categoria_areaOmit<ExtArgs> | null
    /**
     * The data used to create many Categoria_areas.
     */
    data: Categoria_areaCreateManyInput | Categoria_areaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Categoria_areaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Categoria_area update
   */
  export type Categoria_areaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria_area
     */
    select?: Categoria_areaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categoria_area
     */
    omit?: Categoria_areaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Categoria_areaInclude<ExtArgs> | null
    /**
     * The data needed to update a Categoria_area.
     */
    data: XOR<Categoria_areaUpdateInput, Categoria_areaUncheckedUpdateInput>
    /**
     * Choose, which Categoria_area to update.
     */
    where: Categoria_areaWhereUniqueInput
  }

  /**
   * Categoria_area updateMany
   */
  export type Categoria_areaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categoria_areas.
     */
    data: XOR<Categoria_areaUpdateManyMutationInput, Categoria_areaUncheckedUpdateManyInput>
    /**
     * Filter which Categoria_areas to update
     */
    where?: Categoria_areaWhereInput
    /**
     * Limit how many Categoria_areas to update.
     */
    limit?: number
  }

  /**
   * Categoria_area updateManyAndReturn
   */
  export type Categoria_areaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria_area
     */
    select?: Categoria_areaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Categoria_area
     */
    omit?: Categoria_areaOmit<ExtArgs> | null
    /**
     * The data used to update Categoria_areas.
     */
    data: XOR<Categoria_areaUpdateManyMutationInput, Categoria_areaUncheckedUpdateManyInput>
    /**
     * Filter which Categoria_areas to update
     */
    where?: Categoria_areaWhereInput
    /**
     * Limit how many Categoria_areas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Categoria_areaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Categoria_area upsert
   */
  export type Categoria_areaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria_area
     */
    select?: Categoria_areaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categoria_area
     */
    omit?: Categoria_areaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Categoria_areaInclude<ExtArgs> | null
    /**
     * The filter to search for the Categoria_area to update in case it exists.
     */
    where: Categoria_areaWhereUniqueInput
    /**
     * In case the Categoria_area found by the `where` argument doesn't exist, create a new Categoria_area with this data.
     */
    create: XOR<Categoria_areaCreateInput, Categoria_areaUncheckedCreateInput>
    /**
     * In case the Categoria_area was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Categoria_areaUpdateInput, Categoria_areaUncheckedUpdateInput>
  }

  /**
   * Categoria_area delete
   */
  export type Categoria_areaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria_area
     */
    select?: Categoria_areaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categoria_area
     */
    omit?: Categoria_areaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Categoria_areaInclude<ExtArgs> | null
    /**
     * Filter which Categoria_area to delete.
     */
    where: Categoria_areaWhereUniqueInput
  }

  /**
   * Categoria_area deleteMany
   */
  export type Categoria_areaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categoria_areas to delete
     */
    where?: Categoria_areaWhereInput
    /**
     * Limit how many Categoria_areas to delete.
     */
    limit?: number
  }

  /**
   * Categoria_area without action
   */
  export type Categoria_areaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria_area
     */
    select?: Categoria_areaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categoria_area
     */
    omit?: Categoria_areaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Categoria_areaInclude<ExtArgs> | null
  }


  /**
   * Model Inscripcion_tutor
   */

  export type AggregateInscripcion_tutor = {
    _count: Inscripcion_tutorCountAggregateOutputType | null
    _avg: Inscripcion_tutorAvgAggregateOutputType | null
    _sum: Inscripcion_tutorSumAggregateOutputType | null
    _min: Inscripcion_tutorMinAggregateOutputType | null
    _max: Inscripcion_tutorMaxAggregateOutputType | null
  }

  export type Inscripcion_tutorAvgAggregateOutputType = {
    id: number | null
    inscripcion_id: number | null
    motivo_rechazo_id: number | null
  }

  export type Inscripcion_tutorSumAggregateOutputType = {
    id: number | null
    inscripcion_id: number | null
    motivo_rechazo_id: number | null
  }

  export type Inscripcion_tutorMinAggregateOutputType = {
    id: number | null
    inscripcion_id: number | null
    tutor_id: string | null
    aprobado: boolean | null
    fecha_aprobacion: Date | null
    motivo_rechazo_id: number | null
    descripcion_rechazo: string | null
    competidorId: string | null
  }

  export type Inscripcion_tutorMaxAggregateOutputType = {
    id: number | null
    inscripcion_id: number | null
    tutor_id: string | null
    aprobado: boolean | null
    fecha_aprobacion: Date | null
    motivo_rechazo_id: number | null
    descripcion_rechazo: string | null
    competidorId: string | null
  }

  export type Inscripcion_tutorCountAggregateOutputType = {
    id: number
    inscripcion_id: number
    tutor_id: number
    aprobado: number
    fecha_aprobacion: number
    motivo_rechazo_id: number
    descripcion_rechazo: number
    competidorId: number
    _all: number
  }


  export type Inscripcion_tutorAvgAggregateInputType = {
    id?: true
    inscripcion_id?: true
    motivo_rechazo_id?: true
  }

  export type Inscripcion_tutorSumAggregateInputType = {
    id?: true
    inscripcion_id?: true
    motivo_rechazo_id?: true
  }

  export type Inscripcion_tutorMinAggregateInputType = {
    id?: true
    inscripcion_id?: true
    tutor_id?: true
    aprobado?: true
    fecha_aprobacion?: true
    motivo_rechazo_id?: true
    descripcion_rechazo?: true
    competidorId?: true
  }

  export type Inscripcion_tutorMaxAggregateInputType = {
    id?: true
    inscripcion_id?: true
    tutor_id?: true
    aprobado?: true
    fecha_aprobacion?: true
    motivo_rechazo_id?: true
    descripcion_rechazo?: true
    competidorId?: true
  }

  export type Inscripcion_tutorCountAggregateInputType = {
    id?: true
    inscripcion_id?: true
    tutor_id?: true
    aprobado?: true
    fecha_aprobacion?: true
    motivo_rechazo_id?: true
    descripcion_rechazo?: true
    competidorId?: true
    _all?: true
  }

  export type Inscripcion_tutorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inscripcion_tutor to aggregate.
     */
    where?: Inscripcion_tutorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inscripcion_tutors to fetch.
     */
    orderBy?: Inscripcion_tutorOrderByWithRelationInput | Inscripcion_tutorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Inscripcion_tutorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inscripcion_tutors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inscripcion_tutors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Inscripcion_tutors
    **/
    _count?: true | Inscripcion_tutorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Inscripcion_tutorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Inscripcion_tutorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inscripcion_tutorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inscripcion_tutorMaxAggregateInputType
  }

  export type GetInscripcion_tutorAggregateType<T extends Inscripcion_tutorAggregateArgs> = {
        [P in keyof T & keyof AggregateInscripcion_tutor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInscripcion_tutor[P]>
      : GetScalarType<T[P], AggregateInscripcion_tutor[P]>
  }




  export type Inscripcion_tutorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Inscripcion_tutorWhereInput
    orderBy?: Inscripcion_tutorOrderByWithAggregationInput | Inscripcion_tutorOrderByWithAggregationInput[]
    by: Inscripcion_tutorScalarFieldEnum[] | Inscripcion_tutorScalarFieldEnum
    having?: Inscripcion_tutorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inscripcion_tutorCountAggregateInputType | true
    _avg?: Inscripcion_tutorAvgAggregateInputType
    _sum?: Inscripcion_tutorSumAggregateInputType
    _min?: Inscripcion_tutorMinAggregateInputType
    _max?: Inscripcion_tutorMaxAggregateInputType
  }

  export type Inscripcion_tutorGroupByOutputType = {
    id: number
    inscripcion_id: number
    tutor_id: string
    aprobado: boolean
    fecha_aprobacion: Date | null
    motivo_rechazo_id: number | null
    descripcion_rechazo: string | null
    competidorId: string | null
    _count: Inscripcion_tutorCountAggregateOutputType | null
    _avg: Inscripcion_tutorAvgAggregateOutputType | null
    _sum: Inscripcion_tutorSumAggregateOutputType | null
    _min: Inscripcion_tutorMinAggregateOutputType | null
    _max: Inscripcion_tutorMaxAggregateOutputType | null
  }

  type GetInscripcion_tutorGroupByPayload<T extends Inscripcion_tutorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inscripcion_tutorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inscripcion_tutorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inscripcion_tutorGroupByOutputType[P]>
            : GetScalarType<T[P], Inscripcion_tutorGroupByOutputType[P]>
        }
      >
    >


  export type Inscripcion_tutorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inscripcion_id?: boolean
    tutor_id?: boolean
    aprobado?: boolean
    fecha_aprobacion?: boolean
    motivo_rechazo_id?: boolean
    descripcion_rechazo?: boolean
    competidorId?: boolean
    inscripcion?: boolean | InscripcionDefaultArgs<ExtArgs>
    tutor?: boolean | TutorDefaultArgs<ExtArgs>
    Competidor?: boolean | Inscripcion_tutor$CompetidorArgs<ExtArgs>
    MotivoRechazo?: boolean | Inscripcion_tutor$MotivoRechazoArgs<ExtArgs>
  }, ExtArgs["result"]["inscripcion_tutor"]>

  export type Inscripcion_tutorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inscripcion_id?: boolean
    tutor_id?: boolean
    aprobado?: boolean
    fecha_aprobacion?: boolean
    motivo_rechazo_id?: boolean
    descripcion_rechazo?: boolean
    competidorId?: boolean
    inscripcion?: boolean | InscripcionDefaultArgs<ExtArgs>
    tutor?: boolean | TutorDefaultArgs<ExtArgs>
    Competidor?: boolean | Inscripcion_tutor$CompetidorArgs<ExtArgs>
    MotivoRechazo?: boolean | Inscripcion_tutor$MotivoRechazoArgs<ExtArgs>
  }, ExtArgs["result"]["inscripcion_tutor"]>

  export type Inscripcion_tutorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inscripcion_id?: boolean
    tutor_id?: boolean
    aprobado?: boolean
    fecha_aprobacion?: boolean
    motivo_rechazo_id?: boolean
    descripcion_rechazo?: boolean
    competidorId?: boolean
    inscripcion?: boolean | InscripcionDefaultArgs<ExtArgs>
    tutor?: boolean | TutorDefaultArgs<ExtArgs>
    Competidor?: boolean | Inscripcion_tutor$CompetidorArgs<ExtArgs>
    MotivoRechazo?: boolean | Inscripcion_tutor$MotivoRechazoArgs<ExtArgs>
  }, ExtArgs["result"]["inscripcion_tutor"]>

  export type Inscripcion_tutorSelectScalar = {
    id?: boolean
    inscripcion_id?: boolean
    tutor_id?: boolean
    aprobado?: boolean
    fecha_aprobacion?: boolean
    motivo_rechazo_id?: boolean
    descripcion_rechazo?: boolean
    competidorId?: boolean
  }

  export type Inscripcion_tutorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "inscripcion_id" | "tutor_id" | "aprobado" | "fecha_aprobacion" | "motivo_rechazo_id" | "descripcion_rechazo" | "competidorId", ExtArgs["result"]["inscripcion_tutor"]>
  export type Inscripcion_tutorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inscripcion?: boolean | InscripcionDefaultArgs<ExtArgs>
    tutor?: boolean | TutorDefaultArgs<ExtArgs>
    Competidor?: boolean | Inscripcion_tutor$CompetidorArgs<ExtArgs>
    MotivoRechazo?: boolean | Inscripcion_tutor$MotivoRechazoArgs<ExtArgs>
  }
  export type Inscripcion_tutorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inscripcion?: boolean | InscripcionDefaultArgs<ExtArgs>
    tutor?: boolean | TutorDefaultArgs<ExtArgs>
    Competidor?: boolean | Inscripcion_tutor$CompetidorArgs<ExtArgs>
    MotivoRechazo?: boolean | Inscripcion_tutor$MotivoRechazoArgs<ExtArgs>
  }
  export type Inscripcion_tutorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inscripcion?: boolean | InscripcionDefaultArgs<ExtArgs>
    tutor?: boolean | TutorDefaultArgs<ExtArgs>
    Competidor?: boolean | Inscripcion_tutor$CompetidorArgs<ExtArgs>
    MotivoRechazo?: boolean | Inscripcion_tutor$MotivoRechazoArgs<ExtArgs>
  }

  export type $Inscripcion_tutorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Inscripcion_tutor"
    objects: {
      inscripcion: Prisma.$InscripcionPayload<ExtArgs>
      tutor: Prisma.$TutorPayload<ExtArgs>
      Competidor: Prisma.$CompetidorPayload<ExtArgs> | null
      MotivoRechazo: Prisma.$Motivo_rechazoPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      inscripcion_id: number
      tutor_id: string
      aprobado: boolean
      fecha_aprobacion: Date | null
      motivo_rechazo_id: number | null
      descripcion_rechazo: string | null
      competidorId: string | null
    }, ExtArgs["result"]["inscripcion_tutor"]>
    composites: {}
  }

  type Inscripcion_tutorGetPayload<S extends boolean | null | undefined | Inscripcion_tutorDefaultArgs> = $Result.GetResult<Prisma.$Inscripcion_tutorPayload, S>

  type Inscripcion_tutorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Inscripcion_tutorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Inscripcion_tutorCountAggregateInputType | true
    }

  export interface Inscripcion_tutorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Inscripcion_tutor'], meta: { name: 'Inscripcion_tutor' } }
    /**
     * Find zero or one Inscripcion_tutor that matches the filter.
     * @param {Inscripcion_tutorFindUniqueArgs} args - Arguments to find a Inscripcion_tutor
     * @example
     * // Get one Inscripcion_tutor
     * const inscripcion_tutor = await prisma.inscripcion_tutor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Inscripcion_tutorFindUniqueArgs>(args: SelectSubset<T, Inscripcion_tutorFindUniqueArgs<ExtArgs>>): Prisma__Inscripcion_tutorClient<$Result.GetResult<Prisma.$Inscripcion_tutorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Inscripcion_tutor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Inscripcion_tutorFindUniqueOrThrowArgs} args - Arguments to find a Inscripcion_tutor
     * @example
     * // Get one Inscripcion_tutor
     * const inscripcion_tutor = await prisma.inscripcion_tutor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Inscripcion_tutorFindUniqueOrThrowArgs>(args: SelectSubset<T, Inscripcion_tutorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Inscripcion_tutorClient<$Result.GetResult<Prisma.$Inscripcion_tutorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Inscripcion_tutor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inscripcion_tutorFindFirstArgs} args - Arguments to find a Inscripcion_tutor
     * @example
     * // Get one Inscripcion_tutor
     * const inscripcion_tutor = await prisma.inscripcion_tutor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Inscripcion_tutorFindFirstArgs>(args?: SelectSubset<T, Inscripcion_tutorFindFirstArgs<ExtArgs>>): Prisma__Inscripcion_tutorClient<$Result.GetResult<Prisma.$Inscripcion_tutorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Inscripcion_tutor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inscripcion_tutorFindFirstOrThrowArgs} args - Arguments to find a Inscripcion_tutor
     * @example
     * // Get one Inscripcion_tutor
     * const inscripcion_tutor = await prisma.inscripcion_tutor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Inscripcion_tutorFindFirstOrThrowArgs>(args?: SelectSubset<T, Inscripcion_tutorFindFirstOrThrowArgs<ExtArgs>>): Prisma__Inscripcion_tutorClient<$Result.GetResult<Prisma.$Inscripcion_tutorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Inscripcion_tutors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inscripcion_tutorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inscripcion_tutors
     * const inscripcion_tutors = await prisma.inscripcion_tutor.findMany()
     * 
     * // Get first 10 Inscripcion_tutors
     * const inscripcion_tutors = await prisma.inscripcion_tutor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inscripcion_tutorWithIdOnly = await prisma.inscripcion_tutor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Inscripcion_tutorFindManyArgs>(args?: SelectSubset<T, Inscripcion_tutorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Inscripcion_tutorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Inscripcion_tutor.
     * @param {Inscripcion_tutorCreateArgs} args - Arguments to create a Inscripcion_tutor.
     * @example
     * // Create one Inscripcion_tutor
     * const Inscripcion_tutor = await prisma.inscripcion_tutor.create({
     *   data: {
     *     // ... data to create a Inscripcion_tutor
     *   }
     * })
     * 
     */
    create<T extends Inscripcion_tutorCreateArgs>(args: SelectSubset<T, Inscripcion_tutorCreateArgs<ExtArgs>>): Prisma__Inscripcion_tutorClient<$Result.GetResult<Prisma.$Inscripcion_tutorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Inscripcion_tutors.
     * @param {Inscripcion_tutorCreateManyArgs} args - Arguments to create many Inscripcion_tutors.
     * @example
     * // Create many Inscripcion_tutors
     * const inscripcion_tutor = await prisma.inscripcion_tutor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Inscripcion_tutorCreateManyArgs>(args?: SelectSubset<T, Inscripcion_tutorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Inscripcion_tutors and returns the data saved in the database.
     * @param {Inscripcion_tutorCreateManyAndReturnArgs} args - Arguments to create many Inscripcion_tutors.
     * @example
     * // Create many Inscripcion_tutors
     * const inscripcion_tutor = await prisma.inscripcion_tutor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Inscripcion_tutors and only return the `id`
     * const inscripcion_tutorWithIdOnly = await prisma.inscripcion_tutor.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Inscripcion_tutorCreateManyAndReturnArgs>(args?: SelectSubset<T, Inscripcion_tutorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Inscripcion_tutorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Inscripcion_tutor.
     * @param {Inscripcion_tutorDeleteArgs} args - Arguments to delete one Inscripcion_tutor.
     * @example
     * // Delete one Inscripcion_tutor
     * const Inscripcion_tutor = await prisma.inscripcion_tutor.delete({
     *   where: {
     *     // ... filter to delete one Inscripcion_tutor
     *   }
     * })
     * 
     */
    delete<T extends Inscripcion_tutorDeleteArgs>(args: SelectSubset<T, Inscripcion_tutorDeleteArgs<ExtArgs>>): Prisma__Inscripcion_tutorClient<$Result.GetResult<Prisma.$Inscripcion_tutorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Inscripcion_tutor.
     * @param {Inscripcion_tutorUpdateArgs} args - Arguments to update one Inscripcion_tutor.
     * @example
     * // Update one Inscripcion_tutor
     * const inscripcion_tutor = await prisma.inscripcion_tutor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Inscripcion_tutorUpdateArgs>(args: SelectSubset<T, Inscripcion_tutorUpdateArgs<ExtArgs>>): Prisma__Inscripcion_tutorClient<$Result.GetResult<Prisma.$Inscripcion_tutorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Inscripcion_tutors.
     * @param {Inscripcion_tutorDeleteManyArgs} args - Arguments to filter Inscripcion_tutors to delete.
     * @example
     * // Delete a few Inscripcion_tutors
     * const { count } = await prisma.inscripcion_tutor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Inscripcion_tutorDeleteManyArgs>(args?: SelectSubset<T, Inscripcion_tutorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inscripcion_tutors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inscripcion_tutorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inscripcion_tutors
     * const inscripcion_tutor = await prisma.inscripcion_tutor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Inscripcion_tutorUpdateManyArgs>(args: SelectSubset<T, Inscripcion_tutorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inscripcion_tutors and returns the data updated in the database.
     * @param {Inscripcion_tutorUpdateManyAndReturnArgs} args - Arguments to update many Inscripcion_tutors.
     * @example
     * // Update many Inscripcion_tutors
     * const inscripcion_tutor = await prisma.inscripcion_tutor.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Inscripcion_tutors and only return the `id`
     * const inscripcion_tutorWithIdOnly = await prisma.inscripcion_tutor.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends Inscripcion_tutorUpdateManyAndReturnArgs>(args: SelectSubset<T, Inscripcion_tutorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Inscripcion_tutorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Inscripcion_tutor.
     * @param {Inscripcion_tutorUpsertArgs} args - Arguments to update or create a Inscripcion_tutor.
     * @example
     * // Update or create a Inscripcion_tutor
     * const inscripcion_tutor = await prisma.inscripcion_tutor.upsert({
     *   create: {
     *     // ... data to create a Inscripcion_tutor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inscripcion_tutor we want to update
     *   }
     * })
     */
    upsert<T extends Inscripcion_tutorUpsertArgs>(args: SelectSubset<T, Inscripcion_tutorUpsertArgs<ExtArgs>>): Prisma__Inscripcion_tutorClient<$Result.GetResult<Prisma.$Inscripcion_tutorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Inscripcion_tutors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inscripcion_tutorCountArgs} args - Arguments to filter Inscripcion_tutors to count.
     * @example
     * // Count the number of Inscripcion_tutors
     * const count = await prisma.inscripcion_tutor.count({
     *   where: {
     *     // ... the filter for the Inscripcion_tutors we want to count
     *   }
     * })
    **/
    count<T extends Inscripcion_tutorCountArgs>(
      args?: Subset<T, Inscripcion_tutorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inscripcion_tutorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inscripcion_tutor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inscripcion_tutorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inscripcion_tutorAggregateArgs>(args: Subset<T, Inscripcion_tutorAggregateArgs>): Prisma.PrismaPromise<GetInscripcion_tutorAggregateType<T>>

    /**
     * Group by Inscripcion_tutor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inscripcion_tutorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Inscripcion_tutorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Inscripcion_tutorGroupByArgs['orderBy'] }
        : { orderBy?: Inscripcion_tutorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Inscripcion_tutorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInscripcion_tutorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Inscripcion_tutor model
   */
  readonly fields: Inscripcion_tutorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Inscripcion_tutor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Inscripcion_tutorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    inscripcion<T extends InscripcionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InscripcionDefaultArgs<ExtArgs>>): Prisma__InscripcionClient<$Result.GetResult<Prisma.$InscripcionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tutor<T extends TutorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TutorDefaultArgs<ExtArgs>>): Prisma__TutorClient<$Result.GetResult<Prisma.$TutorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Competidor<T extends Inscripcion_tutor$CompetidorArgs<ExtArgs> = {}>(args?: Subset<T, Inscripcion_tutor$CompetidorArgs<ExtArgs>>): Prisma__CompetidorClient<$Result.GetResult<Prisma.$CompetidorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    MotivoRechazo<T extends Inscripcion_tutor$MotivoRechazoArgs<ExtArgs> = {}>(args?: Subset<T, Inscripcion_tutor$MotivoRechazoArgs<ExtArgs>>): Prisma__Motivo_rechazoClient<$Result.GetResult<Prisma.$Motivo_rechazoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Inscripcion_tutor model
   */
  interface Inscripcion_tutorFieldRefs {
    readonly id: FieldRef<"Inscripcion_tutor", 'Int'>
    readonly inscripcion_id: FieldRef<"Inscripcion_tutor", 'Int'>
    readonly tutor_id: FieldRef<"Inscripcion_tutor", 'String'>
    readonly aprobado: FieldRef<"Inscripcion_tutor", 'Boolean'>
    readonly fecha_aprobacion: FieldRef<"Inscripcion_tutor", 'DateTime'>
    readonly motivo_rechazo_id: FieldRef<"Inscripcion_tutor", 'Int'>
    readonly descripcion_rechazo: FieldRef<"Inscripcion_tutor", 'String'>
    readonly competidorId: FieldRef<"Inscripcion_tutor", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Inscripcion_tutor findUnique
   */
  export type Inscripcion_tutorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inscripcion_tutor
     */
    select?: Inscripcion_tutorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inscripcion_tutor
     */
    omit?: Inscripcion_tutorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Inscripcion_tutorInclude<ExtArgs> | null
    /**
     * Filter, which Inscripcion_tutor to fetch.
     */
    where: Inscripcion_tutorWhereUniqueInput
  }

  /**
   * Inscripcion_tutor findUniqueOrThrow
   */
  export type Inscripcion_tutorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inscripcion_tutor
     */
    select?: Inscripcion_tutorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inscripcion_tutor
     */
    omit?: Inscripcion_tutorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Inscripcion_tutorInclude<ExtArgs> | null
    /**
     * Filter, which Inscripcion_tutor to fetch.
     */
    where: Inscripcion_tutorWhereUniqueInput
  }

  /**
   * Inscripcion_tutor findFirst
   */
  export type Inscripcion_tutorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inscripcion_tutor
     */
    select?: Inscripcion_tutorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inscripcion_tutor
     */
    omit?: Inscripcion_tutorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Inscripcion_tutorInclude<ExtArgs> | null
    /**
     * Filter, which Inscripcion_tutor to fetch.
     */
    where?: Inscripcion_tutorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inscripcion_tutors to fetch.
     */
    orderBy?: Inscripcion_tutorOrderByWithRelationInput | Inscripcion_tutorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inscripcion_tutors.
     */
    cursor?: Inscripcion_tutorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inscripcion_tutors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inscripcion_tutors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inscripcion_tutors.
     */
    distinct?: Inscripcion_tutorScalarFieldEnum | Inscripcion_tutorScalarFieldEnum[]
  }

  /**
   * Inscripcion_tutor findFirstOrThrow
   */
  export type Inscripcion_tutorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inscripcion_tutor
     */
    select?: Inscripcion_tutorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inscripcion_tutor
     */
    omit?: Inscripcion_tutorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Inscripcion_tutorInclude<ExtArgs> | null
    /**
     * Filter, which Inscripcion_tutor to fetch.
     */
    where?: Inscripcion_tutorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inscripcion_tutors to fetch.
     */
    orderBy?: Inscripcion_tutorOrderByWithRelationInput | Inscripcion_tutorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inscripcion_tutors.
     */
    cursor?: Inscripcion_tutorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inscripcion_tutors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inscripcion_tutors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inscripcion_tutors.
     */
    distinct?: Inscripcion_tutorScalarFieldEnum | Inscripcion_tutorScalarFieldEnum[]
  }

  /**
   * Inscripcion_tutor findMany
   */
  export type Inscripcion_tutorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inscripcion_tutor
     */
    select?: Inscripcion_tutorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inscripcion_tutor
     */
    omit?: Inscripcion_tutorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Inscripcion_tutorInclude<ExtArgs> | null
    /**
     * Filter, which Inscripcion_tutors to fetch.
     */
    where?: Inscripcion_tutorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inscripcion_tutors to fetch.
     */
    orderBy?: Inscripcion_tutorOrderByWithRelationInput | Inscripcion_tutorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Inscripcion_tutors.
     */
    cursor?: Inscripcion_tutorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inscripcion_tutors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inscripcion_tutors.
     */
    skip?: number
    distinct?: Inscripcion_tutorScalarFieldEnum | Inscripcion_tutorScalarFieldEnum[]
  }

  /**
   * Inscripcion_tutor create
   */
  export type Inscripcion_tutorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inscripcion_tutor
     */
    select?: Inscripcion_tutorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inscripcion_tutor
     */
    omit?: Inscripcion_tutorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Inscripcion_tutorInclude<ExtArgs> | null
    /**
     * The data needed to create a Inscripcion_tutor.
     */
    data: XOR<Inscripcion_tutorCreateInput, Inscripcion_tutorUncheckedCreateInput>
  }

  /**
   * Inscripcion_tutor createMany
   */
  export type Inscripcion_tutorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Inscripcion_tutors.
     */
    data: Inscripcion_tutorCreateManyInput | Inscripcion_tutorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Inscripcion_tutor createManyAndReturn
   */
  export type Inscripcion_tutorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inscripcion_tutor
     */
    select?: Inscripcion_tutorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Inscripcion_tutor
     */
    omit?: Inscripcion_tutorOmit<ExtArgs> | null
    /**
     * The data used to create many Inscripcion_tutors.
     */
    data: Inscripcion_tutorCreateManyInput | Inscripcion_tutorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Inscripcion_tutorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Inscripcion_tutor update
   */
  export type Inscripcion_tutorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inscripcion_tutor
     */
    select?: Inscripcion_tutorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inscripcion_tutor
     */
    omit?: Inscripcion_tutorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Inscripcion_tutorInclude<ExtArgs> | null
    /**
     * The data needed to update a Inscripcion_tutor.
     */
    data: XOR<Inscripcion_tutorUpdateInput, Inscripcion_tutorUncheckedUpdateInput>
    /**
     * Choose, which Inscripcion_tutor to update.
     */
    where: Inscripcion_tutorWhereUniqueInput
  }

  /**
   * Inscripcion_tutor updateMany
   */
  export type Inscripcion_tutorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Inscripcion_tutors.
     */
    data: XOR<Inscripcion_tutorUpdateManyMutationInput, Inscripcion_tutorUncheckedUpdateManyInput>
    /**
     * Filter which Inscripcion_tutors to update
     */
    where?: Inscripcion_tutorWhereInput
    /**
     * Limit how many Inscripcion_tutors to update.
     */
    limit?: number
  }

  /**
   * Inscripcion_tutor updateManyAndReturn
   */
  export type Inscripcion_tutorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inscripcion_tutor
     */
    select?: Inscripcion_tutorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Inscripcion_tutor
     */
    omit?: Inscripcion_tutorOmit<ExtArgs> | null
    /**
     * The data used to update Inscripcion_tutors.
     */
    data: XOR<Inscripcion_tutorUpdateManyMutationInput, Inscripcion_tutorUncheckedUpdateManyInput>
    /**
     * Filter which Inscripcion_tutors to update
     */
    where?: Inscripcion_tutorWhereInput
    /**
     * Limit how many Inscripcion_tutors to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Inscripcion_tutorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Inscripcion_tutor upsert
   */
  export type Inscripcion_tutorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inscripcion_tutor
     */
    select?: Inscripcion_tutorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inscripcion_tutor
     */
    omit?: Inscripcion_tutorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Inscripcion_tutorInclude<ExtArgs> | null
    /**
     * The filter to search for the Inscripcion_tutor to update in case it exists.
     */
    where: Inscripcion_tutorWhereUniqueInput
    /**
     * In case the Inscripcion_tutor found by the `where` argument doesn't exist, create a new Inscripcion_tutor with this data.
     */
    create: XOR<Inscripcion_tutorCreateInput, Inscripcion_tutorUncheckedCreateInput>
    /**
     * In case the Inscripcion_tutor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Inscripcion_tutorUpdateInput, Inscripcion_tutorUncheckedUpdateInput>
  }

  /**
   * Inscripcion_tutor delete
   */
  export type Inscripcion_tutorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inscripcion_tutor
     */
    select?: Inscripcion_tutorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inscripcion_tutor
     */
    omit?: Inscripcion_tutorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Inscripcion_tutorInclude<ExtArgs> | null
    /**
     * Filter which Inscripcion_tutor to delete.
     */
    where: Inscripcion_tutorWhereUniqueInput
  }

  /**
   * Inscripcion_tutor deleteMany
   */
  export type Inscripcion_tutorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inscripcion_tutors to delete
     */
    where?: Inscripcion_tutorWhereInput
    /**
     * Limit how many Inscripcion_tutors to delete.
     */
    limit?: number
  }

  /**
   * Inscripcion_tutor.Competidor
   */
  export type Inscripcion_tutor$CompetidorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Competidor
     */
    select?: CompetidorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Competidor
     */
    omit?: CompetidorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompetidorInclude<ExtArgs> | null
    where?: CompetidorWhereInput
  }

  /**
   * Inscripcion_tutor.MotivoRechazo
   */
  export type Inscripcion_tutor$MotivoRechazoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Motivo_rechazo
     */
    select?: Motivo_rechazoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Motivo_rechazo
     */
    omit?: Motivo_rechazoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Motivo_rechazoInclude<ExtArgs> | null
    where?: Motivo_rechazoWhereInput
  }

  /**
   * Inscripcion_tutor without action
   */
  export type Inscripcion_tutorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inscripcion_tutor
     */
    select?: Inscripcion_tutorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inscripcion_tutor
     */
    omit?: Inscripcion_tutorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Inscripcion_tutorInclude<ExtArgs> | null
  }


  /**
   * Model Metodo_pago
   */

  export type AggregateMetodo_pago = {
    _count: Metodo_pagoCountAggregateOutputType | null
    _avg: Metodo_pagoAvgAggregateOutputType | null
    _sum: Metodo_pagoSumAggregateOutputType | null
    _min: Metodo_pagoMinAggregateOutputType | null
    _max: Metodo_pagoMaxAggregateOutputType | null
  }

  export type Metodo_pagoAvgAggregateOutputType = {
    id: number | null
  }

  export type Metodo_pagoSumAggregateOutputType = {
    id: number | null
  }

  export type Metodo_pagoMinAggregateOutputType = {
    id: number | null
    nombre: string | null
  }

  export type Metodo_pagoMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
  }

  export type Metodo_pagoCountAggregateOutputType = {
    id: number
    nombre: number
    _all: number
  }


  export type Metodo_pagoAvgAggregateInputType = {
    id?: true
  }

  export type Metodo_pagoSumAggregateInputType = {
    id?: true
  }

  export type Metodo_pagoMinAggregateInputType = {
    id?: true
    nombre?: true
  }

  export type Metodo_pagoMaxAggregateInputType = {
    id?: true
    nombre?: true
  }

  export type Metodo_pagoCountAggregateInputType = {
    id?: true
    nombre?: true
    _all?: true
  }

  export type Metodo_pagoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Metodo_pago to aggregate.
     */
    where?: Metodo_pagoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Metodo_pagos to fetch.
     */
    orderBy?: Metodo_pagoOrderByWithRelationInput | Metodo_pagoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Metodo_pagoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Metodo_pagos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Metodo_pagos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Metodo_pagos
    **/
    _count?: true | Metodo_pagoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Metodo_pagoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Metodo_pagoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Metodo_pagoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Metodo_pagoMaxAggregateInputType
  }

  export type GetMetodo_pagoAggregateType<T extends Metodo_pagoAggregateArgs> = {
        [P in keyof T & keyof AggregateMetodo_pago]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMetodo_pago[P]>
      : GetScalarType<T[P], AggregateMetodo_pago[P]>
  }




  export type Metodo_pagoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Metodo_pagoWhereInput
    orderBy?: Metodo_pagoOrderByWithAggregationInput | Metodo_pagoOrderByWithAggregationInput[]
    by: Metodo_pagoScalarFieldEnum[] | Metodo_pagoScalarFieldEnum
    having?: Metodo_pagoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Metodo_pagoCountAggregateInputType | true
    _avg?: Metodo_pagoAvgAggregateInputType
    _sum?: Metodo_pagoSumAggregateInputType
    _min?: Metodo_pagoMinAggregateInputType
    _max?: Metodo_pagoMaxAggregateInputType
  }

  export type Metodo_pagoGroupByOutputType = {
    id: number
    nombre: string
    _count: Metodo_pagoCountAggregateOutputType | null
    _avg: Metodo_pagoAvgAggregateOutputType | null
    _sum: Metodo_pagoSumAggregateOutputType | null
    _min: Metodo_pagoMinAggregateOutputType | null
    _max: Metodo_pagoMaxAggregateOutputType | null
  }

  type GetMetodo_pagoGroupByPayload<T extends Metodo_pagoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Metodo_pagoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Metodo_pagoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Metodo_pagoGroupByOutputType[P]>
            : GetScalarType<T[P], Metodo_pagoGroupByOutputType[P]>
        }
      >
    >


  export type Metodo_pagoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    Pago?: boolean | Metodo_pago$PagoArgs<ExtArgs>
    _count?: boolean | Metodo_pagoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["metodo_pago"]>

  export type Metodo_pagoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
  }, ExtArgs["result"]["metodo_pago"]>

  export type Metodo_pagoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
  }, ExtArgs["result"]["metodo_pago"]>

  export type Metodo_pagoSelectScalar = {
    id?: boolean
    nombre?: boolean
  }

  export type Metodo_pagoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nombre", ExtArgs["result"]["metodo_pago"]>
  export type Metodo_pagoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Pago?: boolean | Metodo_pago$PagoArgs<ExtArgs>
    _count?: boolean | Metodo_pagoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type Metodo_pagoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type Metodo_pagoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $Metodo_pagoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Metodo_pago"
    objects: {
      Pago: Prisma.$PagoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string
    }, ExtArgs["result"]["metodo_pago"]>
    composites: {}
  }

  type Metodo_pagoGetPayload<S extends boolean | null | undefined | Metodo_pagoDefaultArgs> = $Result.GetResult<Prisma.$Metodo_pagoPayload, S>

  type Metodo_pagoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Metodo_pagoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Metodo_pagoCountAggregateInputType | true
    }

  export interface Metodo_pagoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Metodo_pago'], meta: { name: 'Metodo_pago' } }
    /**
     * Find zero or one Metodo_pago that matches the filter.
     * @param {Metodo_pagoFindUniqueArgs} args - Arguments to find a Metodo_pago
     * @example
     * // Get one Metodo_pago
     * const metodo_pago = await prisma.metodo_pago.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Metodo_pagoFindUniqueArgs>(args: SelectSubset<T, Metodo_pagoFindUniqueArgs<ExtArgs>>): Prisma__Metodo_pagoClient<$Result.GetResult<Prisma.$Metodo_pagoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Metodo_pago that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Metodo_pagoFindUniqueOrThrowArgs} args - Arguments to find a Metodo_pago
     * @example
     * // Get one Metodo_pago
     * const metodo_pago = await prisma.metodo_pago.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Metodo_pagoFindUniqueOrThrowArgs>(args: SelectSubset<T, Metodo_pagoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Metodo_pagoClient<$Result.GetResult<Prisma.$Metodo_pagoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Metodo_pago that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Metodo_pagoFindFirstArgs} args - Arguments to find a Metodo_pago
     * @example
     * // Get one Metodo_pago
     * const metodo_pago = await prisma.metodo_pago.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Metodo_pagoFindFirstArgs>(args?: SelectSubset<T, Metodo_pagoFindFirstArgs<ExtArgs>>): Prisma__Metodo_pagoClient<$Result.GetResult<Prisma.$Metodo_pagoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Metodo_pago that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Metodo_pagoFindFirstOrThrowArgs} args - Arguments to find a Metodo_pago
     * @example
     * // Get one Metodo_pago
     * const metodo_pago = await prisma.metodo_pago.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Metodo_pagoFindFirstOrThrowArgs>(args?: SelectSubset<T, Metodo_pagoFindFirstOrThrowArgs<ExtArgs>>): Prisma__Metodo_pagoClient<$Result.GetResult<Prisma.$Metodo_pagoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Metodo_pagos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Metodo_pagoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Metodo_pagos
     * const metodo_pagos = await prisma.metodo_pago.findMany()
     * 
     * // Get first 10 Metodo_pagos
     * const metodo_pagos = await prisma.metodo_pago.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const metodo_pagoWithIdOnly = await prisma.metodo_pago.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Metodo_pagoFindManyArgs>(args?: SelectSubset<T, Metodo_pagoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Metodo_pagoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Metodo_pago.
     * @param {Metodo_pagoCreateArgs} args - Arguments to create a Metodo_pago.
     * @example
     * // Create one Metodo_pago
     * const Metodo_pago = await prisma.metodo_pago.create({
     *   data: {
     *     // ... data to create a Metodo_pago
     *   }
     * })
     * 
     */
    create<T extends Metodo_pagoCreateArgs>(args: SelectSubset<T, Metodo_pagoCreateArgs<ExtArgs>>): Prisma__Metodo_pagoClient<$Result.GetResult<Prisma.$Metodo_pagoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Metodo_pagos.
     * @param {Metodo_pagoCreateManyArgs} args - Arguments to create many Metodo_pagos.
     * @example
     * // Create many Metodo_pagos
     * const metodo_pago = await prisma.metodo_pago.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Metodo_pagoCreateManyArgs>(args?: SelectSubset<T, Metodo_pagoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Metodo_pagos and returns the data saved in the database.
     * @param {Metodo_pagoCreateManyAndReturnArgs} args - Arguments to create many Metodo_pagos.
     * @example
     * // Create many Metodo_pagos
     * const metodo_pago = await prisma.metodo_pago.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Metodo_pagos and only return the `id`
     * const metodo_pagoWithIdOnly = await prisma.metodo_pago.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Metodo_pagoCreateManyAndReturnArgs>(args?: SelectSubset<T, Metodo_pagoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Metodo_pagoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Metodo_pago.
     * @param {Metodo_pagoDeleteArgs} args - Arguments to delete one Metodo_pago.
     * @example
     * // Delete one Metodo_pago
     * const Metodo_pago = await prisma.metodo_pago.delete({
     *   where: {
     *     // ... filter to delete one Metodo_pago
     *   }
     * })
     * 
     */
    delete<T extends Metodo_pagoDeleteArgs>(args: SelectSubset<T, Metodo_pagoDeleteArgs<ExtArgs>>): Prisma__Metodo_pagoClient<$Result.GetResult<Prisma.$Metodo_pagoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Metodo_pago.
     * @param {Metodo_pagoUpdateArgs} args - Arguments to update one Metodo_pago.
     * @example
     * // Update one Metodo_pago
     * const metodo_pago = await prisma.metodo_pago.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Metodo_pagoUpdateArgs>(args: SelectSubset<T, Metodo_pagoUpdateArgs<ExtArgs>>): Prisma__Metodo_pagoClient<$Result.GetResult<Prisma.$Metodo_pagoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Metodo_pagos.
     * @param {Metodo_pagoDeleteManyArgs} args - Arguments to filter Metodo_pagos to delete.
     * @example
     * // Delete a few Metodo_pagos
     * const { count } = await prisma.metodo_pago.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Metodo_pagoDeleteManyArgs>(args?: SelectSubset<T, Metodo_pagoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Metodo_pagos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Metodo_pagoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Metodo_pagos
     * const metodo_pago = await prisma.metodo_pago.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Metodo_pagoUpdateManyArgs>(args: SelectSubset<T, Metodo_pagoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Metodo_pagos and returns the data updated in the database.
     * @param {Metodo_pagoUpdateManyAndReturnArgs} args - Arguments to update many Metodo_pagos.
     * @example
     * // Update many Metodo_pagos
     * const metodo_pago = await prisma.metodo_pago.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Metodo_pagos and only return the `id`
     * const metodo_pagoWithIdOnly = await prisma.metodo_pago.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends Metodo_pagoUpdateManyAndReturnArgs>(args: SelectSubset<T, Metodo_pagoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Metodo_pagoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Metodo_pago.
     * @param {Metodo_pagoUpsertArgs} args - Arguments to update or create a Metodo_pago.
     * @example
     * // Update or create a Metodo_pago
     * const metodo_pago = await prisma.metodo_pago.upsert({
     *   create: {
     *     // ... data to create a Metodo_pago
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Metodo_pago we want to update
     *   }
     * })
     */
    upsert<T extends Metodo_pagoUpsertArgs>(args: SelectSubset<T, Metodo_pagoUpsertArgs<ExtArgs>>): Prisma__Metodo_pagoClient<$Result.GetResult<Prisma.$Metodo_pagoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Metodo_pagos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Metodo_pagoCountArgs} args - Arguments to filter Metodo_pagos to count.
     * @example
     * // Count the number of Metodo_pagos
     * const count = await prisma.metodo_pago.count({
     *   where: {
     *     // ... the filter for the Metodo_pagos we want to count
     *   }
     * })
    **/
    count<T extends Metodo_pagoCountArgs>(
      args?: Subset<T, Metodo_pagoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Metodo_pagoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Metodo_pago.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Metodo_pagoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Metodo_pagoAggregateArgs>(args: Subset<T, Metodo_pagoAggregateArgs>): Prisma.PrismaPromise<GetMetodo_pagoAggregateType<T>>

    /**
     * Group by Metodo_pago.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Metodo_pagoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Metodo_pagoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Metodo_pagoGroupByArgs['orderBy'] }
        : { orderBy?: Metodo_pagoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Metodo_pagoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMetodo_pagoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Metodo_pago model
   */
  readonly fields: Metodo_pagoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Metodo_pago.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Metodo_pagoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Pago<T extends Metodo_pago$PagoArgs<ExtArgs> = {}>(args?: Subset<T, Metodo_pago$PagoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Metodo_pago model
   */
  interface Metodo_pagoFieldRefs {
    readonly id: FieldRef<"Metodo_pago", 'Int'>
    readonly nombre: FieldRef<"Metodo_pago", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Metodo_pago findUnique
   */
  export type Metodo_pagoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metodo_pago
     */
    select?: Metodo_pagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Metodo_pago
     */
    omit?: Metodo_pagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Metodo_pagoInclude<ExtArgs> | null
    /**
     * Filter, which Metodo_pago to fetch.
     */
    where: Metodo_pagoWhereUniqueInput
  }

  /**
   * Metodo_pago findUniqueOrThrow
   */
  export type Metodo_pagoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metodo_pago
     */
    select?: Metodo_pagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Metodo_pago
     */
    omit?: Metodo_pagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Metodo_pagoInclude<ExtArgs> | null
    /**
     * Filter, which Metodo_pago to fetch.
     */
    where: Metodo_pagoWhereUniqueInput
  }

  /**
   * Metodo_pago findFirst
   */
  export type Metodo_pagoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metodo_pago
     */
    select?: Metodo_pagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Metodo_pago
     */
    omit?: Metodo_pagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Metodo_pagoInclude<ExtArgs> | null
    /**
     * Filter, which Metodo_pago to fetch.
     */
    where?: Metodo_pagoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Metodo_pagos to fetch.
     */
    orderBy?: Metodo_pagoOrderByWithRelationInput | Metodo_pagoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Metodo_pagos.
     */
    cursor?: Metodo_pagoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Metodo_pagos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Metodo_pagos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Metodo_pagos.
     */
    distinct?: Metodo_pagoScalarFieldEnum | Metodo_pagoScalarFieldEnum[]
  }

  /**
   * Metodo_pago findFirstOrThrow
   */
  export type Metodo_pagoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metodo_pago
     */
    select?: Metodo_pagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Metodo_pago
     */
    omit?: Metodo_pagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Metodo_pagoInclude<ExtArgs> | null
    /**
     * Filter, which Metodo_pago to fetch.
     */
    where?: Metodo_pagoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Metodo_pagos to fetch.
     */
    orderBy?: Metodo_pagoOrderByWithRelationInput | Metodo_pagoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Metodo_pagos.
     */
    cursor?: Metodo_pagoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Metodo_pagos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Metodo_pagos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Metodo_pagos.
     */
    distinct?: Metodo_pagoScalarFieldEnum | Metodo_pagoScalarFieldEnum[]
  }

  /**
   * Metodo_pago findMany
   */
  export type Metodo_pagoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metodo_pago
     */
    select?: Metodo_pagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Metodo_pago
     */
    omit?: Metodo_pagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Metodo_pagoInclude<ExtArgs> | null
    /**
     * Filter, which Metodo_pagos to fetch.
     */
    where?: Metodo_pagoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Metodo_pagos to fetch.
     */
    orderBy?: Metodo_pagoOrderByWithRelationInput | Metodo_pagoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Metodo_pagos.
     */
    cursor?: Metodo_pagoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Metodo_pagos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Metodo_pagos.
     */
    skip?: number
    distinct?: Metodo_pagoScalarFieldEnum | Metodo_pagoScalarFieldEnum[]
  }

  /**
   * Metodo_pago create
   */
  export type Metodo_pagoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metodo_pago
     */
    select?: Metodo_pagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Metodo_pago
     */
    omit?: Metodo_pagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Metodo_pagoInclude<ExtArgs> | null
    /**
     * The data needed to create a Metodo_pago.
     */
    data: XOR<Metodo_pagoCreateInput, Metodo_pagoUncheckedCreateInput>
  }

  /**
   * Metodo_pago createMany
   */
  export type Metodo_pagoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Metodo_pagos.
     */
    data: Metodo_pagoCreateManyInput | Metodo_pagoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Metodo_pago createManyAndReturn
   */
  export type Metodo_pagoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metodo_pago
     */
    select?: Metodo_pagoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Metodo_pago
     */
    omit?: Metodo_pagoOmit<ExtArgs> | null
    /**
     * The data used to create many Metodo_pagos.
     */
    data: Metodo_pagoCreateManyInput | Metodo_pagoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Metodo_pago update
   */
  export type Metodo_pagoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metodo_pago
     */
    select?: Metodo_pagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Metodo_pago
     */
    omit?: Metodo_pagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Metodo_pagoInclude<ExtArgs> | null
    /**
     * The data needed to update a Metodo_pago.
     */
    data: XOR<Metodo_pagoUpdateInput, Metodo_pagoUncheckedUpdateInput>
    /**
     * Choose, which Metodo_pago to update.
     */
    where: Metodo_pagoWhereUniqueInput
  }

  /**
   * Metodo_pago updateMany
   */
  export type Metodo_pagoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Metodo_pagos.
     */
    data: XOR<Metodo_pagoUpdateManyMutationInput, Metodo_pagoUncheckedUpdateManyInput>
    /**
     * Filter which Metodo_pagos to update
     */
    where?: Metodo_pagoWhereInput
    /**
     * Limit how many Metodo_pagos to update.
     */
    limit?: number
  }

  /**
   * Metodo_pago updateManyAndReturn
   */
  export type Metodo_pagoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metodo_pago
     */
    select?: Metodo_pagoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Metodo_pago
     */
    omit?: Metodo_pagoOmit<ExtArgs> | null
    /**
     * The data used to update Metodo_pagos.
     */
    data: XOR<Metodo_pagoUpdateManyMutationInput, Metodo_pagoUncheckedUpdateManyInput>
    /**
     * Filter which Metodo_pagos to update
     */
    where?: Metodo_pagoWhereInput
    /**
     * Limit how many Metodo_pagos to update.
     */
    limit?: number
  }

  /**
   * Metodo_pago upsert
   */
  export type Metodo_pagoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metodo_pago
     */
    select?: Metodo_pagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Metodo_pago
     */
    omit?: Metodo_pagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Metodo_pagoInclude<ExtArgs> | null
    /**
     * The filter to search for the Metodo_pago to update in case it exists.
     */
    where: Metodo_pagoWhereUniqueInput
    /**
     * In case the Metodo_pago found by the `where` argument doesn't exist, create a new Metodo_pago with this data.
     */
    create: XOR<Metodo_pagoCreateInput, Metodo_pagoUncheckedCreateInput>
    /**
     * In case the Metodo_pago was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Metodo_pagoUpdateInput, Metodo_pagoUncheckedUpdateInput>
  }

  /**
   * Metodo_pago delete
   */
  export type Metodo_pagoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metodo_pago
     */
    select?: Metodo_pagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Metodo_pago
     */
    omit?: Metodo_pagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Metodo_pagoInclude<ExtArgs> | null
    /**
     * Filter which Metodo_pago to delete.
     */
    where: Metodo_pagoWhereUniqueInput
  }

  /**
   * Metodo_pago deleteMany
   */
  export type Metodo_pagoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Metodo_pagos to delete
     */
    where?: Metodo_pagoWhereInput
    /**
     * Limit how many Metodo_pagos to delete.
     */
    limit?: number
  }

  /**
   * Metodo_pago.Pago
   */
  export type Metodo_pago$PagoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pago
     */
    select?: PagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pago
     */
    omit?: PagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoInclude<ExtArgs> | null
    where?: PagoWhereInput
    orderBy?: PagoOrderByWithRelationInput | PagoOrderByWithRelationInput[]
    cursor?: PagoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PagoScalarFieldEnum | PagoScalarFieldEnum[]
  }

  /**
   * Metodo_pago without action
   */
  export type Metodo_pagoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metodo_pago
     */
    select?: Metodo_pagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Metodo_pago
     */
    omit?: Metodo_pagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Metodo_pagoInclude<ExtArgs> | null
  }


  /**
   * Model estado_convocatoria
   */

  export type AggregateEstado_convocatoria = {
    _count: Estado_convocatoriaCountAggregateOutputType | null
    _avg: Estado_convocatoriaAvgAggregateOutputType | null
    _sum: Estado_convocatoriaSumAggregateOutputType | null
    _min: Estado_convocatoriaMinAggregateOutputType | null
    _max: Estado_convocatoriaMaxAggregateOutputType | null
  }

  export type Estado_convocatoriaAvgAggregateOutputType = {
    id: number | null
  }

  export type Estado_convocatoriaSumAggregateOutputType = {
    id: number | null
  }

  export type Estado_convocatoriaMinAggregateOutputType = {
    id: number | null
    nombre: string | null
  }

  export type Estado_convocatoriaMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
  }

  export type Estado_convocatoriaCountAggregateOutputType = {
    id: number
    nombre: number
    _all: number
  }


  export type Estado_convocatoriaAvgAggregateInputType = {
    id?: true
  }

  export type Estado_convocatoriaSumAggregateInputType = {
    id?: true
  }

  export type Estado_convocatoriaMinAggregateInputType = {
    id?: true
    nombre?: true
  }

  export type Estado_convocatoriaMaxAggregateInputType = {
    id?: true
    nombre?: true
  }

  export type Estado_convocatoriaCountAggregateInputType = {
    id?: true
    nombre?: true
    _all?: true
  }

  export type Estado_convocatoriaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which estado_convocatoria to aggregate.
     */
    where?: estado_convocatoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of estado_convocatorias to fetch.
     */
    orderBy?: estado_convocatoriaOrderByWithRelationInput | estado_convocatoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: estado_convocatoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` estado_convocatorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` estado_convocatorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned estado_convocatorias
    **/
    _count?: true | Estado_convocatoriaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Estado_convocatoriaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Estado_convocatoriaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Estado_convocatoriaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Estado_convocatoriaMaxAggregateInputType
  }

  export type GetEstado_convocatoriaAggregateType<T extends Estado_convocatoriaAggregateArgs> = {
        [P in keyof T & keyof AggregateEstado_convocatoria]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEstado_convocatoria[P]>
      : GetScalarType<T[P], AggregateEstado_convocatoria[P]>
  }




  export type estado_convocatoriaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: estado_convocatoriaWhereInput
    orderBy?: estado_convocatoriaOrderByWithAggregationInput | estado_convocatoriaOrderByWithAggregationInput[]
    by: Estado_convocatoriaScalarFieldEnum[] | Estado_convocatoriaScalarFieldEnum
    having?: estado_convocatoriaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Estado_convocatoriaCountAggregateInputType | true
    _avg?: Estado_convocatoriaAvgAggregateInputType
    _sum?: Estado_convocatoriaSumAggregateInputType
    _min?: Estado_convocatoriaMinAggregateInputType
    _max?: Estado_convocatoriaMaxAggregateInputType
  }

  export type Estado_convocatoriaGroupByOutputType = {
    id: number
    nombre: string
    _count: Estado_convocatoriaCountAggregateOutputType | null
    _avg: Estado_convocatoriaAvgAggregateOutputType | null
    _sum: Estado_convocatoriaSumAggregateOutputType | null
    _min: Estado_convocatoriaMinAggregateOutputType | null
    _max: Estado_convocatoriaMaxAggregateOutputType | null
  }

  type GetEstado_convocatoriaGroupByPayload<T extends estado_convocatoriaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Estado_convocatoriaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Estado_convocatoriaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Estado_convocatoriaGroupByOutputType[P]>
            : GetScalarType<T[P], Estado_convocatoriaGroupByOutputType[P]>
        }
      >
    >


  export type estado_convocatoriaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    Convocatoria?: boolean | estado_convocatoria$ConvocatoriaArgs<ExtArgs>
    _count?: boolean | Estado_convocatoriaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["estado_convocatoria"]>

  export type estado_convocatoriaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
  }, ExtArgs["result"]["estado_convocatoria"]>

  export type estado_convocatoriaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
  }, ExtArgs["result"]["estado_convocatoria"]>

  export type estado_convocatoriaSelectScalar = {
    id?: boolean
    nombre?: boolean
  }

  export type estado_convocatoriaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nombre", ExtArgs["result"]["estado_convocatoria"]>
  export type estado_convocatoriaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Convocatoria?: boolean | estado_convocatoria$ConvocatoriaArgs<ExtArgs>
    _count?: boolean | Estado_convocatoriaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type estado_convocatoriaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type estado_convocatoriaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $estado_convocatoriaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "estado_convocatoria"
    objects: {
      Convocatoria: Prisma.$ConvocatoriaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string
    }, ExtArgs["result"]["estado_convocatoria"]>
    composites: {}
  }

  type estado_convocatoriaGetPayload<S extends boolean | null | undefined | estado_convocatoriaDefaultArgs> = $Result.GetResult<Prisma.$estado_convocatoriaPayload, S>

  type estado_convocatoriaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<estado_convocatoriaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Estado_convocatoriaCountAggregateInputType | true
    }

  export interface estado_convocatoriaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['estado_convocatoria'], meta: { name: 'estado_convocatoria' } }
    /**
     * Find zero or one Estado_convocatoria that matches the filter.
     * @param {estado_convocatoriaFindUniqueArgs} args - Arguments to find a Estado_convocatoria
     * @example
     * // Get one Estado_convocatoria
     * const estado_convocatoria = await prisma.estado_convocatoria.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends estado_convocatoriaFindUniqueArgs>(args: SelectSubset<T, estado_convocatoriaFindUniqueArgs<ExtArgs>>): Prisma__estado_convocatoriaClient<$Result.GetResult<Prisma.$estado_convocatoriaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Estado_convocatoria that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {estado_convocatoriaFindUniqueOrThrowArgs} args - Arguments to find a Estado_convocatoria
     * @example
     * // Get one Estado_convocatoria
     * const estado_convocatoria = await prisma.estado_convocatoria.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends estado_convocatoriaFindUniqueOrThrowArgs>(args: SelectSubset<T, estado_convocatoriaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__estado_convocatoriaClient<$Result.GetResult<Prisma.$estado_convocatoriaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Estado_convocatoria that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estado_convocatoriaFindFirstArgs} args - Arguments to find a Estado_convocatoria
     * @example
     * // Get one Estado_convocatoria
     * const estado_convocatoria = await prisma.estado_convocatoria.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends estado_convocatoriaFindFirstArgs>(args?: SelectSubset<T, estado_convocatoriaFindFirstArgs<ExtArgs>>): Prisma__estado_convocatoriaClient<$Result.GetResult<Prisma.$estado_convocatoriaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Estado_convocatoria that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estado_convocatoriaFindFirstOrThrowArgs} args - Arguments to find a Estado_convocatoria
     * @example
     * // Get one Estado_convocatoria
     * const estado_convocatoria = await prisma.estado_convocatoria.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends estado_convocatoriaFindFirstOrThrowArgs>(args?: SelectSubset<T, estado_convocatoriaFindFirstOrThrowArgs<ExtArgs>>): Prisma__estado_convocatoriaClient<$Result.GetResult<Prisma.$estado_convocatoriaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Estado_convocatorias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estado_convocatoriaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Estado_convocatorias
     * const estado_convocatorias = await prisma.estado_convocatoria.findMany()
     * 
     * // Get first 10 Estado_convocatorias
     * const estado_convocatorias = await prisma.estado_convocatoria.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const estado_convocatoriaWithIdOnly = await prisma.estado_convocatoria.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends estado_convocatoriaFindManyArgs>(args?: SelectSubset<T, estado_convocatoriaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$estado_convocatoriaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Estado_convocatoria.
     * @param {estado_convocatoriaCreateArgs} args - Arguments to create a Estado_convocatoria.
     * @example
     * // Create one Estado_convocatoria
     * const Estado_convocatoria = await prisma.estado_convocatoria.create({
     *   data: {
     *     // ... data to create a Estado_convocatoria
     *   }
     * })
     * 
     */
    create<T extends estado_convocatoriaCreateArgs>(args: SelectSubset<T, estado_convocatoriaCreateArgs<ExtArgs>>): Prisma__estado_convocatoriaClient<$Result.GetResult<Prisma.$estado_convocatoriaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Estado_convocatorias.
     * @param {estado_convocatoriaCreateManyArgs} args - Arguments to create many Estado_convocatorias.
     * @example
     * // Create many Estado_convocatorias
     * const estado_convocatoria = await prisma.estado_convocatoria.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends estado_convocatoriaCreateManyArgs>(args?: SelectSubset<T, estado_convocatoriaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Estado_convocatorias and returns the data saved in the database.
     * @param {estado_convocatoriaCreateManyAndReturnArgs} args - Arguments to create many Estado_convocatorias.
     * @example
     * // Create many Estado_convocatorias
     * const estado_convocatoria = await prisma.estado_convocatoria.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Estado_convocatorias and only return the `id`
     * const estado_convocatoriaWithIdOnly = await prisma.estado_convocatoria.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends estado_convocatoriaCreateManyAndReturnArgs>(args?: SelectSubset<T, estado_convocatoriaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$estado_convocatoriaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Estado_convocatoria.
     * @param {estado_convocatoriaDeleteArgs} args - Arguments to delete one Estado_convocatoria.
     * @example
     * // Delete one Estado_convocatoria
     * const Estado_convocatoria = await prisma.estado_convocatoria.delete({
     *   where: {
     *     // ... filter to delete one Estado_convocatoria
     *   }
     * })
     * 
     */
    delete<T extends estado_convocatoriaDeleteArgs>(args: SelectSubset<T, estado_convocatoriaDeleteArgs<ExtArgs>>): Prisma__estado_convocatoriaClient<$Result.GetResult<Prisma.$estado_convocatoriaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Estado_convocatoria.
     * @param {estado_convocatoriaUpdateArgs} args - Arguments to update one Estado_convocatoria.
     * @example
     * // Update one Estado_convocatoria
     * const estado_convocatoria = await prisma.estado_convocatoria.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends estado_convocatoriaUpdateArgs>(args: SelectSubset<T, estado_convocatoriaUpdateArgs<ExtArgs>>): Prisma__estado_convocatoriaClient<$Result.GetResult<Prisma.$estado_convocatoriaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Estado_convocatorias.
     * @param {estado_convocatoriaDeleteManyArgs} args - Arguments to filter Estado_convocatorias to delete.
     * @example
     * // Delete a few Estado_convocatorias
     * const { count } = await prisma.estado_convocatoria.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends estado_convocatoriaDeleteManyArgs>(args?: SelectSubset<T, estado_convocatoriaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Estado_convocatorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estado_convocatoriaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Estado_convocatorias
     * const estado_convocatoria = await prisma.estado_convocatoria.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends estado_convocatoriaUpdateManyArgs>(args: SelectSubset<T, estado_convocatoriaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Estado_convocatorias and returns the data updated in the database.
     * @param {estado_convocatoriaUpdateManyAndReturnArgs} args - Arguments to update many Estado_convocatorias.
     * @example
     * // Update many Estado_convocatorias
     * const estado_convocatoria = await prisma.estado_convocatoria.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Estado_convocatorias and only return the `id`
     * const estado_convocatoriaWithIdOnly = await prisma.estado_convocatoria.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends estado_convocatoriaUpdateManyAndReturnArgs>(args: SelectSubset<T, estado_convocatoriaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$estado_convocatoriaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Estado_convocatoria.
     * @param {estado_convocatoriaUpsertArgs} args - Arguments to update or create a Estado_convocatoria.
     * @example
     * // Update or create a Estado_convocatoria
     * const estado_convocatoria = await prisma.estado_convocatoria.upsert({
     *   create: {
     *     // ... data to create a Estado_convocatoria
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Estado_convocatoria we want to update
     *   }
     * })
     */
    upsert<T extends estado_convocatoriaUpsertArgs>(args: SelectSubset<T, estado_convocatoriaUpsertArgs<ExtArgs>>): Prisma__estado_convocatoriaClient<$Result.GetResult<Prisma.$estado_convocatoriaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Estado_convocatorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estado_convocatoriaCountArgs} args - Arguments to filter Estado_convocatorias to count.
     * @example
     * // Count the number of Estado_convocatorias
     * const count = await prisma.estado_convocatoria.count({
     *   where: {
     *     // ... the filter for the Estado_convocatorias we want to count
     *   }
     * })
    **/
    count<T extends estado_convocatoriaCountArgs>(
      args?: Subset<T, estado_convocatoriaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Estado_convocatoriaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Estado_convocatoria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Estado_convocatoriaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Estado_convocatoriaAggregateArgs>(args: Subset<T, Estado_convocatoriaAggregateArgs>): Prisma.PrismaPromise<GetEstado_convocatoriaAggregateType<T>>

    /**
     * Group by Estado_convocatoria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estado_convocatoriaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends estado_convocatoriaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: estado_convocatoriaGroupByArgs['orderBy'] }
        : { orderBy?: estado_convocatoriaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, estado_convocatoriaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEstado_convocatoriaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the estado_convocatoria model
   */
  readonly fields: estado_convocatoriaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for estado_convocatoria.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__estado_convocatoriaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Convocatoria<T extends estado_convocatoria$ConvocatoriaArgs<ExtArgs> = {}>(args?: Subset<T, estado_convocatoria$ConvocatoriaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConvocatoriaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the estado_convocatoria model
   */
  interface estado_convocatoriaFieldRefs {
    readonly id: FieldRef<"estado_convocatoria", 'Int'>
    readonly nombre: FieldRef<"estado_convocatoria", 'String'>
  }
    

  // Custom InputTypes
  /**
   * estado_convocatoria findUnique
   */
  export type estado_convocatoriaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estado_convocatoria
     */
    select?: estado_convocatoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estado_convocatoria
     */
    omit?: estado_convocatoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estado_convocatoriaInclude<ExtArgs> | null
    /**
     * Filter, which estado_convocatoria to fetch.
     */
    where: estado_convocatoriaWhereUniqueInput
  }

  /**
   * estado_convocatoria findUniqueOrThrow
   */
  export type estado_convocatoriaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estado_convocatoria
     */
    select?: estado_convocatoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estado_convocatoria
     */
    omit?: estado_convocatoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estado_convocatoriaInclude<ExtArgs> | null
    /**
     * Filter, which estado_convocatoria to fetch.
     */
    where: estado_convocatoriaWhereUniqueInput
  }

  /**
   * estado_convocatoria findFirst
   */
  export type estado_convocatoriaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estado_convocatoria
     */
    select?: estado_convocatoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estado_convocatoria
     */
    omit?: estado_convocatoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estado_convocatoriaInclude<ExtArgs> | null
    /**
     * Filter, which estado_convocatoria to fetch.
     */
    where?: estado_convocatoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of estado_convocatorias to fetch.
     */
    orderBy?: estado_convocatoriaOrderByWithRelationInput | estado_convocatoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for estado_convocatorias.
     */
    cursor?: estado_convocatoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` estado_convocatorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` estado_convocatorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of estado_convocatorias.
     */
    distinct?: Estado_convocatoriaScalarFieldEnum | Estado_convocatoriaScalarFieldEnum[]
  }

  /**
   * estado_convocatoria findFirstOrThrow
   */
  export type estado_convocatoriaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estado_convocatoria
     */
    select?: estado_convocatoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estado_convocatoria
     */
    omit?: estado_convocatoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estado_convocatoriaInclude<ExtArgs> | null
    /**
     * Filter, which estado_convocatoria to fetch.
     */
    where?: estado_convocatoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of estado_convocatorias to fetch.
     */
    orderBy?: estado_convocatoriaOrderByWithRelationInput | estado_convocatoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for estado_convocatorias.
     */
    cursor?: estado_convocatoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` estado_convocatorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` estado_convocatorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of estado_convocatorias.
     */
    distinct?: Estado_convocatoriaScalarFieldEnum | Estado_convocatoriaScalarFieldEnum[]
  }

  /**
   * estado_convocatoria findMany
   */
  export type estado_convocatoriaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estado_convocatoria
     */
    select?: estado_convocatoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estado_convocatoria
     */
    omit?: estado_convocatoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estado_convocatoriaInclude<ExtArgs> | null
    /**
     * Filter, which estado_convocatorias to fetch.
     */
    where?: estado_convocatoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of estado_convocatorias to fetch.
     */
    orderBy?: estado_convocatoriaOrderByWithRelationInput | estado_convocatoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing estado_convocatorias.
     */
    cursor?: estado_convocatoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` estado_convocatorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` estado_convocatorias.
     */
    skip?: number
    distinct?: Estado_convocatoriaScalarFieldEnum | Estado_convocatoriaScalarFieldEnum[]
  }

  /**
   * estado_convocatoria create
   */
  export type estado_convocatoriaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estado_convocatoria
     */
    select?: estado_convocatoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estado_convocatoria
     */
    omit?: estado_convocatoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estado_convocatoriaInclude<ExtArgs> | null
    /**
     * The data needed to create a estado_convocatoria.
     */
    data: XOR<estado_convocatoriaCreateInput, estado_convocatoriaUncheckedCreateInput>
  }

  /**
   * estado_convocatoria createMany
   */
  export type estado_convocatoriaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many estado_convocatorias.
     */
    data: estado_convocatoriaCreateManyInput | estado_convocatoriaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * estado_convocatoria createManyAndReturn
   */
  export type estado_convocatoriaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estado_convocatoria
     */
    select?: estado_convocatoriaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the estado_convocatoria
     */
    omit?: estado_convocatoriaOmit<ExtArgs> | null
    /**
     * The data used to create many estado_convocatorias.
     */
    data: estado_convocatoriaCreateManyInput | estado_convocatoriaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * estado_convocatoria update
   */
  export type estado_convocatoriaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estado_convocatoria
     */
    select?: estado_convocatoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estado_convocatoria
     */
    omit?: estado_convocatoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estado_convocatoriaInclude<ExtArgs> | null
    /**
     * The data needed to update a estado_convocatoria.
     */
    data: XOR<estado_convocatoriaUpdateInput, estado_convocatoriaUncheckedUpdateInput>
    /**
     * Choose, which estado_convocatoria to update.
     */
    where: estado_convocatoriaWhereUniqueInput
  }

  /**
   * estado_convocatoria updateMany
   */
  export type estado_convocatoriaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update estado_convocatorias.
     */
    data: XOR<estado_convocatoriaUpdateManyMutationInput, estado_convocatoriaUncheckedUpdateManyInput>
    /**
     * Filter which estado_convocatorias to update
     */
    where?: estado_convocatoriaWhereInput
    /**
     * Limit how many estado_convocatorias to update.
     */
    limit?: number
  }

  /**
   * estado_convocatoria updateManyAndReturn
   */
  export type estado_convocatoriaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estado_convocatoria
     */
    select?: estado_convocatoriaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the estado_convocatoria
     */
    omit?: estado_convocatoriaOmit<ExtArgs> | null
    /**
     * The data used to update estado_convocatorias.
     */
    data: XOR<estado_convocatoriaUpdateManyMutationInput, estado_convocatoriaUncheckedUpdateManyInput>
    /**
     * Filter which estado_convocatorias to update
     */
    where?: estado_convocatoriaWhereInput
    /**
     * Limit how many estado_convocatorias to update.
     */
    limit?: number
  }

  /**
   * estado_convocatoria upsert
   */
  export type estado_convocatoriaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estado_convocatoria
     */
    select?: estado_convocatoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estado_convocatoria
     */
    omit?: estado_convocatoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estado_convocatoriaInclude<ExtArgs> | null
    /**
     * The filter to search for the estado_convocatoria to update in case it exists.
     */
    where: estado_convocatoriaWhereUniqueInput
    /**
     * In case the estado_convocatoria found by the `where` argument doesn't exist, create a new estado_convocatoria with this data.
     */
    create: XOR<estado_convocatoriaCreateInput, estado_convocatoriaUncheckedCreateInput>
    /**
     * In case the estado_convocatoria was found with the provided `where` argument, update it with this data.
     */
    update: XOR<estado_convocatoriaUpdateInput, estado_convocatoriaUncheckedUpdateInput>
  }

  /**
   * estado_convocatoria delete
   */
  export type estado_convocatoriaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estado_convocatoria
     */
    select?: estado_convocatoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estado_convocatoria
     */
    omit?: estado_convocatoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estado_convocatoriaInclude<ExtArgs> | null
    /**
     * Filter which estado_convocatoria to delete.
     */
    where: estado_convocatoriaWhereUniqueInput
  }

  /**
   * estado_convocatoria deleteMany
   */
  export type estado_convocatoriaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which estado_convocatorias to delete
     */
    where?: estado_convocatoriaWhereInput
    /**
     * Limit how many estado_convocatorias to delete.
     */
    limit?: number
  }

  /**
   * estado_convocatoria.Convocatoria
   */
  export type estado_convocatoria$ConvocatoriaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Convocatoria
     */
    select?: ConvocatoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Convocatoria
     */
    omit?: ConvocatoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConvocatoriaInclude<ExtArgs> | null
    where?: ConvocatoriaWhereInput
    orderBy?: ConvocatoriaOrderByWithRelationInput | ConvocatoriaOrderByWithRelationInput[]
    cursor?: ConvocatoriaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConvocatoriaScalarFieldEnum | ConvocatoriaScalarFieldEnum[]
  }

  /**
   * estado_convocatoria without action
   */
  export type estado_convocatoriaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estado_convocatoria
     */
    select?: estado_convocatoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estado_convocatoria
     */
    omit?: estado_convocatoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estado_convocatoriaInclude<ExtArgs> | null
  }


  /**
   * Model Inscripcion
   */

  export type AggregateInscripcion = {
    _count: InscripcionCountAggregateOutputType | null
    _avg: InscripcionAvgAggregateOutputType | null
    _sum: InscripcionSumAggregateOutputType | null
    _min: InscripcionMinAggregateOutputType | null
    _max: InscripcionMaxAggregateOutputType | null
  }

  export type InscripcionAvgAggregateOutputType = {
    id: number | null
    area_id: number | null
    convocatoria_id: number | null
    categoria_id: number | null
  }

  export type InscripcionSumAggregateOutputType = {
    id: number | null
    area_id: number | null
    convocatoria_id: number | null
    categoria_id: number | null
  }

  export type InscripcionMinAggregateOutputType = {
    id: number | null
    competidor_id: string | null
    area_id: number | null
    convocatoria_id: number | null
    categoria_id: number | null
    fecha_inscripcion: Date | null
    estado_inscripcion: string | null
  }

  export type InscripcionMaxAggregateOutputType = {
    id: number | null
    competidor_id: string | null
    area_id: number | null
    convocatoria_id: number | null
    categoria_id: number | null
    fecha_inscripcion: Date | null
    estado_inscripcion: string | null
  }

  export type InscripcionCountAggregateOutputType = {
    id: number
    competidor_id: number
    area_id: number
    convocatoria_id: number
    categoria_id: number
    fecha_inscripcion: number
    estado_inscripcion: number
    _all: number
  }


  export type InscripcionAvgAggregateInputType = {
    id?: true
    area_id?: true
    convocatoria_id?: true
    categoria_id?: true
  }

  export type InscripcionSumAggregateInputType = {
    id?: true
    area_id?: true
    convocatoria_id?: true
    categoria_id?: true
  }

  export type InscripcionMinAggregateInputType = {
    id?: true
    competidor_id?: true
    area_id?: true
    convocatoria_id?: true
    categoria_id?: true
    fecha_inscripcion?: true
    estado_inscripcion?: true
  }

  export type InscripcionMaxAggregateInputType = {
    id?: true
    competidor_id?: true
    area_id?: true
    convocatoria_id?: true
    categoria_id?: true
    fecha_inscripcion?: true
    estado_inscripcion?: true
  }

  export type InscripcionCountAggregateInputType = {
    id?: true
    competidor_id?: true
    area_id?: true
    convocatoria_id?: true
    categoria_id?: true
    fecha_inscripcion?: true
    estado_inscripcion?: true
    _all?: true
  }

  export type InscripcionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inscripcion to aggregate.
     */
    where?: InscripcionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inscripcions to fetch.
     */
    orderBy?: InscripcionOrderByWithRelationInput | InscripcionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InscripcionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inscripcions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inscripcions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Inscripcions
    **/
    _count?: true | InscripcionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InscripcionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InscripcionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InscripcionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InscripcionMaxAggregateInputType
  }

  export type GetInscripcionAggregateType<T extends InscripcionAggregateArgs> = {
        [P in keyof T & keyof AggregateInscripcion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInscripcion[P]>
      : GetScalarType<T[P], AggregateInscripcion[P]>
  }




  export type InscripcionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InscripcionWhereInput
    orderBy?: InscripcionOrderByWithAggregationInput | InscripcionOrderByWithAggregationInput[]
    by: InscripcionScalarFieldEnum[] | InscripcionScalarFieldEnum
    having?: InscripcionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InscripcionCountAggregateInputType | true
    _avg?: InscripcionAvgAggregateInputType
    _sum?: InscripcionSumAggregateInputType
    _min?: InscripcionMinAggregateInputType
    _max?: InscripcionMaxAggregateInputType
  }

  export type InscripcionGroupByOutputType = {
    id: number
    competidor_id: string
    area_id: number
    convocatoria_id: number
    categoria_id: number
    fecha_inscripcion: Date
    estado_inscripcion: string
    _count: InscripcionCountAggregateOutputType | null
    _avg: InscripcionAvgAggregateOutputType | null
    _sum: InscripcionSumAggregateOutputType | null
    _min: InscripcionMinAggregateOutputType | null
    _max: InscripcionMaxAggregateOutputType | null
  }

  type GetInscripcionGroupByPayload<T extends InscripcionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InscripcionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InscripcionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InscripcionGroupByOutputType[P]>
            : GetScalarType<T[P], InscripcionGroupByOutputType[P]>
        }
      >
    >


  export type InscripcionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    competidor_id?: boolean
    area_id?: boolean
    convocatoria_id?: boolean
    categoria_id?: boolean
    fecha_inscripcion?: boolean
    estado_inscripcion?: boolean
    tutorInscripciones?: boolean | Inscripcion$tutorInscripcionesArgs<ExtArgs>
    pagos?: boolean | Inscripcion$pagosArgs<ExtArgs>
    competidor?: boolean | CompetidorDefaultArgs<ExtArgs>
    area?: boolean | AreaDefaultArgs<ExtArgs>
    convocatoria?: boolean | ConvocatoriaDefaultArgs<ExtArgs>
    categoria?: boolean | CategoriaDefaultArgs<ExtArgs>
    _count?: boolean | InscripcionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inscripcion"]>

  export type InscripcionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    competidor_id?: boolean
    area_id?: boolean
    convocatoria_id?: boolean
    categoria_id?: boolean
    fecha_inscripcion?: boolean
    estado_inscripcion?: boolean
    competidor?: boolean | CompetidorDefaultArgs<ExtArgs>
    area?: boolean | AreaDefaultArgs<ExtArgs>
    convocatoria?: boolean | ConvocatoriaDefaultArgs<ExtArgs>
    categoria?: boolean | CategoriaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inscripcion"]>

  export type InscripcionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    competidor_id?: boolean
    area_id?: boolean
    convocatoria_id?: boolean
    categoria_id?: boolean
    fecha_inscripcion?: boolean
    estado_inscripcion?: boolean
    competidor?: boolean | CompetidorDefaultArgs<ExtArgs>
    area?: boolean | AreaDefaultArgs<ExtArgs>
    convocatoria?: boolean | ConvocatoriaDefaultArgs<ExtArgs>
    categoria?: boolean | CategoriaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inscripcion"]>

  export type InscripcionSelectScalar = {
    id?: boolean
    competidor_id?: boolean
    area_id?: boolean
    convocatoria_id?: boolean
    categoria_id?: boolean
    fecha_inscripcion?: boolean
    estado_inscripcion?: boolean
  }

  export type InscripcionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "competidor_id" | "area_id" | "convocatoria_id" | "categoria_id" | "fecha_inscripcion" | "estado_inscripcion", ExtArgs["result"]["inscripcion"]>
  export type InscripcionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tutorInscripciones?: boolean | Inscripcion$tutorInscripcionesArgs<ExtArgs>
    pagos?: boolean | Inscripcion$pagosArgs<ExtArgs>
    competidor?: boolean | CompetidorDefaultArgs<ExtArgs>
    area?: boolean | AreaDefaultArgs<ExtArgs>
    convocatoria?: boolean | ConvocatoriaDefaultArgs<ExtArgs>
    categoria?: boolean | CategoriaDefaultArgs<ExtArgs>
    _count?: boolean | InscripcionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InscripcionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    competidor?: boolean | CompetidorDefaultArgs<ExtArgs>
    area?: boolean | AreaDefaultArgs<ExtArgs>
    convocatoria?: boolean | ConvocatoriaDefaultArgs<ExtArgs>
    categoria?: boolean | CategoriaDefaultArgs<ExtArgs>
  }
  export type InscripcionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    competidor?: boolean | CompetidorDefaultArgs<ExtArgs>
    area?: boolean | AreaDefaultArgs<ExtArgs>
    convocatoria?: boolean | ConvocatoriaDefaultArgs<ExtArgs>
    categoria?: boolean | CategoriaDefaultArgs<ExtArgs>
  }

  export type $InscripcionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Inscripcion"
    objects: {
      tutorInscripciones: Prisma.$Inscripcion_tutorPayload<ExtArgs>[]
      pagos: Prisma.$PagoPayload<ExtArgs>[]
      competidor: Prisma.$CompetidorPayload<ExtArgs>
      area: Prisma.$AreaPayload<ExtArgs>
      convocatoria: Prisma.$ConvocatoriaPayload<ExtArgs>
      categoria: Prisma.$CategoriaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      competidor_id: string
      area_id: number
      convocatoria_id: number
      categoria_id: number
      fecha_inscripcion: Date
      estado_inscripcion: string
    }, ExtArgs["result"]["inscripcion"]>
    composites: {}
  }

  type InscripcionGetPayload<S extends boolean | null | undefined | InscripcionDefaultArgs> = $Result.GetResult<Prisma.$InscripcionPayload, S>

  type InscripcionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InscripcionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InscripcionCountAggregateInputType | true
    }

  export interface InscripcionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Inscripcion'], meta: { name: 'Inscripcion' } }
    /**
     * Find zero or one Inscripcion that matches the filter.
     * @param {InscripcionFindUniqueArgs} args - Arguments to find a Inscripcion
     * @example
     * // Get one Inscripcion
     * const inscripcion = await prisma.inscripcion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InscripcionFindUniqueArgs>(args: SelectSubset<T, InscripcionFindUniqueArgs<ExtArgs>>): Prisma__InscripcionClient<$Result.GetResult<Prisma.$InscripcionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Inscripcion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InscripcionFindUniqueOrThrowArgs} args - Arguments to find a Inscripcion
     * @example
     * // Get one Inscripcion
     * const inscripcion = await prisma.inscripcion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InscripcionFindUniqueOrThrowArgs>(args: SelectSubset<T, InscripcionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InscripcionClient<$Result.GetResult<Prisma.$InscripcionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Inscripcion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InscripcionFindFirstArgs} args - Arguments to find a Inscripcion
     * @example
     * // Get one Inscripcion
     * const inscripcion = await prisma.inscripcion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InscripcionFindFirstArgs>(args?: SelectSubset<T, InscripcionFindFirstArgs<ExtArgs>>): Prisma__InscripcionClient<$Result.GetResult<Prisma.$InscripcionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Inscripcion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InscripcionFindFirstOrThrowArgs} args - Arguments to find a Inscripcion
     * @example
     * // Get one Inscripcion
     * const inscripcion = await prisma.inscripcion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InscripcionFindFirstOrThrowArgs>(args?: SelectSubset<T, InscripcionFindFirstOrThrowArgs<ExtArgs>>): Prisma__InscripcionClient<$Result.GetResult<Prisma.$InscripcionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Inscripcions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InscripcionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inscripcions
     * const inscripcions = await prisma.inscripcion.findMany()
     * 
     * // Get first 10 Inscripcions
     * const inscripcions = await prisma.inscripcion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inscripcionWithIdOnly = await prisma.inscripcion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InscripcionFindManyArgs>(args?: SelectSubset<T, InscripcionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InscripcionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Inscripcion.
     * @param {InscripcionCreateArgs} args - Arguments to create a Inscripcion.
     * @example
     * // Create one Inscripcion
     * const Inscripcion = await prisma.inscripcion.create({
     *   data: {
     *     // ... data to create a Inscripcion
     *   }
     * })
     * 
     */
    create<T extends InscripcionCreateArgs>(args: SelectSubset<T, InscripcionCreateArgs<ExtArgs>>): Prisma__InscripcionClient<$Result.GetResult<Prisma.$InscripcionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Inscripcions.
     * @param {InscripcionCreateManyArgs} args - Arguments to create many Inscripcions.
     * @example
     * // Create many Inscripcions
     * const inscripcion = await prisma.inscripcion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InscripcionCreateManyArgs>(args?: SelectSubset<T, InscripcionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Inscripcions and returns the data saved in the database.
     * @param {InscripcionCreateManyAndReturnArgs} args - Arguments to create many Inscripcions.
     * @example
     * // Create many Inscripcions
     * const inscripcion = await prisma.inscripcion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Inscripcions and only return the `id`
     * const inscripcionWithIdOnly = await prisma.inscripcion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InscripcionCreateManyAndReturnArgs>(args?: SelectSubset<T, InscripcionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InscripcionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Inscripcion.
     * @param {InscripcionDeleteArgs} args - Arguments to delete one Inscripcion.
     * @example
     * // Delete one Inscripcion
     * const Inscripcion = await prisma.inscripcion.delete({
     *   where: {
     *     // ... filter to delete one Inscripcion
     *   }
     * })
     * 
     */
    delete<T extends InscripcionDeleteArgs>(args: SelectSubset<T, InscripcionDeleteArgs<ExtArgs>>): Prisma__InscripcionClient<$Result.GetResult<Prisma.$InscripcionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Inscripcion.
     * @param {InscripcionUpdateArgs} args - Arguments to update one Inscripcion.
     * @example
     * // Update one Inscripcion
     * const inscripcion = await prisma.inscripcion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InscripcionUpdateArgs>(args: SelectSubset<T, InscripcionUpdateArgs<ExtArgs>>): Prisma__InscripcionClient<$Result.GetResult<Prisma.$InscripcionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Inscripcions.
     * @param {InscripcionDeleteManyArgs} args - Arguments to filter Inscripcions to delete.
     * @example
     * // Delete a few Inscripcions
     * const { count } = await prisma.inscripcion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InscripcionDeleteManyArgs>(args?: SelectSubset<T, InscripcionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inscripcions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InscripcionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inscripcions
     * const inscripcion = await prisma.inscripcion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InscripcionUpdateManyArgs>(args: SelectSubset<T, InscripcionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inscripcions and returns the data updated in the database.
     * @param {InscripcionUpdateManyAndReturnArgs} args - Arguments to update many Inscripcions.
     * @example
     * // Update many Inscripcions
     * const inscripcion = await prisma.inscripcion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Inscripcions and only return the `id`
     * const inscripcionWithIdOnly = await prisma.inscripcion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InscripcionUpdateManyAndReturnArgs>(args: SelectSubset<T, InscripcionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InscripcionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Inscripcion.
     * @param {InscripcionUpsertArgs} args - Arguments to update or create a Inscripcion.
     * @example
     * // Update or create a Inscripcion
     * const inscripcion = await prisma.inscripcion.upsert({
     *   create: {
     *     // ... data to create a Inscripcion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inscripcion we want to update
     *   }
     * })
     */
    upsert<T extends InscripcionUpsertArgs>(args: SelectSubset<T, InscripcionUpsertArgs<ExtArgs>>): Prisma__InscripcionClient<$Result.GetResult<Prisma.$InscripcionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Inscripcions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InscripcionCountArgs} args - Arguments to filter Inscripcions to count.
     * @example
     * // Count the number of Inscripcions
     * const count = await prisma.inscripcion.count({
     *   where: {
     *     // ... the filter for the Inscripcions we want to count
     *   }
     * })
    **/
    count<T extends InscripcionCountArgs>(
      args?: Subset<T, InscripcionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InscripcionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inscripcion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InscripcionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InscripcionAggregateArgs>(args: Subset<T, InscripcionAggregateArgs>): Prisma.PrismaPromise<GetInscripcionAggregateType<T>>

    /**
     * Group by Inscripcion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InscripcionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InscripcionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InscripcionGroupByArgs['orderBy'] }
        : { orderBy?: InscripcionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InscripcionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInscripcionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Inscripcion model
   */
  readonly fields: InscripcionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Inscripcion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InscripcionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tutorInscripciones<T extends Inscripcion$tutorInscripcionesArgs<ExtArgs> = {}>(args?: Subset<T, Inscripcion$tutorInscripcionesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Inscripcion_tutorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pagos<T extends Inscripcion$pagosArgs<ExtArgs> = {}>(args?: Subset<T, Inscripcion$pagosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    competidor<T extends CompetidorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompetidorDefaultArgs<ExtArgs>>): Prisma__CompetidorClient<$Result.GetResult<Prisma.$CompetidorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    area<T extends AreaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AreaDefaultArgs<ExtArgs>>): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    convocatoria<T extends ConvocatoriaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConvocatoriaDefaultArgs<ExtArgs>>): Prisma__ConvocatoriaClient<$Result.GetResult<Prisma.$ConvocatoriaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    categoria<T extends CategoriaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoriaDefaultArgs<ExtArgs>>): Prisma__CategoriaClient<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Inscripcion model
   */
  interface InscripcionFieldRefs {
    readonly id: FieldRef<"Inscripcion", 'Int'>
    readonly competidor_id: FieldRef<"Inscripcion", 'String'>
    readonly area_id: FieldRef<"Inscripcion", 'Int'>
    readonly convocatoria_id: FieldRef<"Inscripcion", 'Int'>
    readonly categoria_id: FieldRef<"Inscripcion", 'Int'>
    readonly fecha_inscripcion: FieldRef<"Inscripcion", 'DateTime'>
    readonly estado_inscripcion: FieldRef<"Inscripcion", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Inscripcion findUnique
   */
  export type InscripcionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inscripcion
     */
    select?: InscripcionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inscripcion
     */
    omit?: InscripcionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InscripcionInclude<ExtArgs> | null
    /**
     * Filter, which Inscripcion to fetch.
     */
    where: InscripcionWhereUniqueInput
  }

  /**
   * Inscripcion findUniqueOrThrow
   */
  export type InscripcionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inscripcion
     */
    select?: InscripcionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inscripcion
     */
    omit?: InscripcionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InscripcionInclude<ExtArgs> | null
    /**
     * Filter, which Inscripcion to fetch.
     */
    where: InscripcionWhereUniqueInput
  }

  /**
   * Inscripcion findFirst
   */
  export type InscripcionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inscripcion
     */
    select?: InscripcionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inscripcion
     */
    omit?: InscripcionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InscripcionInclude<ExtArgs> | null
    /**
     * Filter, which Inscripcion to fetch.
     */
    where?: InscripcionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inscripcions to fetch.
     */
    orderBy?: InscripcionOrderByWithRelationInput | InscripcionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inscripcions.
     */
    cursor?: InscripcionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inscripcions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inscripcions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inscripcions.
     */
    distinct?: InscripcionScalarFieldEnum | InscripcionScalarFieldEnum[]
  }

  /**
   * Inscripcion findFirstOrThrow
   */
  export type InscripcionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inscripcion
     */
    select?: InscripcionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inscripcion
     */
    omit?: InscripcionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InscripcionInclude<ExtArgs> | null
    /**
     * Filter, which Inscripcion to fetch.
     */
    where?: InscripcionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inscripcions to fetch.
     */
    orderBy?: InscripcionOrderByWithRelationInput | InscripcionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inscripcions.
     */
    cursor?: InscripcionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inscripcions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inscripcions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inscripcions.
     */
    distinct?: InscripcionScalarFieldEnum | InscripcionScalarFieldEnum[]
  }

  /**
   * Inscripcion findMany
   */
  export type InscripcionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inscripcion
     */
    select?: InscripcionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inscripcion
     */
    omit?: InscripcionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InscripcionInclude<ExtArgs> | null
    /**
     * Filter, which Inscripcions to fetch.
     */
    where?: InscripcionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inscripcions to fetch.
     */
    orderBy?: InscripcionOrderByWithRelationInput | InscripcionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Inscripcions.
     */
    cursor?: InscripcionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inscripcions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inscripcions.
     */
    skip?: number
    distinct?: InscripcionScalarFieldEnum | InscripcionScalarFieldEnum[]
  }

  /**
   * Inscripcion create
   */
  export type InscripcionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inscripcion
     */
    select?: InscripcionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inscripcion
     */
    omit?: InscripcionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InscripcionInclude<ExtArgs> | null
    /**
     * The data needed to create a Inscripcion.
     */
    data: XOR<InscripcionCreateInput, InscripcionUncheckedCreateInput>
  }

  /**
   * Inscripcion createMany
   */
  export type InscripcionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Inscripcions.
     */
    data: InscripcionCreateManyInput | InscripcionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Inscripcion createManyAndReturn
   */
  export type InscripcionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inscripcion
     */
    select?: InscripcionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Inscripcion
     */
    omit?: InscripcionOmit<ExtArgs> | null
    /**
     * The data used to create many Inscripcions.
     */
    data: InscripcionCreateManyInput | InscripcionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InscripcionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Inscripcion update
   */
  export type InscripcionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inscripcion
     */
    select?: InscripcionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inscripcion
     */
    omit?: InscripcionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InscripcionInclude<ExtArgs> | null
    /**
     * The data needed to update a Inscripcion.
     */
    data: XOR<InscripcionUpdateInput, InscripcionUncheckedUpdateInput>
    /**
     * Choose, which Inscripcion to update.
     */
    where: InscripcionWhereUniqueInput
  }

  /**
   * Inscripcion updateMany
   */
  export type InscripcionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Inscripcions.
     */
    data: XOR<InscripcionUpdateManyMutationInput, InscripcionUncheckedUpdateManyInput>
    /**
     * Filter which Inscripcions to update
     */
    where?: InscripcionWhereInput
    /**
     * Limit how many Inscripcions to update.
     */
    limit?: number
  }

  /**
   * Inscripcion updateManyAndReturn
   */
  export type InscripcionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inscripcion
     */
    select?: InscripcionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Inscripcion
     */
    omit?: InscripcionOmit<ExtArgs> | null
    /**
     * The data used to update Inscripcions.
     */
    data: XOR<InscripcionUpdateManyMutationInput, InscripcionUncheckedUpdateManyInput>
    /**
     * Filter which Inscripcions to update
     */
    where?: InscripcionWhereInput
    /**
     * Limit how many Inscripcions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InscripcionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Inscripcion upsert
   */
  export type InscripcionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inscripcion
     */
    select?: InscripcionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inscripcion
     */
    omit?: InscripcionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InscripcionInclude<ExtArgs> | null
    /**
     * The filter to search for the Inscripcion to update in case it exists.
     */
    where: InscripcionWhereUniqueInput
    /**
     * In case the Inscripcion found by the `where` argument doesn't exist, create a new Inscripcion with this data.
     */
    create: XOR<InscripcionCreateInput, InscripcionUncheckedCreateInput>
    /**
     * In case the Inscripcion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InscripcionUpdateInput, InscripcionUncheckedUpdateInput>
  }

  /**
   * Inscripcion delete
   */
  export type InscripcionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inscripcion
     */
    select?: InscripcionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inscripcion
     */
    omit?: InscripcionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InscripcionInclude<ExtArgs> | null
    /**
     * Filter which Inscripcion to delete.
     */
    where: InscripcionWhereUniqueInput
  }

  /**
   * Inscripcion deleteMany
   */
  export type InscripcionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inscripcions to delete
     */
    where?: InscripcionWhereInput
    /**
     * Limit how many Inscripcions to delete.
     */
    limit?: number
  }

  /**
   * Inscripcion.tutorInscripciones
   */
  export type Inscripcion$tutorInscripcionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inscripcion_tutor
     */
    select?: Inscripcion_tutorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inscripcion_tutor
     */
    omit?: Inscripcion_tutorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Inscripcion_tutorInclude<ExtArgs> | null
    where?: Inscripcion_tutorWhereInput
    orderBy?: Inscripcion_tutorOrderByWithRelationInput | Inscripcion_tutorOrderByWithRelationInput[]
    cursor?: Inscripcion_tutorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Inscripcion_tutorScalarFieldEnum | Inscripcion_tutorScalarFieldEnum[]
  }

  /**
   * Inscripcion.pagos
   */
  export type Inscripcion$pagosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pago
     */
    select?: PagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pago
     */
    omit?: PagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoInclude<ExtArgs> | null
    where?: PagoWhereInput
    orderBy?: PagoOrderByWithRelationInput | PagoOrderByWithRelationInput[]
    cursor?: PagoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PagoScalarFieldEnum | PagoScalarFieldEnum[]
  }

  /**
   * Inscripcion without action
   */
  export type InscripcionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inscripcion
     */
    select?: InscripcionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inscripcion
     */
    omit?: InscripcionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InscripcionInclude<ExtArgs> | null
  }


  /**
   * Model Nivel
   */

  export type AggregateNivel = {
    _count: NivelCountAggregateOutputType | null
    _avg: NivelAvgAggregateOutputType | null
    _sum: NivelSumAggregateOutputType | null
    _min: NivelMinAggregateOutputType | null
    _max: NivelMaxAggregateOutputType | null
  }

  export type NivelAvgAggregateOutputType = {
    id: number | null
  }

  export type NivelSumAggregateOutputType = {
    id: number | null
  }

  export type NivelMinAggregateOutputType = {
    id: number | null
    nombre_nivel: string | null
  }

  export type NivelMaxAggregateOutputType = {
    id: number | null
    nombre_nivel: string | null
  }

  export type NivelCountAggregateOutputType = {
    id: number
    nombre_nivel: number
    _all: number
  }


  export type NivelAvgAggregateInputType = {
    id?: true
  }

  export type NivelSumAggregateInputType = {
    id?: true
  }

  export type NivelMinAggregateInputType = {
    id?: true
    nombre_nivel?: true
  }

  export type NivelMaxAggregateInputType = {
    id?: true
    nombre_nivel?: true
  }

  export type NivelCountAggregateInputType = {
    id?: true
    nombre_nivel?: true
    _all?: true
  }

  export type NivelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Nivel to aggregate.
     */
    where?: NivelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Nivels to fetch.
     */
    orderBy?: NivelOrderByWithRelationInput | NivelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NivelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Nivels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Nivels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Nivels
    **/
    _count?: true | NivelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NivelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NivelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NivelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NivelMaxAggregateInputType
  }

  export type GetNivelAggregateType<T extends NivelAggregateArgs> = {
        [P in keyof T & keyof AggregateNivel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNivel[P]>
      : GetScalarType<T[P], AggregateNivel[P]>
  }




  export type NivelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NivelWhereInput
    orderBy?: NivelOrderByWithAggregationInput | NivelOrderByWithAggregationInput[]
    by: NivelScalarFieldEnum[] | NivelScalarFieldEnum
    having?: NivelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NivelCountAggregateInputType | true
    _avg?: NivelAvgAggregateInputType
    _sum?: NivelSumAggregateInputType
    _min?: NivelMinAggregateInputType
    _max?: NivelMaxAggregateInputType
  }

  export type NivelGroupByOutputType = {
    id: number
    nombre_nivel: string
    _count: NivelCountAggregateOutputType | null
    _avg: NivelAvgAggregateOutputType | null
    _sum: NivelSumAggregateOutputType | null
    _min: NivelMinAggregateOutputType | null
    _max: NivelMaxAggregateOutputType | null
  }

  type GetNivelGroupByPayload<T extends NivelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NivelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NivelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NivelGroupByOutputType[P]>
            : GetScalarType<T[P], NivelGroupByOutputType[P]>
        }
      >
    >


  export type NivelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre_nivel?: boolean
    Grado?: boolean | Nivel$GradoArgs<ExtArgs>
    _count?: boolean | NivelCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nivel"]>

  export type NivelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre_nivel?: boolean
  }, ExtArgs["result"]["nivel"]>

  export type NivelSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre_nivel?: boolean
  }, ExtArgs["result"]["nivel"]>

  export type NivelSelectScalar = {
    id?: boolean
    nombre_nivel?: boolean
  }

  export type NivelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nombre_nivel", ExtArgs["result"]["nivel"]>
  export type NivelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Grado?: boolean | Nivel$GradoArgs<ExtArgs>
    _count?: boolean | NivelCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type NivelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type NivelIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $NivelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Nivel"
    objects: {
      Grado: Prisma.$GradoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre_nivel: string
    }, ExtArgs["result"]["nivel"]>
    composites: {}
  }

  type NivelGetPayload<S extends boolean | null | undefined | NivelDefaultArgs> = $Result.GetResult<Prisma.$NivelPayload, S>

  type NivelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NivelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NivelCountAggregateInputType | true
    }

  export interface NivelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Nivel'], meta: { name: 'Nivel' } }
    /**
     * Find zero or one Nivel that matches the filter.
     * @param {NivelFindUniqueArgs} args - Arguments to find a Nivel
     * @example
     * // Get one Nivel
     * const nivel = await prisma.nivel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NivelFindUniqueArgs>(args: SelectSubset<T, NivelFindUniqueArgs<ExtArgs>>): Prisma__NivelClient<$Result.GetResult<Prisma.$NivelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Nivel that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NivelFindUniqueOrThrowArgs} args - Arguments to find a Nivel
     * @example
     * // Get one Nivel
     * const nivel = await prisma.nivel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NivelFindUniqueOrThrowArgs>(args: SelectSubset<T, NivelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NivelClient<$Result.GetResult<Prisma.$NivelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Nivel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NivelFindFirstArgs} args - Arguments to find a Nivel
     * @example
     * // Get one Nivel
     * const nivel = await prisma.nivel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NivelFindFirstArgs>(args?: SelectSubset<T, NivelFindFirstArgs<ExtArgs>>): Prisma__NivelClient<$Result.GetResult<Prisma.$NivelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Nivel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NivelFindFirstOrThrowArgs} args - Arguments to find a Nivel
     * @example
     * // Get one Nivel
     * const nivel = await prisma.nivel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NivelFindFirstOrThrowArgs>(args?: SelectSubset<T, NivelFindFirstOrThrowArgs<ExtArgs>>): Prisma__NivelClient<$Result.GetResult<Prisma.$NivelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Nivels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NivelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Nivels
     * const nivels = await prisma.nivel.findMany()
     * 
     * // Get first 10 Nivels
     * const nivels = await prisma.nivel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const nivelWithIdOnly = await prisma.nivel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NivelFindManyArgs>(args?: SelectSubset<T, NivelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NivelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Nivel.
     * @param {NivelCreateArgs} args - Arguments to create a Nivel.
     * @example
     * // Create one Nivel
     * const Nivel = await prisma.nivel.create({
     *   data: {
     *     // ... data to create a Nivel
     *   }
     * })
     * 
     */
    create<T extends NivelCreateArgs>(args: SelectSubset<T, NivelCreateArgs<ExtArgs>>): Prisma__NivelClient<$Result.GetResult<Prisma.$NivelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Nivels.
     * @param {NivelCreateManyArgs} args - Arguments to create many Nivels.
     * @example
     * // Create many Nivels
     * const nivel = await prisma.nivel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NivelCreateManyArgs>(args?: SelectSubset<T, NivelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Nivels and returns the data saved in the database.
     * @param {NivelCreateManyAndReturnArgs} args - Arguments to create many Nivels.
     * @example
     * // Create many Nivels
     * const nivel = await prisma.nivel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Nivels and only return the `id`
     * const nivelWithIdOnly = await prisma.nivel.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NivelCreateManyAndReturnArgs>(args?: SelectSubset<T, NivelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NivelPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Nivel.
     * @param {NivelDeleteArgs} args - Arguments to delete one Nivel.
     * @example
     * // Delete one Nivel
     * const Nivel = await prisma.nivel.delete({
     *   where: {
     *     // ... filter to delete one Nivel
     *   }
     * })
     * 
     */
    delete<T extends NivelDeleteArgs>(args: SelectSubset<T, NivelDeleteArgs<ExtArgs>>): Prisma__NivelClient<$Result.GetResult<Prisma.$NivelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Nivel.
     * @param {NivelUpdateArgs} args - Arguments to update one Nivel.
     * @example
     * // Update one Nivel
     * const nivel = await prisma.nivel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NivelUpdateArgs>(args: SelectSubset<T, NivelUpdateArgs<ExtArgs>>): Prisma__NivelClient<$Result.GetResult<Prisma.$NivelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Nivels.
     * @param {NivelDeleteManyArgs} args - Arguments to filter Nivels to delete.
     * @example
     * // Delete a few Nivels
     * const { count } = await prisma.nivel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NivelDeleteManyArgs>(args?: SelectSubset<T, NivelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Nivels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NivelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Nivels
     * const nivel = await prisma.nivel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NivelUpdateManyArgs>(args: SelectSubset<T, NivelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Nivels and returns the data updated in the database.
     * @param {NivelUpdateManyAndReturnArgs} args - Arguments to update many Nivels.
     * @example
     * // Update many Nivels
     * const nivel = await prisma.nivel.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Nivels and only return the `id`
     * const nivelWithIdOnly = await prisma.nivel.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NivelUpdateManyAndReturnArgs>(args: SelectSubset<T, NivelUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NivelPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Nivel.
     * @param {NivelUpsertArgs} args - Arguments to update or create a Nivel.
     * @example
     * // Update or create a Nivel
     * const nivel = await prisma.nivel.upsert({
     *   create: {
     *     // ... data to create a Nivel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Nivel we want to update
     *   }
     * })
     */
    upsert<T extends NivelUpsertArgs>(args: SelectSubset<T, NivelUpsertArgs<ExtArgs>>): Prisma__NivelClient<$Result.GetResult<Prisma.$NivelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Nivels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NivelCountArgs} args - Arguments to filter Nivels to count.
     * @example
     * // Count the number of Nivels
     * const count = await prisma.nivel.count({
     *   where: {
     *     // ... the filter for the Nivels we want to count
     *   }
     * })
    **/
    count<T extends NivelCountArgs>(
      args?: Subset<T, NivelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NivelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Nivel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NivelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NivelAggregateArgs>(args: Subset<T, NivelAggregateArgs>): Prisma.PrismaPromise<GetNivelAggregateType<T>>

    /**
     * Group by Nivel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NivelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NivelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NivelGroupByArgs['orderBy'] }
        : { orderBy?: NivelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NivelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNivelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Nivel model
   */
  readonly fields: NivelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Nivel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NivelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Grado<T extends Nivel$GradoArgs<ExtArgs> = {}>(args?: Subset<T, Nivel$GradoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Nivel model
   */
  interface NivelFieldRefs {
    readonly id: FieldRef<"Nivel", 'Int'>
    readonly nombre_nivel: FieldRef<"Nivel", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Nivel findUnique
   */
  export type NivelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nivel
     */
    select?: NivelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nivel
     */
    omit?: NivelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NivelInclude<ExtArgs> | null
    /**
     * Filter, which Nivel to fetch.
     */
    where: NivelWhereUniqueInput
  }

  /**
   * Nivel findUniqueOrThrow
   */
  export type NivelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nivel
     */
    select?: NivelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nivel
     */
    omit?: NivelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NivelInclude<ExtArgs> | null
    /**
     * Filter, which Nivel to fetch.
     */
    where: NivelWhereUniqueInput
  }

  /**
   * Nivel findFirst
   */
  export type NivelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nivel
     */
    select?: NivelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nivel
     */
    omit?: NivelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NivelInclude<ExtArgs> | null
    /**
     * Filter, which Nivel to fetch.
     */
    where?: NivelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Nivels to fetch.
     */
    orderBy?: NivelOrderByWithRelationInput | NivelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Nivels.
     */
    cursor?: NivelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Nivels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Nivels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Nivels.
     */
    distinct?: NivelScalarFieldEnum | NivelScalarFieldEnum[]
  }

  /**
   * Nivel findFirstOrThrow
   */
  export type NivelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nivel
     */
    select?: NivelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nivel
     */
    omit?: NivelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NivelInclude<ExtArgs> | null
    /**
     * Filter, which Nivel to fetch.
     */
    where?: NivelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Nivels to fetch.
     */
    orderBy?: NivelOrderByWithRelationInput | NivelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Nivels.
     */
    cursor?: NivelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Nivels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Nivels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Nivels.
     */
    distinct?: NivelScalarFieldEnum | NivelScalarFieldEnum[]
  }

  /**
   * Nivel findMany
   */
  export type NivelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nivel
     */
    select?: NivelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nivel
     */
    omit?: NivelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NivelInclude<ExtArgs> | null
    /**
     * Filter, which Nivels to fetch.
     */
    where?: NivelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Nivels to fetch.
     */
    orderBy?: NivelOrderByWithRelationInput | NivelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Nivels.
     */
    cursor?: NivelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Nivels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Nivels.
     */
    skip?: number
    distinct?: NivelScalarFieldEnum | NivelScalarFieldEnum[]
  }

  /**
   * Nivel create
   */
  export type NivelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nivel
     */
    select?: NivelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nivel
     */
    omit?: NivelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NivelInclude<ExtArgs> | null
    /**
     * The data needed to create a Nivel.
     */
    data: XOR<NivelCreateInput, NivelUncheckedCreateInput>
  }

  /**
   * Nivel createMany
   */
  export type NivelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Nivels.
     */
    data: NivelCreateManyInput | NivelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Nivel createManyAndReturn
   */
  export type NivelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nivel
     */
    select?: NivelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Nivel
     */
    omit?: NivelOmit<ExtArgs> | null
    /**
     * The data used to create many Nivels.
     */
    data: NivelCreateManyInput | NivelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Nivel update
   */
  export type NivelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nivel
     */
    select?: NivelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nivel
     */
    omit?: NivelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NivelInclude<ExtArgs> | null
    /**
     * The data needed to update a Nivel.
     */
    data: XOR<NivelUpdateInput, NivelUncheckedUpdateInput>
    /**
     * Choose, which Nivel to update.
     */
    where: NivelWhereUniqueInput
  }

  /**
   * Nivel updateMany
   */
  export type NivelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Nivels.
     */
    data: XOR<NivelUpdateManyMutationInput, NivelUncheckedUpdateManyInput>
    /**
     * Filter which Nivels to update
     */
    where?: NivelWhereInput
    /**
     * Limit how many Nivels to update.
     */
    limit?: number
  }

  /**
   * Nivel updateManyAndReturn
   */
  export type NivelUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nivel
     */
    select?: NivelSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Nivel
     */
    omit?: NivelOmit<ExtArgs> | null
    /**
     * The data used to update Nivels.
     */
    data: XOR<NivelUpdateManyMutationInput, NivelUncheckedUpdateManyInput>
    /**
     * Filter which Nivels to update
     */
    where?: NivelWhereInput
    /**
     * Limit how many Nivels to update.
     */
    limit?: number
  }

  /**
   * Nivel upsert
   */
  export type NivelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nivel
     */
    select?: NivelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nivel
     */
    omit?: NivelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NivelInclude<ExtArgs> | null
    /**
     * The filter to search for the Nivel to update in case it exists.
     */
    where: NivelWhereUniqueInput
    /**
     * In case the Nivel found by the `where` argument doesn't exist, create a new Nivel with this data.
     */
    create: XOR<NivelCreateInput, NivelUncheckedCreateInput>
    /**
     * In case the Nivel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NivelUpdateInput, NivelUncheckedUpdateInput>
  }

  /**
   * Nivel delete
   */
  export type NivelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nivel
     */
    select?: NivelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nivel
     */
    omit?: NivelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NivelInclude<ExtArgs> | null
    /**
     * Filter which Nivel to delete.
     */
    where: NivelWhereUniqueInput
  }

  /**
   * Nivel deleteMany
   */
  export type NivelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Nivels to delete
     */
    where?: NivelWhereInput
    /**
     * Limit how many Nivels to delete.
     */
    limit?: number
  }

  /**
   * Nivel.Grado
   */
  export type Nivel$GradoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grado
     */
    select?: GradoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grado
     */
    omit?: GradoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradoInclude<ExtArgs> | null
    where?: GradoWhereInput
    orderBy?: GradoOrderByWithRelationInput | GradoOrderByWithRelationInput[]
    cursor?: GradoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GradoScalarFieldEnum | GradoScalarFieldEnum[]
  }

  /**
   * Nivel without action
   */
  export type NivelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nivel
     */
    select?: NivelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nivel
     */
    omit?: NivelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NivelInclude<ExtArgs> | null
  }


  /**
   * Model Notificacion
   */

  export type AggregateNotificacion = {
    _count: NotificacionCountAggregateOutputType | null
    _avg: NotificacionAvgAggregateOutputType | null
    _sum: NotificacionSumAggregateOutputType | null
    _min: NotificacionMinAggregateOutputType | null
    _max: NotificacionMaxAggregateOutputType | null
  }

  export type NotificacionAvgAggregateOutputType = {
    id: number | null
  }

  export type NotificacionSumAggregateOutputType = {
    id: number | null
  }

  export type NotificacionMinAggregateOutputType = {
    id: number | null
    usuarioId: string | null
    tipo: string | null
    mensaje: string | null
    leido: boolean | null
    createdAt: Date | null
  }

  export type NotificacionMaxAggregateOutputType = {
    id: number | null
    usuarioId: string | null
    tipo: string | null
    mensaje: string | null
    leido: boolean | null
    createdAt: Date | null
  }

  export type NotificacionCountAggregateOutputType = {
    id: number
    usuarioId: number
    tipo: number
    mensaje: number
    leido: number
    createdAt: number
    _all: number
  }


  export type NotificacionAvgAggregateInputType = {
    id?: true
  }

  export type NotificacionSumAggregateInputType = {
    id?: true
  }

  export type NotificacionMinAggregateInputType = {
    id?: true
    usuarioId?: true
    tipo?: true
    mensaje?: true
    leido?: true
    createdAt?: true
  }

  export type NotificacionMaxAggregateInputType = {
    id?: true
    usuarioId?: true
    tipo?: true
    mensaje?: true
    leido?: true
    createdAt?: true
  }

  export type NotificacionCountAggregateInputType = {
    id?: true
    usuarioId?: true
    tipo?: true
    mensaje?: true
    leido?: true
    createdAt?: true
    _all?: true
  }

  export type NotificacionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notificacion to aggregate.
     */
    where?: NotificacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notificacions to fetch.
     */
    orderBy?: NotificacionOrderByWithRelationInput | NotificacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notificacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notificacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notificacions
    **/
    _count?: true | NotificacionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificacionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificacionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificacionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificacionMaxAggregateInputType
  }

  export type GetNotificacionAggregateType<T extends NotificacionAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificacion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificacion[P]>
      : GetScalarType<T[P], AggregateNotificacion[P]>
  }




  export type NotificacionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificacionWhereInput
    orderBy?: NotificacionOrderByWithAggregationInput | NotificacionOrderByWithAggregationInput[]
    by: NotificacionScalarFieldEnum[] | NotificacionScalarFieldEnum
    having?: NotificacionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificacionCountAggregateInputType | true
    _avg?: NotificacionAvgAggregateInputType
    _sum?: NotificacionSumAggregateInputType
    _min?: NotificacionMinAggregateInputType
    _max?: NotificacionMaxAggregateInputType
  }

  export type NotificacionGroupByOutputType = {
    id: number
    usuarioId: string
    tipo: string
    mensaje: string
    leido: boolean
    createdAt: Date
    _count: NotificacionCountAggregateOutputType | null
    _avg: NotificacionAvgAggregateOutputType | null
    _sum: NotificacionSumAggregateOutputType | null
    _min: NotificacionMinAggregateOutputType | null
    _max: NotificacionMaxAggregateOutputType | null
  }

  type GetNotificacionGroupByPayload<T extends NotificacionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificacionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificacionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificacionGroupByOutputType[P]>
            : GetScalarType<T[P], NotificacionGroupByOutputType[P]>
        }
      >
    >


  export type NotificacionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    tipo?: boolean
    mensaje?: boolean
    leido?: boolean
    createdAt?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificacion"]>

  export type NotificacionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    tipo?: boolean
    mensaje?: boolean
    leido?: boolean
    createdAt?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificacion"]>

  export type NotificacionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    tipo?: boolean
    mensaje?: boolean
    leido?: boolean
    createdAt?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificacion"]>

  export type NotificacionSelectScalar = {
    id?: boolean
    usuarioId?: boolean
    tipo?: boolean
    mensaje?: boolean
    leido?: boolean
    createdAt?: boolean
  }

  export type NotificacionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "usuarioId" | "tipo" | "mensaje" | "leido" | "createdAt", ExtArgs["result"]["notificacion"]>
  export type NotificacionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type NotificacionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type NotificacionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $NotificacionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notificacion"
    objects: {
      usuario: Prisma.$UsuarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      usuarioId: string
      tipo: string
      mensaje: string
      leido: boolean
      createdAt: Date
    }, ExtArgs["result"]["notificacion"]>
    composites: {}
  }

  type NotificacionGetPayload<S extends boolean | null | undefined | NotificacionDefaultArgs> = $Result.GetResult<Prisma.$NotificacionPayload, S>

  type NotificacionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificacionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificacionCountAggregateInputType | true
    }

  export interface NotificacionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notificacion'], meta: { name: 'Notificacion' } }
    /**
     * Find zero or one Notificacion that matches the filter.
     * @param {NotificacionFindUniqueArgs} args - Arguments to find a Notificacion
     * @example
     * // Get one Notificacion
     * const notificacion = await prisma.notificacion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificacionFindUniqueArgs>(args: SelectSubset<T, NotificacionFindUniqueArgs<ExtArgs>>): Prisma__NotificacionClient<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notificacion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificacionFindUniqueOrThrowArgs} args - Arguments to find a Notificacion
     * @example
     * // Get one Notificacion
     * const notificacion = await prisma.notificacion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificacionFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificacionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificacionClient<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notificacion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificacionFindFirstArgs} args - Arguments to find a Notificacion
     * @example
     * // Get one Notificacion
     * const notificacion = await prisma.notificacion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificacionFindFirstArgs>(args?: SelectSubset<T, NotificacionFindFirstArgs<ExtArgs>>): Prisma__NotificacionClient<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notificacion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificacionFindFirstOrThrowArgs} args - Arguments to find a Notificacion
     * @example
     * // Get one Notificacion
     * const notificacion = await prisma.notificacion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificacionFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificacionFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificacionClient<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notificacions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificacionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notificacions
     * const notificacions = await prisma.notificacion.findMany()
     * 
     * // Get first 10 Notificacions
     * const notificacions = await prisma.notificacion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificacionWithIdOnly = await prisma.notificacion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificacionFindManyArgs>(args?: SelectSubset<T, NotificacionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notificacion.
     * @param {NotificacionCreateArgs} args - Arguments to create a Notificacion.
     * @example
     * // Create one Notificacion
     * const Notificacion = await prisma.notificacion.create({
     *   data: {
     *     // ... data to create a Notificacion
     *   }
     * })
     * 
     */
    create<T extends NotificacionCreateArgs>(args: SelectSubset<T, NotificacionCreateArgs<ExtArgs>>): Prisma__NotificacionClient<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notificacions.
     * @param {NotificacionCreateManyArgs} args - Arguments to create many Notificacions.
     * @example
     * // Create many Notificacions
     * const notificacion = await prisma.notificacion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificacionCreateManyArgs>(args?: SelectSubset<T, NotificacionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notificacions and returns the data saved in the database.
     * @param {NotificacionCreateManyAndReturnArgs} args - Arguments to create many Notificacions.
     * @example
     * // Create many Notificacions
     * const notificacion = await prisma.notificacion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notificacions and only return the `id`
     * const notificacionWithIdOnly = await prisma.notificacion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificacionCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificacionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notificacion.
     * @param {NotificacionDeleteArgs} args - Arguments to delete one Notificacion.
     * @example
     * // Delete one Notificacion
     * const Notificacion = await prisma.notificacion.delete({
     *   where: {
     *     // ... filter to delete one Notificacion
     *   }
     * })
     * 
     */
    delete<T extends NotificacionDeleteArgs>(args: SelectSubset<T, NotificacionDeleteArgs<ExtArgs>>): Prisma__NotificacionClient<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notificacion.
     * @param {NotificacionUpdateArgs} args - Arguments to update one Notificacion.
     * @example
     * // Update one Notificacion
     * const notificacion = await prisma.notificacion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificacionUpdateArgs>(args: SelectSubset<T, NotificacionUpdateArgs<ExtArgs>>): Prisma__NotificacionClient<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notificacions.
     * @param {NotificacionDeleteManyArgs} args - Arguments to filter Notificacions to delete.
     * @example
     * // Delete a few Notificacions
     * const { count } = await prisma.notificacion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificacionDeleteManyArgs>(args?: SelectSubset<T, NotificacionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notificacions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificacionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notificacions
     * const notificacion = await prisma.notificacion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificacionUpdateManyArgs>(args: SelectSubset<T, NotificacionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notificacions and returns the data updated in the database.
     * @param {NotificacionUpdateManyAndReturnArgs} args - Arguments to update many Notificacions.
     * @example
     * // Update many Notificacions
     * const notificacion = await prisma.notificacion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notificacions and only return the `id`
     * const notificacionWithIdOnly = await prisma.notificacion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificacionUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificacionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notificacion.
     * @param {NotificacionUpsertArgs} args - Arguments to update or create a Notificacion.
     * @example
     * // Update or create a Notificacion
     * const notificacion = await prisma.notificacion.upsert({
     *   create: {
     *     // ... data to create a Notificacion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notificacion we want to update
     *   }
     * })
     */
    upsert<T extends NotificacionUpsertArgs>(args: SelectSubset<T, NotificacionUpsertArgs<ExtArgs>>): Prisma__NotificacionClient<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notificacions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificacionCountArgs} args - Arguments to filter Notificacions to count.
     * @example
     * // Count the number of Notificacions
     * const count = await prisma.notificacion.count({
     *   where: {
     *     // ... the filter for the Notificacions we want to count
     *   }
     * })
    **/
    count<T extends NotificacionCountArgs>(
      args?: Subset<T, NotificacionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificacionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notificacion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificacionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificacionAggregateArgs>(args: Subset<T, NotificacionAggregateArgs>): Prisma.PrismaPromise<GetNotificacionAggregateType<T>>

    /**
     * Group by Notificacion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificacionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificacionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificacionGroupByArgs['orderBy'] }
        : { orderBy?: NotificacionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificacionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificacionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notificacion model
   */
  readonly fields: NotificacionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notificacion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificacionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notificacion model
   */
  interface NotificacionFieldRefs {
    readonly id: FieldRef<"Notificacion", 'Int'>
    readonly usuarioId: FieldRef<"Notificacion", 'String'>
    readonly tipo: FieldRef<"Notificacion", 'String'>
    readonly mensaje: FieldRef<"Notificacion", 'String'>
    readonly leido: FieldRef<"Notificacion", 'Boolean'>
    readonly createdAt: FieldRef<"Notificacion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notificacion findUnique
   */
  export type NotificacionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notificacion
     */
    omit?: NotificacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null
    /**
     * Filter, which Notificacion to fetch.
     */
    where: NotificacionWhereUniqueInput
  }

  /**
   * Notificacion findUniqueOrThrow
   */
  export type NotificacionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notificacion
     */
    omit?: NotificacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null
    /**
     * Filter, which Notificacion to fetch.
     */
    where: NotificacionWhereUniqueInput
  }

  /**
   * Notificacion findFirst
   */
  export type NotificacionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notificacion
     */
    omit?: NotificacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null
    /**
     * Filter, which Notificacion to fetch.
     */
    where?: NotificacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notificacions to fetch.
     */
    orderBy?: NotificacionOrderByWithRelationInput | NotificacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notificacions.
     */
    cursor?: NotificacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notificacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notificacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notificacions.
     */
    distinct?: NotificacionScalarFieldEnum | NotificacionScalarFieldEnum[]
  }

  /**
   * Notificacion findFirstOrThrow
   */
  export type NotificacionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notificacion
     */
    omit?: NotificacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null
    /**
     * Filter, which Notificacion to fetch.
     */
    where?: NotificacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notificacions to fetch.
     */
    orderBy?: NotificacionOrderByWithRelationInput | NotificacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notificacions.
     */
    cursor?: NotificacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notificacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notificacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notificacions.
     */
    distinct?: NotificacionScalarFieldEnum | NotificacionScalarFieldEnum[]
  }

  /**
   * Notificacion findMany
   */
  export type NotificacionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notificacion
     */
    omit?: NotificacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null
    /**
     * Filter, which Notificacions to fetch.
     */
    where?: NotificacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notificacions to fetch.
     */
    orderBy?: NotificacionOrderByWithRelationInput | NotificacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notificacions.
     */
    cursor?: NotificacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notificacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notificacions.
     */
    skip?: number
    distinct?: NotificacionScalarFieldEnum | NotificacionScalarFieldEnum[]
  }

  /**
   * Notificacion create
   */
  export type NotificacionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notificacion
     */
    omit?: NotificacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null
    /**
     * The data needed to create a Notificacion.
     */
    data: XOR<NotificacionCreateInput, NotificacionUncheckedCreateInput>
  }

  /**
   * Notificacion createMany
   */
  export type NotificacionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notificacions.
     */
    data: NotificacionCreateManyInput | NotificacionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notificacion createManyAndReturn
   */
  export type NotificacionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notificacion
     */
    omit?: NotificacionOmit<ExtArgs> | null
    /**
     * The data used to create many Notificacions.
     */
    data: NotificacionCreateManyInput | NotificacionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notificacion update
   */
  export type NotificacionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notificacion
     */
    omit?: NotificacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null
    /**
     * The data needed to update a Notificacion.
     */
    data: XOR<NotificacionUpdateInput, NotificacionUncheckedUpdateInput>
    /**
     * Choose, which Notificacion to update.
     */
    where: NotificacionWhereUniqueInput
  }

  /**
   * Notificacion updateMany
   */
  export type NotificacionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notificacions.
     */
    data: XOR<NotificacionUpdateManyMutationInput, NotificacionUncheckedUpdateManyInput>
    /**
     * Filter which Notificacions to update
     */
    where?: NotificacionWhereInput
    /**
     * Limit how many Notificacions to update.
     */
    limit?: number
  }

  /**
   * Notificacion updateManyAndReturn
   */
  export type NotificacionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notificacion
     */
    omit?: NotificacionOmit<ExtArgs> | null
    /**
     * The data used to update Notificacions.
     */
    data: XOR<NotificacionUpdateManyMutationInput, NotificacionUncheckedUpdateManyInput>
    /**
     * Filter which Notificacions to update
     */
    where?: NotificacionWhereInput
    /**
     * Limit how many Notificacions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notificacion upsert
   */
  export type NotificacionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notificacion
     */
    omit?: NotificacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null
    /**
     * The filter to search for the Notificacion to update in case it exists.
     */
    where: NotificacionWhereUniqueInput
    /**
     * In case the Notificacion found by the `where` argument doesn't exist, create a new Notificacion with this data.
     */
    create: XOR<NotificacionCreateInput, NotificacionUncheckedCreateInput>
    /**
     * In case the Notificacion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificacionUpdateInput, NotificacionUncheckedUpdateInput>
  }

  /**
   * Notificacion delete
   */
  export type NotificacionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notificacion
     */
    omit?: NotificacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null
    /**
     * Filter which Notificacion to delete.
     */
    where: NotificacionWhereUniqueInput
  }

  /**
   * Notificacion deleteMany
   */
  export type NotificacionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notificacions to delete
     */
    where?: NotificacionWhereInput
    /**
     * Limit how many Notificacions to delete.
     */
    limit?: number
  }

  /**
   * Notificacion without action
   */
  export type NotificacionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notificacion
     */
    omit?: NotificacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null
  }


  /**
   * Model Motivo_rechazo
   */

  export type AggregateMotivo_rechazo = {
    _count: Motivo_rechazoCountAggregateOutputType | null
    _avg: Motivo_rechazoAvgAggregateOutputType | null
    _sum: Motivo_rechazoSumAggregateOutputType | null
    _min: Motivo_rechazoMinAggregateOutputType | null
    _max: Motivo_rechazoMaxAggregateOutputType | null
  }

  export type Motivo_rechazoAvgAggregateOutputType = {
    id: number | null
  }

  export type Motivo_rechazoSumAggregateOutputType = {
    id: number | null
  }

  export type Motivo_rechazoMinAggregateOutputType = {
    id: number | null
    mensaje: string | null
  }

  export type Motivo_rechazoMaxAggregateOutputType = {
    id: number | null
    mensaje: string | null
  }

  export type Motivo_rechazoCountAggregateOutputType = {
    id: number
    mensaje: number
    _all: number
  }


  export type Motivo_rechazoAvgAggregateInputType = {
    id?: true
  }

  export type Motivo_rechazoSumAggregateInputType = {
    id?: true
  }

  export type Motivo_rechazoMinAggregateInputType = {
    id?: true
    mensaje?: true
  }

  export type Motivo_rechazoMaxAggregateInputType = {
    id?: true
    mensaje?: true
  }

  export type Motivo_rechazoCountAggregateInputType = {
    id?: true
    mensaje?: true
    _all?: true
  }

  export type Motivo_rechazoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Motivo_rechazo to aggregate.
     */
    where?: Motivo_rechazoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Motivo_rechazos to fetch.
     */
    orderBy?: Motivo_rechazoOrderByWithRelationInput | Motivo_rechazoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Motivo_rechazoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Motivo_rechazos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Motivo_rechazos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Motivo_rechazos
    **/
    _count?: true | Motivo_rechazoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Motivo_rechazoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Motivo_rechazoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Motivo_rechazoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Motivo_rechazoMaxAggregateInputType
  }

  export type GetMotivo_rechazoAggregateType<T extends Motivo_rechazoAggregateArgs> = {
        [P in keyof T & keyof AggregateMotivo_rechazo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMotivo_rechazo[P]>
      : GetScalarType<T[P], AggregateMotivo_rechazo[P]>
  }




  export type Motivo_rechazoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Motivo_rechazoWhereInput
    orderBy?: Motivo_rechazoOrderByWithAggregationInput | Motivo_rechazoOrderByWithAggregationInput[]
    by: Motivo_rechazoScalarFieldEnum[] | Motivo_rechazoScalarFieldEnum
    having?: Motivo_rechazoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Motivo_rechazoCountAggregateInputType | true
    _avg?: Motivo_rechazoAvgAggregateInputType
    _sum?: Motivo_rechazoSumAggregateInputType
    _min?: Motivo_rechazoMinAggregateInputType
    _max?: Motivo_rechazoMaxAggregateInputType
  }

  export type Motivo_rechazoGroupByOutputType = {
    id: number
    mensaje: string
    _count: Motivo_rechazoCountAggregateOutputType | null
    _avg: Motivo_rechazoAvgAggregateOutputType | null
    _sum: Motivo_rechazoSumAggregateOutputType | null
    _min: Motivo_rechazoMinAggregateOutputType | null
    _max: Motivo_rechazoMaxAggregateOutputType | null
  }

  type GetMotivo_rechazoGroupByPayload<T extends Motivo_rechazoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Motivo_rechazoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Motivo_rechazoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Motivo_rechazoGroupByOutputType[P]>
            : GetScalarType<T[P], Motivo_rechazoGroupByOutputType[P]>
        }
      >
    >


  export type Motivo_rechazoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mensaje?: boolean
    inscripcionesTutor?: boolean | Motivo_rechazo$inscripcionesTutorArgs<ExtArgs>
    _count?: boolean | Motivo_rechazoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["motivo_rechazo"]>

  export type Motivo_rechazoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mensaje?: boolean
  }, ExtArgs["result"]["motivo_rechazo"]>

  export type Motivo_rechazoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mensaje?: boolean
  }, ExtArgs["result"]["motivo_rechazo"]>

  export type Motivo_rechazoSelectScalar = {
    id?: boolean
    mensaje?: boolean
  }

  export type Motivo_rechazoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "mensaje", ExtArgs["result"]["motivo_rechazo"]>
  export type Motivo_rechazoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inscripcionesTutor?: boolean | Motivo_rechazo$inscripcionesTutorArgs<ExtArgs>
    _count?: boolean | Motivo_rechazoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type Motivo_rechazoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type Motivo_rechazoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $Motivo_rechazoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Motivo_rechazo"
    objects: {
      inscripcionesTutor: Prisma.$Inscripcion_tutorPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      mensaje: string
    }, ExtArgs["result"]["motivo_rechazo"]>
    composites: {}
  }

  type Motivo_rechazoGetPayload<S extends boolean | null | undefined | Motivo_rechazoDefaultArgs> = $Result.GetResult<Prisma.$Motivo_rechazoPayload, S>

  type Motivo_rechazoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Motivo_rechazoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Motivo_rechazoCountAggregateInputType | true
    }

  export interface Motivo_rechazoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Motivo_rechazo'], meta: { name: 'Motivo_rechazo' } }
    /**
     * Find zero or one Motivo_rechazo that matches the filter.
     * @param {Motivo_rechazoFindUniqueArgs} args - Arguments to find a Motivo_rechazo
     * @example
     * // Get one Motivo_rechazo
     * const motivo_rechazo = await prisma.motivo_rechazo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Motivo_rechazoFindUniqueArgs>(args: SelectSubset<T, Motivo_rechazoFindUniqueArgs<ExtArgs>>): Prisma__Motivo_rechazoClient<$Result.GetResult<Prisma.$Motivo_rechazoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Motivo_rechazo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Motivo_rechazoFindUniqueOrThrowArgs} args - Arguments to find a Motivo_rechazo
     * @example
     * // Get one Motivo_rechazo
     * const motivo_rechazo = await prisma.motivo_rechazo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Motivo_rechazoFindUniqueOrThrowArgs>(args: SelectSubset<T, Motivo_rechazoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Motivo_rechazoClient<$Result.GetResult<Prisma.$Motivo_rechazoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Motivo_rechazo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Motivo_rechazoFindFirstArgs} args - Arguments to find a Motivo_rechazo
     * @example
     * // Get one Motivo_rechazo
     * const motivo_rechazo = await prisma.motivo_rechazo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Motivo_rechazoFindFirstArgs>(args?: SelectSubset<T, Motivo_rechazoFindFirstArgs<ExtArgs>>): Prisma__Motivo_rechazoClient<$Result.GetResult<Prisma.$Motivo_rechazoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Motivo_rechazo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Motivo_rechazoFindFirstOrThrowArgs} args - Arguments to find a Motivo_rechazo
     * @example
     * // Get one Motivo_rechazo
     * const motivo_rechazo = await prisma.motivo_rechazo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Motivo_rechazoFindFirstOrThrowArgs>(args?: SelectSubset<T, Motivo_rechazoFindFirstOrThrowArgs<ExtArgs>>): Prisma__Motivo_rechazoClient<$Result.GetResult<Prisma.$Motivo_rechazoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Motivo_rechazos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Motivo_rechazoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Motivo_rechazos
     * const motivo_rechazos = await prisma.motivo_rechazo.findMany()
     * 
     * // Get first 10 Motivo_rechazos
     * const motivo_rechazos = await prisma.motivo_rechazo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const motivo_rechazoWithIdOnly = await prisma.motivo_rechazo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Motivo_rechazoFindManyArgs>(args?: SelectSubset<T, Motivo_rechazoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Motivo_rechazoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Motivo_rechazo.
     * @param {Motivo_rechazoCreateArgs} args - Arguments to create a Motivo_rechazo.
     * @example
     * // Create one Motivo_rechazo
     * const Motivo_rechazo = await prisma.motivo_rechazo.create({
     *   data: {
     *     // ... data to create a Motivo_rechazo
     *   }
     * })
     * 
     */
    create<T extends Motivo_rechazoCreateArgs>(args: SelectSubset<T, Motivo_rechazoCreateArgs<ExtArgs>>): Prisma__Motivo_rechazoClient<$Result.GetResult<Prisma.$Motivo_rechazoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Motivo_rechazos.
     * @param {Motivo_rechazoCreateManyArgs} args - Arguments to create many Motivo_rechazos.
     * @example
     * // Create many Motivo_rechazos
     * const motivo_rechazo = await prisma.motivo_rechazo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Motivo_rechazoCreateManyArgs>(args?: SelectSubset<T, Motivo_rechazoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Motivo_rechazos and returns the data saved in the database.
     * @param {Motivo_rechazoCreateManyAndReturnArgs} args - Arguments to create many Motivo_rechazos.
     * @example
     * // Create many Motivo_rechazos
     * const motivo_rechazo = await prisma.motivo_rechazo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Motivo_rechazos and only return the `id`
     * const motivo_rechazoWithIdOnly = await prisma.motivo_rechazo.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Motivo_rechazoCreateManyAndReturnArgs>(args?: SelectSubset<T, Motivo_rechazoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Motivo_rechazoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Motivo_rechazo.
     * @param {Motivo_rechazoDeleteArgs} args - Arguments to delete one Motivo_rechazo.
     * @example
     * // Delete one Motivo_rechazo
     * const Motivo_rechazo = await prisma.motivo_rechazo.delete({
     *   where: {
     *     // ... filter to delete one Motivo_rechazo
     *   }
     * })
     * 
     */
    delete<T extends Motivo_rechazoDeleteArgs>(args: SelectSubset<T, Motivo_rechazoDeleteArgs<ExtArgs>>): Prisma__Motivo_rechazoClient<$Result.GetResult<Prisma.$Motivo_rechazoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Motivo_rechazo.
     * @param {Motivo_rechazoUpdateArgs} args - Arguments to update one Motivo_rechazo.
     * @example
     * // Update one Motivo_rechazo
     * const motivo_rechazo = await prisma.motivo_rechazo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Motivo_rechazoUpdateArgs>(args: SelectSubset<T, Motivo_rechazoUpdateArgs<ExtArgs>>): Prisma__Motivo_rechazoClient<$Result.GetResult<Prisma.$Motivo_rechazoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Motivo_rechazos.
     * @param {Motivo_rechazoDeleteManyArgs} args - Arguments to filter Motivo_rechazos to delete.
     * @example
     * // Delete a few Motivo_rechazos
     * const { count } = await prisma.motivo_rechazo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Motivo_rechazoDeleteManyArgs>(args?: SelectSubset<T, Motivo_rechazoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Motivo_rechazos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Motivo_rechazoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Motivo_rechazos
     * const motivo_rechazo = await prisma.motivo_rechazo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Motivo_rechazoUpdateManyArgs>(args: SelectSubset<T, Motivo_rechazoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Motivo_rechazos and returns the data updated in the database.
     * @param {Motivo_rechazoUpdateManyAndReturnArgs} args - Arguments to update many Motivo_rechazos.
     * @example
     * // Update many Motivo_rechazos
     * const motivo_rechazo = await prisma.motivo_rechazo.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Motivo_rechazos and only return the `id`
     * const motivo_rechazoWithIdOnly = await prisma.motivo_rechazo.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends Motivo_rechazoUpdateManyAndReturnArgs>(args: SelectSubset<T, Motivo_rechazoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Motivo_rechazoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Motivo_rechazo.
     * @param {Motivo_rechazoUpsertArgs} args - Arguments to update or create a Motivo_rechazo.
     * @example
     * // Update or create a Motivo_rechazo
     * const motivo_rechazo = await prisma.motivo_rechazo.upsert({
     *   create: {
     *     // ... data to create a Motivo_rechazo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Motivo_rechazo we want to update
     *   }
     * })
     */
    upsert<T extends Motivo_rechazoUpsertArgs>(args: SelectSubset<T, Motivo_rechazoUpsertArgs<ExtArgs>>): Prisma__Motivo_rechazoClient<$Result.GetResult<Prisma.$Motivo_rechazoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Motivo_rechazos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Motivo_rechazoCountArgs} args - Arguments to filter Motivo_rechazos to count.
     * @example
     * // Count the number of Motivo_rechazos
     * const count = await prisma.motivo_rechazo.count({
     *   where: {
     *     // ... the filter for the Motivo_rechazos we want to count
     *   }
     * })
    **/
    count<T extends Motivo_rechazoCountArgs>(
      args?: Subset<T, Motivo_rechazoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Motivo_rechazoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Motivo_rechazo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Motivo_rechazoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Motivo_rechazoAggregateArgs>(args: Subset<T, Motivo_rechazoAggregateArgs>): Prisma.PrismaPromise<GetMotivo_rechazoAggregateType<T>>

    /**
     * Group by Motivo_rechazo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Motivo_rechazoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Motivo_rechazoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Motivo_rechazoGroupByArgs['orderBy'] }
        : { orderBy?: Motivo_rechazoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Motivo_rechazoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMotivo_rechazoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Motivo_rechazo model
   */
  readonly fields: Motivo_rechazoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Motivo_rechazo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Motivo_rechazoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    inscripcionesTutor<T extends Motivo_rechazo$inscripcionesTutorArgs<ExtArgs> = {}>(args?: Subset<T, Motivo_rechazo$inscripcionesTutorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Inscripcion_tutorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Motivo_rechazo model
   */
  interface Motivo_rechazoFieldRefs {
    readonly id: FieldRef<"Motivo_rechazo", 'Int'>
    readonly mensaje: FieldRef<"Motivo_rechazo", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Motivo_rechazo findUnique
   */
  export type Motivo_rechazoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Motivo_rechazo
     */
    select?: Motivo_rechazoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Motivo_rechazo
     */
    omit?: Motivo_rechazoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Motivo_rechazoInclude<ExtArgs> | null
    /**
     * Filter, which Motivo_rechazo to fetch.
     */
    where: Motivo_rechazoWhereUniqueInput
  }

  /**
   * Motivo_rechazo findUniqueOrThrow
   */
  export type Motivo_rechazoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Motivo_rechazo
     */
    select?: Motivo_rechazoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Motivo_rechazo
     */
    omit?: Motivo_rechazoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Motivo_rechazoInclude<ExtArgs> | null
    /**
     * Filter, which Motivo_rechazo to fetch.
     */
    where: Motivo_rechazoWhereUniqueInput
  }

  /**
   * Motivo_rechazo findFirst
   */
  export type Motivo_rechazoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Motivo_rechazo
     */
    select?: Motivo_rechazoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Motivo_rechazo
     */
    omit?: Motivo_rechazoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Motivo_rechazoInclude<ExtArgs> | null
    /**
     * Filter, which Motivo_rechazo to fetch.
     */
    where?: Motivo_rechazoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Motivo_rechazos to fetch.
     */
    orderBy?: Motivo_rechazoOrderByWithRelationInput | Motivo_rechazoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Motivo_rechazos.
     */
    cursor?: Motivo_rechazoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Motivo_rechazos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Motivo_rechazos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Motivo_rechazos.
     */
    distinct?: Motivo_rechazoScalarFieldEnum | Motivo_rechazoScalarFieldEnum[]
  }

  /**
   * Motivo_rechazo findFirstOrThrow
   */
  export type Motivo_rechazoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Motivo_rechazo
     */
    select?: Motivo_rechazoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Motivo_rechazo
     */
    omit?: Motivo_rechazoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Motivo_rechazoInclude<ExtArgs> | null
    /**
     * Filter, which Motivo_rechazo to fetch.
     */
    where?: Motivo_rechazoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Motivo_rechazos to fetch.
     */
    orderBy?: Motivo_rechazoOrderByWithRelationInput | Motivo_rechazoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Motivo_rechazos.
     */
    cursor?: Motivo_rechazoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Motivo_rechazos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Motivo_rechazos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Motivo_rechazos.
     */
    distinct?: Motivo_rechazoScalarFieldEnum | Motivo_rechazoScalarFieldEnum[]
  }

  /**
   * Motivo_rechazo findMany
   */
  export type Motivo_rechazoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Motivo_rechazo
     */
    select?: Motivo_rechazoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Motivo_rechazo
     */
    omit?: Motivo_rechazoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Motivo_rechazoInclude<ExtArgs> | null
    /**
     * Filter, which Motivo_rechazos to fetch.
     */
    where?: Motivo_rechazoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Motivo_rechazos to fetch.
     */
    orderBy?: Motivo_rechazoOrderByWithRelationInput | Motivo_rechazoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Motivo_rechazos.
     */
    cursor?: Motivo_rechazoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Motivo_rechazos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Motivo_rechazos.
     */
    skip?: number
    distinct?: Motivo_rechazoScalarFieldEnum | Motivo_rechazoScalarFieldEnum[]
  }

  /**
   * Motivo_rechazo create
   */
  export type Motivo_rechazoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Motivo_rechazo
     */
    select?: Motivo_rechazoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Motivo_rechazo
     */
    omit?: Motivo_rechazoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Motivo_rechazoInclude<ExtArgs> | null
    /**
     * The data needed to create a Motivo_rechazo.
     */
    data: XOR<Motivo_rechazoCreateInput, Motivo_rechazoUncheckedCreateInput>
  }

  /**
   * Motivo_rechazo createMany
   */
  export type Motivo_rechazoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Motivo_rechazos.
     */
    data: Motivo_rechazoCreateManyInput | Motivo_rechazoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Motivo_rechazo createManyAndReturn
   */
  export type Motivo_rechazoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Motivo_rechazo
     */
    select?: Motivo_rechazoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Motivo_rechazo
     */
    omit?: Motivo_rechazoOmit<ExtArgs> | null
    /**
     * The data used to create many Motivo_rechazos.
     */
    data: Motivo_rechazoCreateManyInput | Motivo_rechazoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Motivo_rechazo update
   */
  export type Motivo_rechazoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Motivo_rechazo
     */
    select?: Motivo_rechazoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Motivo_rechazo
     */
    omit?: Motivo_rechazoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Motivo_rechazoInclude<ExtArgs> | null
    /**
     * The data needed to update a Motivo_rechazo.
     */
    data: XOR<Motivo_rechazoUpdateInput, Motivo_rechazoUncheckedUpdateInput>
    /**
     * Choose, which Motivo_rechazo to update.
     */
    where: Motivo_rechazoWhereUniqueInput
  }

  /**
   * Motivo_rechazo updateMany
   */
  export type Motivo_rechazoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Motivo_rechazos.
     */
    data: XOR<Motivo_rechazoUpdateManyMutationInput, Motivo_rechazoUncheckedUpdateManyInput>
    /**
     * Filter which Motivo_rechazos to update
     */
    where?: Motivo_rechazoWhereInput
    /**
     * Limit how many Motivo_rechazos to update.
     */
    limit?: number
  }

  /**
   * Motivo_rechazo updateManyAndReturn
   */
  export type Motivo_rechazoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Motivo_rechazo
     */
    select?: Motivo_rechazoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Motivo_rechazo
     */
    omit?: Motivo_rechazoOmit<ExtArgs> | null
    /**
     * The data used to update Motivo_rechazos.
     */
    data: XOR<Motivo_rechazoUpdateManyMutationInput, Motivo_rechazoUncheckedUpdateManyInput>
    /**
     * Filter which Motivo_rechazos to update
     */
    where?: Motivo_rechazoWhereInput
    /**
     * Limit how many Motivo_rechazos to update.
     */
    limit?: number
  }

  /**
   * Motivo_rechazo upsert
   */
  export type Motivo_rechazoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Motivo_rechazo
     */
    select?: Motivo_rechazoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Motivo_rechazo
     */
    omit?: Motivo_rechazoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Motivo_rechazoInclude<ExtArgs> | null
    /**
     * The filter to search for the Motivo_rechazo to update in case it exists.
     */
    where: Motivo_rechazoWhereUniqueInput
    /**
     * In case the Motivo_rechazo found by the `where` argument doesn't exist, create a new Motivo_rechazo with this data.
     */
    create: XOR<Motivo_rechazoCreateInput, Motivo_rechazoUncheckedCreateInput>
    /**
     * In case the Motivo_rechazo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Motivo_rechazoUpdateInput, Motivo_rechazoUncheckedUpdateInput>
  }

  /**
   * Motivo_rechazo delete
   */
  export type Motivo_rechazoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Motivo_rechazo
     */
    select?: Motivo_rechazoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Motivo_rechazo
     */
    omit?: Motivo_rechazoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Motivo_rechazoInclude<ExtArgs> | null
    /**
     * Filter which Motivo_rechazo to delete.
     */
    where: Motivo_rechazoWhereUniqueInput
  }

  /**
   * Motivo_rechazo deleteMany
   */
  export type Motivo_rechazoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Motivo_rechazos to delete
     */
    where?: Motivo_rechazoWhereInput
    /**
     * Limit how many Motivo_rechazos to delete.
     */
    limit?: number
  }

  /**
   * Motivo_rechazo.inscripcionesTutor
   */
  export type Motivo_rechazo$inscripcionesTutorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inscripcion_tutor
     */
    select?: Inscripcion_tutorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inscripcion_tutor
     */
    omit?: Inscripcion_tutorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Inscripcion_tutorInclude<ExtArgs> | null
    where?: Inscripcion_tutorWhereInput
    orderBy?: Inscripcion_tutorOrderByWithRelationInput | Inscripcion_tutorOrderByWithRelationInput[]
    cursor?: Inscripcion_tutorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Inscripcion_tutorScalarFieldEnum | Inscripcion_tutorScalarFieldEnum[]
  }

  /**
   * Motivo_rechazo without action
   */
  export type Motivo_rechazoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Motivo_rechazo
     */
    select?: Motivo_rechazoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Motivo_rechazo
     */
    omit?: Motivo_rechazoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Motivo_rechazoInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UsuarioScalarFieldEnum: {
    id: 'id',
    correo_electronico: 'correo_electronico',
    nombre: 'nombre',
    apellido: 'apellido',
    estado: 'estado',
    password: 'password',
    rol_id: 'rol_id',
    createdAt: 'createdAt'
  };

  export type UsuarioScalarFieldEnum = (typeof UsuarioScalarFieldEnum)[keyof typeof UsuarioScalarFieldEnum]


  export const RolScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre'
  };

  export type RolScalarFieldEnum = (typeof RolScalarFieldEnum)[keyof typeof RolScalarFieldEnum]


  export const PermisoScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    descripcion: 'descripcion'
  };

  export type PermisoScalarFieldEnum = (typeof PermisoScalarFieldEnum)[keyof typeof PermisoScalarFieldEnum]


  export const Rol_permisoScalarFieldEnum: {
    id: 'id',
    rol_id: 'rol_id',
    permiso_id: 'permiso_id'
  };

  export type Rol_permisoScalarFieldEnum = (typeof Rol_permisoScalarFieldEnum)[keyof typeof Rol_permisoScalarFieldEnum]


  export const CompetidorScalarFieldEnum: {
    id: 'id',
    usuario_id: 'usuario_id',
    colegio_id: 'colegio_id',
    provincia_id: 'provincia_id',
    carnet_identidad: 'carnet_identidad',
    fecha_nacimiento: 'fecha_nacimiento'
  };

  export type CompetidorScalarFieldEnum = (typeof CompetidorScalarFieldEnum)[keyof typeof CompetidorScalarFieldEnum]


  export const TutorScalarFieldEnum: {
    id: 'id',
    usuario_id: 'usuario_id',
    carnet_identidad: 'carnet_identidad',
    numero_celular: 'numero_celular',
    area_id: 'area_id'
  };

  export type TutorScalarFieldEnum = (typeof TutorScalarFieldEnum)[keyof typeof TutorScalarFieldEnum]


  export const DepartamentoScalarFieldEnum: {
    id: 'id',
    nombre_departamento: 'nombre_departamento'
  };

  export type DepartamentoScalarFieldEnum = (typeof DepartamentoScalarFieldEnum)[keyof typeof DepartamentoScalarFieldEnum]


  export const ProvinciaScalarFieldEnum: {
    id: 'id',
    nombre_provincia: 'nombre_provincia',
    departamento_id: 'departamento_id'
  };

  export type ProvinciaScalarFieldEnum = (typeof ProvinciaScalarFieldEnum)[keyof typeof ProvinciaScalarFieldEnum]


  export const ColegioScalarFieldEnum: {
    id: 'id',
    nombre_colegio: 'nombre_colegio',
    provincia_id: 'provincia_id'
  };

  export type ColegioScalarFieldEnum = (typeof ColegioScalarFieldEnum)[keyof typeof ColegioScalarFieldEnum]


  export const ConvocatoriaScalarFieldEnum: {
    id: 'id',
    nombre_convocatoria: 'nombre_convocatoria',
    id_estado_convocatoria: 'id_estado_convocatoria',
    fecha_inicio: 'fecha_inicio',
    fecha_fin: 'fecha_fin',
    pago_fin: 'pago_fin',
    pago_inicio: 'pago_inicio',
    competicion_inicio: 'competicion_inicio',
    competicion_fin: 'competicion_fin',
    descripcion_convocatoria: 'descripcion_convocatoria'
  };

  export type ConvocatoriaScalarFieldEnum = (typeof ConvocatoriaScalarFieldEnum)[keyof typeof ConvocatoriaScalarFieldEnum]


  export const AreaScalarFieldEnum: {
    id: 'id',
    nombre_area: 'nombre_area',
    descripcion_area: 'descripcion_area',
    costo: 'costo'
  };

  export type AreaScalarFieldEnum = (typeof AreaScalarFieldEnum)[keyof typeof AreaScalarFieldEnum]


  export const CategoriaScalarFieldEnum: {
    id: 'id',
    nombre_categoria: 'nombre_categoria',
    grado_min_id: 'grado_min_id',
    grado_max_id: 'grado_max_id',
    descripcion_cat: 'descripcion_cat'
  };

  export type CategoriaScalarFieldEnum = (typeof CategoriaScalarFieldEnum)[keyof typeof CategoriaScalarFieldEnum]


  export const GradoScalarFieldEnum: {
    id: 'id',
    nombre_grado: 'nombre_grado',
    id_nivel: 'id_nivel'
  };

  export type GradoScalarFieldEnum = (typeof GradoScalarFieldEnum)[keyof typeof GradoScalarFieldEnum]


  export const PagoScalarFieldEnum: {
    id: 'id',
    inscripcion_id: 'inscripcion_id',
    monto: 'monto',
    estado: 'estado',
    codigo_pago: 'codigo_pago',
    fecha_pago: 'fecha_pago',
    metodo_pago_id: 'metodo_pago_id'
  };

  export type PagoScalarFieldEnum = (typeof PagoScalarFieldEnum)[keyof typeof PagoScalarFieldEnum]


  export const Area_convocatoriaScalarFieldEnum: {
    id: 'id',
    area_id: 'area_id',
    convocatoria_id: 'convocatoria_id'
  };

  export type Area_convocatoriaScalarFieldEnum = (typeof Area_convocatoriaScalarFieldEnum)[keyof typeof Area_convocatoriaScalarFieldEnum]


  export const Categoria_areaScalarFieldEnum: {
    id: 'id',
    categoria_id: 'categoria_id',
    area_id: 'area_id'
  };

  export type Categoria_areaScalarFieldEnum = (typeof Categoria_areaScalarFieldEnum)[keyof typeof Categoria_areaScalarFieldEnum]


  export const Inscripcion_tutorScalarFieldEnum: {
    id: 'id',
    inscripcion_id: 'inscripcion_id',
    tutor_id: 'tutor_id',
    aprobado: 'aprobado',
    fecha_aprobacion: 'fecha_aprobacion',
    motivo_rechazo_id: 'motivo_rechazo_id',
    descripcion_rechazo: 'descripcion_rechazo',
    competidorId: 'competidorId'
  };

  export type Inscripcion_tutorScalarFieldEnum = (typeof Inscripcion_tutorScalarFieldEnum)[keyof typeof Inscripcion_tutorScalarFieldEnum]


  export const Metodo_pagoScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre'
  };

  export type Metodo_pagoScalarFieldEnum = (typeof Metodo_pagoScalarFieldEnum)[keyof typeof Metodo_pagoScalarFieldEnum]


  export const Estado_convocatoriaScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre'
  };

  export type Estado_convocatoriaScalarFieldEnum = (typeof Estado_convocatoriaScalarFieldEnum)[keyof typeof Estado_convocatoriaScalarFieldEnum]


  export const InscripcionScalarFieldEnum: {
    id: 'id',
    competidor_id: 'competidor_id',
    area_id: 'area_id',
    convocatoria_id: 'convocatoria_id',
    categoria_id: 'categoria_id',
    fecha_inscripcion: 'fecha_inscripcion',
    estado_inscripcion: 'estado_inscripcion'
  };

  export type InscripcionScalarFieldEnum = (typeof InscripcionScalarFieldEnum)[keyof typeof InscripcionScalarFieldEnum]


  export const NivelScalarFieldEnum: {
    id: 'id',
    nombre_nivel: 'nombre_nivel'
  };

  export type NivelScalarFieldEnum = (typeof NivelScalarFieldEnum)[keyof typeof NivelScalarFieldEnum]


  export const NotificacionScalarFieldEnum: {
    id: 'id',
    usuarioId: 'usuarioId',
    tipo: 'tipo',
    mensaje: 'mensaje',
    leido: 'leido',
    createdAt: 'createdAt'
  };

  export type NotificacionScalarFieldEnum = (typeof NotificacionScalarFieldEnum)[keyof typeof NotificacionScalarFieldEnum]


  export const Motivo_rechazoScalarFieldEnum: {
    id: 'id',
    mensaje: 'mensaje'
  };

  export type Motivo_rechazoScalarFieldEnum = (typeof Motivo_rechazoScalarFieldEnum)[keyof typeof Motivo_rechazoScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UsuarioWhereInput = {
    AND?: UsuarioWhereInput | UsuarioWhereInput[]
    OR?: UsuarioWhereInput[]
    NOT?: UsuarioWhereInput | UsuarioWhereInput[]
    id?: StringFilter<"Usuario"> | string
    correo_electronico?: StringFilter<"Usuario"> | string
    nombre?: StringFilter<"Usuario"> | string
    apellido?: StringFilter<"Usuario"> | string
    estado?: BoolFilter<"Usuario"> | boolean
    password?: StringFilter<"Usuario"> | string
    rol_id?: IntFilter<"Usuario"> | number
    createdAt?: DateTimeFilter<"Usuario"> | Date | string
    competidor?: XOR<CompetidorNullableScalarRelationFilter, CompetidorWhereInput> | null
    tutor?: XOR<TutorNullableScalarRelationFilter, TutorWhereInput> | null
    role?: XOR<RolScalarRelationFilter, RolWhereInput>
    Notificacion?: NotificacionListRelationFilter
  }

  export type UsuarioOrderByWithRelationInput = {
    id?: SortOrder
    correo_electronico?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    estado?: SortOrder
    password?: SortOrder
    rol_id?: SortOrder
    createdAt?: SortOrder
    competidor?: CompetidorOrderByWithRelationInput
    tutor?: TutorOrderByWithRelationInput
    role?: RolOrderByWithRelationInput
    Notificacion?: NotificacionOrderByRelationAggregateInput
  }

  export type UsuarioWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    correo_electronico?: string
    AND?: UsuarioWhereInput | UsuarioWhereInput[]
    OR?: UsuarioWhereInput[]
    NOT?: UsuarioWhereInput | UsuarioWhereInput[]
    nombre?: StringFilter<"Usuario"> | string
    apellido?: StringFilter<"Usuario"> | string
    estado?: BoolFilter<"Usuario"> | boolean
    password?: StringFilter<"Usuario"> | string
    rol_id?: IntFilter<"Usuario"> | number
    createdAt?: DateTimeFilter<"Usuario"> | Date | string
    competidor?: XOR<CompetidorNullableScalarRelationFilter, CompetidorWhereInput> | null
    tutor?: XOR<TutorNullableScalarRelationFilter, TutorWhereInput> | null
    role?: XOR<RolScalarRelationFilter, RolWhereInput>
    Notificacion?: NotificacionListRelationFilter
  }, "id" | "correo_electronico">

  export type UsuarioOrderByWithAggregationInput = {
    id?: SortOrder
    correo_electronico?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    estado?: SortOrder
    password?: SortOrder
    rol_id?: SortOrder
    createdAt?: SortOrder
    _count?: UsuarioCountOrderByAggregateInput
    _avg?: UsuarioAvgOrderByAggregateInput
    _max?: UsuarioMaxOrderByAggregateInput
    _min?: UsuarioMinOrderByAggregateInput
    _sum?: UsuarioSumOrderByAggregateInput
  }

  export type UsuarioScalarWhereWithAggregatesInput = {
    AND?: UsuarioScalarWhereWithAggregatesInput | UsuarioScalarWhereWithAggregatesInput[]
    OR?: UsuarioScalarWhereWithAggregatesInput[]
    NOT?: UsuarioScalarWhereWithAggregatesInput | UsuarioScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Usuario"> | string
    correo_electronico?: StringWithAggregatesFilter<"Usuario"> | string
    nombre?: StringWithAggregatesFilter<"Usuario"> | string
    apellido?: StringWithAggregatesFilter<"Usuario"> | string
    estado?: BoolWithAggregatesFilter<"Usuario"> | boolean
    password?: StringWithAggregatesFilter<"Usuario"> | string
    rol_id?: IntWithAggregatesFilter<"Usuario"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Usuario"> | Date | string
  }

  export type RolWhereInput = {
    AND?: RolWhereInput | RolWhereInput[]
    OR?: RolWhereInput[]
    NOT?: RolWhereInput | RolWhereInput[]
    id?: IntFilter<"Rol"> | number
    nombre?: StringFilter<"Rol"> | string
    roles?: Rol_permisoListRelationFilter
    usuarios?: UsuarioListRelationFilter
  }

  export type RolOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    roles?: Rol_permisoOrderByRelationAggregateInput
    usuarios?: UsuarioOrderByRelationAggregateInput
  }

  export type RolWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nombre?: string
    AND?: RolWhereInput | RolWhereInput[]
    OR?: RolWhereInput[]
    NOT?: RolWhereInput | RolWhereInput[]
    roles?: Rol_permisoListRelationFilter
    usuarios?: UsuarioListRelationFilter
  }, "id" | "nombre">

  export type RolOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    _count?: RolCountOrderByAggregateInput
    _avg?: RolAvgOrderByAggregateInput
    _max?: RolMaxOrderByAggregateInput
    _min?: RolMinOrderByAggregateInput
    _sum?: RolSumOrderByAggregateInput
  }

  export type RolScalarWhereWithAggregatesInput = {
    AND?: RolScalarWhereWithAggregatesInput | RolScalarWhereWithAggregatesInput[]
    OR?: RolScalarWhereWithAggregatesInput[]
    NOT?: RolScalarWhereWithAggregatesInput | RolScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Rol"> | number
    nombre?: StringWithAggregatesFilter<"Rol"> | string
  }

  export type PermisoWhereInput = {
    AND?: PermisoWhereInput | PermisoWhereInput[]
    OR?: PermisoWhereInput[]
    NOT?: PermisoWhereInput | PermisoWhereInput[]
    id?: IntFilter<"Permiso"> | number
    nombre?: StringFilter<"Permiso"> | string
    descripcion?: StringFilter<"Permiso"> | string
    roles?: Rol_permisoListRelationFilter
  }

  export type PermisoOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    roles?: Rol_permisoOrderByRelationAggregateInput
  }

  export type PermisoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nombre?: string
    AND?: PermisoWhereInput | PermisoWhereInput[]
    OR?: PermisoWhereInput[]
    NOT?: PermisoWhereInput | PermisoWhereInput[]
    descripcion?: StringFilter<"Permiso"> | string
    roles?: Rol_permisoListRelationFilter
  }, "id" | "nombre">

  export type PermisoOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    _count?: PermisoCountOrderByAggregateInput
    _avg?: PermisoAvgOrderByAggregateInput
    _max?: PermisoMaxOrderByAggregateInput
    _min?: PermisoMinOrderByAggregateInput
    _sum?: PermisoSumOrderByAggregateInput
  }

  export type PermisoScalarWhereWithAggregatesInput = {
    AND?: PermisoScalarWhereWithAggregatesInput | PermisoScalarWhereWithAggregatesInput[]
    OR?: PermisoScalarWhereWithAggregatesInput[]
    NOT?: PermisoScalarWhereWithAggregatesInput | PermisoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Permiso"> | number
    nombre?: StringWithAggregatesFilter<"Permiso"> | string
    descripcion?: StringWithAggregatesFilter<"Permiso"> | string
  }

  export type Rol_permisoWhereInput = {
    AND?: Rol_permisoWhereInput | Rol_permisoWhereInput[]
    OR?: Rol_permisoWhereInput[]
    NOT?: Rol_permisoWhereInput | Rol_permisoWhereInput[]
    id?: IntFilter<"Rol_permiso"> | number
    rol_id?: IntFilter<"Rol_permiso"> | number
    permiso_id?: IntFilter<"Rol_permiso"> | number
    permiso?: XOR<PermisoScalarRelationFilter, PermisoWhereInput>
    rol?: XOR<RolScalarRelationFilter, RolWhereInput>
  }

  export type Rol_permisoOrderByWithRelationInput = {
    id?: SortOrder
    rol_id?: SortOrder
    permiso_id?: SortOrder
    permiso?: PermisoOrderByWithRelationInput
    rol?: RolOrderByWithRelationInput
  }

  export type Rol_permisoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: Rol_permisoWhereInput | Rol_permisoWhereInput[]
    OR?: Rol_permisoWhereInput[]
    NOT?: Rol_permisoWhereInput | Rol_permisoWhereInput[]
    rol_id?: IntFilter<"Rol_permiso"> | number
    permiso_id?: IntFilter<"Rol_permiso"> | number
    permiso?: XOR<PermisoScalarRelationFilter, PermisoWhereInput>
    rol?: XOR<RolScalarRelationFilter, RolWhereInput>
  }, "id">

  export type Rol_permisoOrderByWithAggregationInput = {
    id?: SortOrder
    rol_id?: SortOrder
    permiso_id?: SortOrder
    _count?: Rol_permisoCountOrderByAggregateInput
    _avg?: Rol_permisoAvgOrderByAggregateInput
    _max?: Rol_permisoMaxOrderByAggregateInput
    _min?: Rol_permisoMinOrderByAggregateInput
    _sum?: Rol_permisoSumOrderByAggregateInput
  }

  export type Rol_permisoScalarWhereWithAggregatesInput = {
    AND?: Rol_permisoScalarWhereWithAggregatesInput | Rol_permisoScalarWhereWithAggregatesInput[]
    OR?: Rol_permisoScalarWhereWithAggregatesInput[]
    NOT?: Rol_permisoScalarWhereWithAggregatesInput | Rol_permisoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Rol_permiso"> | number
    rol_id?: IntWithAggregatesFilter<"Rol_permiso"> | number
    permiso_id?: IntWithAggregatesFilter<"Rol_permiso"> | number
  }

  export type CompetidorWhereInput = {
    AND?: CompetidorWhereInput | CompetidorWhereInput[]
    OR?: CompetidorWhereInput[]
    NOT?: CompetidorWhereInput | CompetidorWhereInput[]
    id?: StringFilter<"Competidor"> | string
    usuario_id?: StringFilter<"Competidor"> | string
    colegio_id?: IntFilter<"Competidor"> | number
    provincia_id?: IntFilter<"Competidor"> | number
    carnet_identidad?: StringFilter<"Competidor"> | string
    fecha_nacimiento?: DateTimeFilter<"Competidor"> | Date | string
    colegio?: XOR<ColegioScalarRelationFilter, ColegioWhereInput>
    provincia?: XOR<ProvinciaScalarRelationFilter, ProvinciaWhereInput>
    usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
    Inscripciones?: Inscripcion_tutorListRelationFilter
    Inscripcion?: InscripcionListRelationFilter
  }

  export type CompetidorOrderByWithRelationInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    colegio_id?: SortOrder
    provincia_id?: SortOrder
    carnet_identidad?: SortOrder
    fecha_nacimiento?: SortOrder
    colegio?: ColegioOrderByWithRelationInput
    provincia?: ProvinciaOrderByWithRelationInput
    usuario?: UsuarioOrderByWithRelationInput
    Inscripciones?: Inscripcion_tutorOrderByRelationAggregateInput
    Inscripcion?: InscripcionOrderByRelationAggregateInput
  }

  export type CompetidorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    usuario_id?: string
    carnet_identidad?: string
    AND?: CompetidorWhereInput | CompetidorWhereInput[]
    OR?: CompetidorWhereInput[]
    NOT?: CompetidorWhereInput | CompetidorWhereInput[]
    colegio_id?: IntFilter<"Competidor"> | number
    provincia_id?: IntFilter<"Competidor"> | number
    fecha_nacimiento?: DateTimeFilter<"Competidor"> | Date | string
    colegio?: XOR<ColegioScalarRelationFilter, ColegioWhereInput>
    provincia?: XOR<ProvinciaScalarRelationFilter, ProvinciaWhereInput>
    usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
    Inscripciones?: Inscripcion_tutorListRelationFilter
    Inscripcion?: InscripcionListRelationFilter
  }, "id" | "usuario_id" | "carnet_identidad">

  export type CompetidorOrderByWithAggregationInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    colegio_id?: SortOrder
    provincia_id?: SortOrder
    carnet_identidad?: SortOrder
    fecha_nacimiento?: SortOrder
    _count?: CompetidorCountOrderByAggregateInput
    _avg?: CompetidorAvgOrderByAggregateInput
    _max?: CompetidorMaxOrderByAggregateInput
    _min?: CompetidorMinOrderByAggregateInput
    _sum?: CompetidorSumOrderByAggregateInput
  }

  export type CompetidorScalarWhereWithAggregatesInput = {
    AND?: CompetidorScalarWhereWithAggregatesInput | CompetidorScalarWhereWithAggregatesInput[]
    OR?: CompetidorScalarWhereWithAggregatesInput[]
    NOT?: CompetidorScalarWhereWithAggregatesInput | CompetidorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Competidor"> | string
    usuario_id?: StringWithAggregatesFilter<"Competidor"> | string
    colegio_id?: IntWithAggregatesFilter<"Competidor"> | number
    provincia_id?: IntWithAggregatesFilter<"Competidor"> | number
    carnet_identidad?: StringWithAggregatesFilter<"Competidor"> | string
    fecha_nacimiento?: DateTimeWithAggregatesFilter<"Competidor"> | Date | string
  }

  export type TutorWhereInput = {
    AND?: TutorWhereInput | TutorWhereInput[]
    OR?: TutorWhereInput[]
    NOT?: TutorWhereInput | TutorWhereInput[]
    id?: StringFilter<"Tutor"> | string
    usuario_id?: StringFilter<"Tutor"> | string
    carnet_identidad?: StringFilter<"Tutor"> | string
    numero_celular?: StringFilter<"Tutor"> | string
    area_id?: IntFilter<"Tutor"> | number
    Inscripciones_tutor?: Inscripcion_tutorListRelationFilter
    area?: XOR<AreaScalarRelationFilter, AreaWhereInput>
    usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
  }

  export type TutorOrderByWithRelationInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    carnet_identidad?: SortOrder
    numero_celular?: SortOrder
    area_id?: SortOrder
    Inscripciones_tutor?: Inscripcion_tutorOrderByRelationAggregateInput
    area?: AreaOrderByWithRelationInput
    usuario?: UsuarioOrderByWithRelationInput
  }

  export type TutorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    usuario_id?: string
    carnet_identidad?: string
    numero_celular?: string
    AND?: TutorWhereInput | TutorWhereInput[]
    OR?: TutorWhereInput[]
    NOT?: TutorWhereInput | TutorWhereInput[]
    area_id?: IntFilter<"Tutor"> | number
    Inscripciones_tutor?: Inscripcion_tutorListRelationFilter
    area?: XOR<AreaScalarRelationFilter, AreaWhereInput>
    usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
  }, "id" | "usuario_id" | "carnet_identidad" | "numero_celular">

  export type TutorOrderByWithAggregationInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    carnet_identidad?: SortOrder
    numero_celular?: SortOrder
    area_id?: SortOrder
    _count?: TutorCountOrderByAggregateInput
    _avg?: TutorAvgOrderByAggregateInput
    _max?: TutorMaxOrderByAggregateInput
    _min?: TutorMinOrderByAggregateInput
    _sum?: TutorSumOrderByAggregateInput
  }

  export type TutorScalarWhereWithAggregatesInput = {
    AND?: TutorScalarWhereWithAggregatesInput | TutorScalarWhereWithAggregatesInput[]
    OR?: TutorScalarWhereWithAggregatesInput[]
    NOT?: TutorScalarWhereWithAggregatesInput | TutorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tutor"> | string
    usuario_id?: StringWithAggregatesFilter<"Tutor"> | string
    carnet_identidad?: StringWithAggregatesFilter<"Tutor"> | string
    numero_celular?: StringWithAggregatesFilter<"Tutor"> | string
    area_id?: IntWithAggregatesFilter<"Tutor"> | number
  }

  export type DepartamentoWhereInput = {
    AND?: DepartamentoWhereInput | DepartamentoWhereInput[]
    OR?: DepartamentoWhereInput[]
    NOT?: DepartamentoWhereInput | DepartamentoWhereInput[]
    id?: IntFilter<"Departamento"> | number
    nombre_departamento?: StringFilter<"Departamento"> | string
    Provincia?: ProvinciaListRelationFilter
  }

  export type DepartamentoOrderByWithRelationInput = {
    id?: SortOrder
    nombre_departamento?: SortOrder
    Provincia?: ProvinciaOrderByRelationAggregateInput
  }

  export type DepartamentoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DepartamentoWhereInput | DepartamentoWhereInput[]
    OR?: DepartamentoWhereInput[]
    NOT?: DepartamentoWhereInput | DepartamentoWhereInput[]
    nombre_departamento?: StringFilter<"Departamento"> | string
    Provincia?: ProvinciaListRelationFilter
  }, "id">

  export type DepartamentoOrderByWithAggregationInput = {
    id?: SortOrder
    nombre_departamento?: SortOrder
    _count?: DepartamentoCountOrderByAggregateInput
    _avg?: DepartamentoAvgOrderByAggregateInput
    _max?: DepartamentoMaxOrderByAggregateInput
    _min?: DepartamentoMinOrderByAggregateInput
    _sum?: DepartamentoSumOrderByAggregateInput
  }

  export type DepartamentoScalarWhereWithAggregatesInput = {
    AND?: DepartamentoScalarWhereWithAggregatesInput | DepartamentoScalarWhereWithAggregatesInput[]
    OR?: DepartamentoScalarWhereWithAggregatesInput[]
    NOT?: DepartamentoScalarWhereWithAggregatesInput | DepartamentoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Departamento"> | number
    nombre_departamento?: StringWithAggregatesFilter<"Departamento"> | string
  }

  export type ProvinciaWhereInput = {
    AND?: ProvinciaWhereInput | ProvinciaWhereInput[]
    OR?: ProvinciaWhereInput[]
    NOT?: ProvinciaWhereInput | ProvinciaWhereInput[]
    id?: IntFilter<"Provincia"> | number
    nombre_provincia?: StringFilter<"Provincia"> | string
    departamento_id?: IntFilter<"Provincia"> | number
    Colegio?: ColegioListRelationFilter
    Competidor?: CompetidorListRelationFilter
    departamento?: XOR<DepartamentoScalarRelationFilter, DepartamentoWhereInput>
  }

  export type ProvinciaOrderByWithRelationInput = {
    id?: SortOrder
    nombre_provincia?: SortOrder
    departamento_id?: SortOrder
    Colegio?: ColegioOrderByRelationAggregateInput
    Competidor?: CompetidorOrderByRelationAggregateInput
    departamento?: DepartamentoOrderByWithRelationInput
  }

  export type ProvinciaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProvinciaWhereInput | ProvinciaWhereInput[]
    OR?: ProvinciaWhereInput[]
    NOT?: ProvinciaWhereInput | ProvinciaWhereInput[]
    nombre_provincia?: StringFilter<"Provincia"> | string
    departamento_id?: IntFilter<"Provincia"> | number
    Colegio?: ColegioListRelationFilter
    Competidor?: CompetidorListRelationFilter
    departamento?: XOR<DepartamentoScalarRelationFilter, DepartamentoWhereInput>
  }, "id">

  export type ProvinciaOrderByWithAggregationInput = {
    id?: SortOrder
    nombre_provincia?: SortOrder
    departamento_id?: SortOrder
    _count?: ProvinciaCountOrderByAggregateInput
    _avg?: ProvinciaAvgOrderByAggregateInput
    _max?: ProvinciaMaxOrderByAggregateInput
    _min?: ProvinciaMinOrderByAggregateInput
    _sum?: ProvinciaSumOrderByAggregateInput
  }

  export type ProvinciaScalarWhereWithAggregatesInput = {
    AND?: ProvinciaScalarWhereWithAggregatesInput | ProvinciaScalarWhereWithAggregatesInput[]
    OR?: ProvinciaScalarWhereWithAggregatesInput[]
    NOT?: ProvinciaScalarWhereWithAggregatesInput | ProvinciaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Provincia"> | number
    nombre_provincia?: StringWithAggregatesFilter<"Provincia"> | string
    departamento_id?: IntWithAggregatesFilter<"Provincia"> | number
  }

  export type ColegioWhereInput = {
    AND?: ColegioWhereInput | ColegioWhereInput[]
    OR?: ColegioWhereInput[]
    NOT?: ColegioWhereInput | ColegioWhereInput[]
    id?: IntFilter<"Colegio"> | number
    nombre_colegio?: StringFilter<"Colegio"> | string
    provincia_id?: IntFilter<"Colegio"> | number
    provincia?: XOR<ProvinciaScalarRelationFilter, ProvinciaWhereInput>
    Competidores?: CompetidorListRelationFilter
  }

  export type ColegioOrderByWithRelationInput = {
    id?: SortOrder
    nombre_colegio?: SortOrder
    provincia_id?: SortOrder
    provincia?: ProvinciaOrderByWithRelationInput
    Competidores?: CompetidorOrderByRelationAggregateInput
  }

  export type ColegioWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ColegioWhereInput | ColegioWhereInput[]
    OR?: ColegioWhereInput[]
    NOT?: ColegioWhereInput | ColegioWhereInput[]
    nombre_colegio?: StringFilter<"Colegio"> | string
    provincia_id?: IntFilter<"Colegio"> | number
    provincia?: XOR<ProvinciaScalarRelationFilter, ProvinciaWhereInput>
    Competidores?: CompetidorListRelationFilter
  }, "id">

  export type ColegioOrderByWithAggregationInput = {
    id?: SortOrder
    nombre_colegio?: SortOrder
    provincia_id?: SortOrder
    _count?: ColegioCountOrderByAggregateInput
    _avg?: ColegioAvgOrderByAggregateInput
    _max?: ColegioMaxOrderByAggregateInput
    _min?: ColegioMinOrderByAggregateInput
    _sum?: ColegioSumOrderByAggregateInput
  }

  export type ColegioScalarWhereWithAggregatesInput = {
    AND?: ColegioScalarWhereWithAggregatesInput | ColegioScalarWhereWithAggregatesInput[]
    OR?: ColegioScalarWhereWithAggregatesInput[]
    NOT?: ColegioScalarWhereWithAggregatesInput | ColegioScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Colegio"> | number
    nombre_colegio?: StringWithAggregatesFilter<"Colegio"> | string
    provincia_id?: IntWithAggregatesFilter<"Colegio"> | number
  }

  export type ConvocatoriaWhereInput = {
    AND?: ConvocatoriaWhereInput | ConvocatoriaWhereInput[]
    OR?: ConvocatoriaWhereInput[]
    NOT?: ConvocatoriaWhereInput | ConvocatoriaWhereInput[]
    id?: IntFilter<"Convocatoria"> | number
    nombre_convocatoria?: StringFilter<"Convocatoria"> | string
    id_estado_convocatoria?: IntFilter<"Convocatoria"> | number
    fecha_inicio?: DateTimeFilter<"Convocatoria"> | Date | string
    fecha_fin?: DateTimeFilter<"Convocatoria"> | Date | string
    pago_fin?: DateTimeFilter<"Convocatoria"> | Date | string
    pago_inicio?: DateTimeFilter<"Convocatoria"> | Date | string
    competicion_inicio?: DateTimeFilter<"Convocatoria"> | Date | string
    competicion_fin?: DateTimeFilter<"Convocatoria"> | Date | string
    descripcion_convocatoria?: StringFilter<"Convocatoria"> | string
    Area_convocatoria?: Area_convocatoriaListRelationFilter
    estado_convocatoria?: XOR<Estado_convocatoriaScalarRelationFilter, estado_convocatoriaWhereInput>
    Inscripcion?: InscripcionListRelationFilter
  }

  export type ConvocatoriaOrderByWithRelationInput = {
    id?: SortOrder
    nombre_convocatoria?: SortOrder
    id_estado_convocatoria?: SortOrder
    fecha_inicio?: SortOrder
    fecha_fin?: SortOrder
    pago_fin?: SortOrder
    pago_inicio?: SortOrder
    competicion_inicio?: SortOrder
    competicion_fin?: SortOrder
    descripcion_convocatoria?: SortOrder
    Area_convocatoria?: Area_convocatoriaOrderByRelationAggregateInput
    estado_convocatoria?: estado_convocatoriaOrderByWithRelationInput
    Inscripcion?: InscripcionOrderByRelationAggregateInput
  }

  export type ConvocatoriaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ConvocatoriaWhereInput | ConvocatoriaWhereInput[]
    OR?: ConvocatoriaWhereInput[]
    NOT?: ConvocatoriaWhereInput | ConvocatoriaWhereInput[]
    nombre_convocatoria?: StringFilter<"Convocatoria"> | string
    id_estado_convocatoria?: IntFilter<"Convocatoria"> | number
    fecha_inicio?: DateTimeFilter<"Convocatoria"> | Date | string
    fecha_fin?: DateTimeFilter<"Convocatoria"> | Date | string
    pago_fin?: DateTimeFilter<"Convocatoria"> | Date | string
    pago_inicio?: DateTimeFilter<"Convocatoria"> | Date | string
    competicion_inicio?: DateTimeFilter<"Convocatoria"> | Date | string
    competicion_fin?: DateTimeFilter<"Convocatoria"> | Date | string
    descripcion_convocatoria?: StringFilter<"Convocatoria"> | string
    Area_convocatoria?: Area_convocatoriaListRelationFilter
    estado_convocatoria?: XOR<Estado_convocatoriaScalarRelationFilter, estado_convocatoriaWhereInput>
    Inscripcion?: InscripcionListRelationFilter
  }, "id">

  export type ConvocatoriaOrderByWithAggregationInput = {
    id?: SortOrder
    nombre_convocatoria?: SortOrder
    id_estado_convocatoria?: SortOrder
    fecha_inicio?: SortOrder
    fecha_fin?: SortOrder
    pago_fin?: SortOrder
    pago_inicio?: SortOrder
    competicion_inicio?: SortOrder
    competicion_fin?: SortOrder
    descripcion_convocatoria?: SortOrder
    _count?: ConvocatoriaCountOrderByAggregateInput
    _avg?: ConvocatoriaAvgOrderByAggregateInput
    _max?: ConvocatoriaMaxOrderByAggregateInput
    _min?: ConvocatoriaMinOrderByAggregateInput
    _sum?: ConvocatoriaSumOrderByAggregateInput
  }

  export type ConvocatoriaScalarWhereWithAggregatesInput = {
    AND?: ConvocatoriaScalarWhereWithAggregatesInput | ConvocatoriaScalarWhereWithAggregatesInput[]
    OR?: ConvocatoriaScalarWhereWithAggregatesInput[]
    NOT?: ConvocatoriaScalarWhereWithAggregatesInput | ConvocatoriaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Convocatoria"> | number
    nombre_convocatoria?: StringWithAggregatesFilter<"Convocatoria"> | string
    id_estado_convocatoria?: IntWithAggregatesFilter<"Convocatoria"> | number
    fecha_inicio?: DateTimeWithAggregatesFilter<"Convocatoria"> | Date | string
    fecha_fin?: DateTimeWithAggregatesFilter<"Convocatoria"> | Date | string
    pago_fin?: DateTimeWithAggregatesFilter<"Convocatoria"> | Date | string
    pago_inicio?: DateTimeWithAggregatesFilter<"Convocatoria"> | Date | string
    competicion_inicio?: DateTimeWithAggregatesFilter<"Convocatoria"> | Date | string
    competicion_fin?: DateTimeWithAggregatesFilter<"Convocatoria"> | Date | string
    descripcion_convocatoria?: StringWithAggregatesFilter<"Convocatoria"> | string
  }

  export type AreaWhereInput = {
    AND?: AreaWhereInput | AreaWhereInput[]
    OR?: AreaWhereInput[]
    NOT?: AreaWhereInput | AreaWhereInput[]
    id?: IntFilter<"Area"> | number
    nombre_area?: StringFilter<"Area"> | string
    descripcion_area?: StringFilter<"Area"> | string
    costo?: DecimalFilter<"Area"> | Decimal | DecimalJsLike | number | string
    Area_convocatoria?: Area_convocatoriaListRelationFilter
    area_categoria?: Categoria_areaListRelationFilter
    Tutor?: TutorListRelationFilter
    Inscripcion?: InscripcionListRelationFilter
  }

  export type AreaOrderByWithRelationInput = {
    id?: SortOrder
    nombre_area?: SortOrder
    descripcion_area?: SortOrder
    costo?: SortOrder
    Area_convocatoria?: Area_convocatoriaOrderByRelationAggregateInput
    area_categoria?: Categoria_areaOrderByRelationAggregateInput
    Tutor?: TutorOrderByRelationAggregateInput
    Inscripcion?: InscripcionOrderByRelationAggregateInput
  }

  export type AreaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AreaWhereInput | AreaWhereInput[]
    OR?: AreaWhereInput[]
    NOT?: AreaWhereInput | AreaWhereInput[]
    nombre_area?: StringFilter<"Area"> | string
    descripcion_area?: StringFilter<"Area"> | string
    costo?: DecimalFilter<"Area"> | Decimal | DecimalJsLike | number | string
    Area_convocatoria?: Area_convocatoriaListRelationFilter
    area_categoria?: Categoria_areaListRelationFilter
    Tutor?: TutorListRelationFilter
    Inscripcion?: InscripcionListRelationFilter
  }, "id">

  export type AreaOrderByWithAggregationInput = {
    id?: SortOrder
    nombre_area?: SortOrder
    descripcion_area?: SortOrder
    costo?: SortOrder
    _count?: AreaCountOrderByAggregateInput
    _avg?: AreaAvgOrderByAggregateInput
    _max?: AreaMaxOrderByAggregateInput
    _min?: AreaMinOrderByAggregateInput
    _sum?: AreaSumOrderByAggregateInput
  }

  export type AreaScalarWhereWithAggregatesInput = {
    AND?: AreaScalarWhereWithAggregatesInput | AreaScalarWhereWithAggregatesInput[]
    OR?: AreaScalarWhereWithAggregatesInput[]
    NOT?: AreaScalarWhereWithAggregatesInput | AreaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Area"> | number
    nombre_area?: StringWithAggregatesFilter<"Area"> | string
    descripcion_area?: StringWithAggregatesFilter<"Area"> | string
    costo?: DecimalWithAggregatesFilter<"Area"> | Decimal | DecimalJsLike | number | string
  }

  export type CategoriaWhereInput = {
    AND?: CategoriaWhereInput | CategoriaWhereInput[]
    OR?: CategoriaWhereInput[]
    NOT?: CategoriaWhereInput | CategoriaWhereInput[]
    id?: IntFilter<"Categoria"> | number
    nombre_categoria?: StringFilter<"Categoria"> | string
    grado_min_id?: IntFilter<"Categoria"> | number
    grado_max_id?: IntFilter<"Categoria"> | number
    descripcion_cat?: StringFilter<"Categoria"> | string
    grado_max?: XOR<GradoScalarRelationFilter, GradoWhereInput>
    grado_min?: XOR<GradoScalarRelationFilter, GradoWhereInput>
    Categoria_convocatoria?: Categoria_areaListRelationFilter
    Inscripcion?: InscripcionListRelationFilter
  }

  export type CategoriaOrderByWithRelationInput = {
    id?: SortOrder
    nombre_categoria?: SortOrder
    grado_min_id?: SortOrder
    grado_max_id?: SortOrder
    descripcion_cat?: SortOrder
    grado_max?: GradoOrderByWithRelationInput
    grado_min?: GradoOrderByWithRelationInput
    Categoria_convocatoria?: Categoria_areaOrderByRelationAggregateInput
    Inscripcion?: InscripcionOrderByRelationAggregateInput
  }

  export type CategoriaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CategoriaWhereInput | CategoriaWhereInput[]
    OR?: CategoriaWhereInput[]
    NOT?: CategoriaWhereInput | CategoriaWhereInput[]
    nombre_categoria?: StringFilter<"Categoria"> | string
    grado_min_id?: IntFilter<"Categoria"> | number
    grado_max_id?: IntFilter<"Categoria"> | number
    descripcion_cat?: StringFilter<"Categoria"> | string
    grado_max?: XOR<GradoScalarRelationFilter, GradoWhereInput>
    grado_min?: XOR<GradoScalarRelationFilter, GradoWhereInput>
    Categoria_convocatoria?: Categoria_areaListRelationFilter
    Inscripcion?: InscripcionListRelationFilter
  }, "id">

  export type CategoriaOrderByWithAggregationInput = {
    id?: SortOrder
    nombre_categoria?: SortOrder
    grado_min_id?: SortOrder
    grado_max_id?: SortOrder
    descripcion_cat?: SortOrder
    _count?: CategoriaCountOrderByAggregateInput
    _avg?: CategoriaAvgOrderByAggregateInput
    _max?: CategoriaMaxOrderByAggregateInput
    _min?: CategoriaMinOrderByAggregateInput
    _sum?: CategoriaSumOrderByAggregateInput
  }

  export type CategoriaScalarWhereWithAggregatesInput = {
    AND?: CategoriaScalarWhereWithAggregatesInput | CategoriaScalarWhereWithAggregatesInput[]
    OR?: CategoriaScalarWhereWithAggregatesInput[]
    NOT?: CategoriaScalarWhereWithAggregatesInput | CategoriaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Categoria"> | number
    nombre_categoria?: StringWithAggregatesFilter<"Categoria"> | string
    grado_min_id?: IntWithAggregatesFilter<"Categoria"> | number
    grado_max_id?: IntWithAggregatesFilter<"Categoria"> | number
    descripcion_cat?: StringWithAggregatesFilter<"Categoria"> | string
  }

  export type GradoWhereInput = {
    AND?: GradoWhereInput | GradoWhereInput[]
    OR?: GradoWhereInput[]
    NOT?: GradoWhereInput | GradoWhereInput[]
    id?: IntFilter<"Grado"> | number
    nombre_grado?: StringFilter<"Grado"> | string
    id_nivel?: IntFilter<"Grado"> | number
    categorias_max?: CategoriaListRelationFilter
    categorias_min?: CategoriaListRelationFilter
    nivel?: XOR<NivelScalarRelationFilter, NivelWhereInput>
  }

  export type GradoOrderByWithRelationInput = {
    id?: SortOrder
    nombre_grado?: SortOrder
    id_nivel?: SortOrder
    categorias_max?: CategoriaOrderByRelationAggregateInput
    categorias_min?: CategoriaOrderByRelationAggregateInput
    nivel?: NivelOrderByWithRelationInput
  }

  export type GradoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: GradoWhereInput | GradoWhereInput[]
    OR?: GradoWhereInput[]
    NOT?: GradoWhereInput | GradoWhereInput[]
    nombre_grado?: StringFilter<"Grado"> | string
    id_nivel?: IntFilter<"Grado"> | number
    categorias_max?: CategoriaListRelationFilter
    categorias_min?: CategoriaListRelationFilter
    nivel?: XOR<NivelScalarRelationFilter, NivelWhereInput>
  }, "id">

  export type GradoOrderByWithAggregationInput = {
    id?: SortOrder
    nombre_grado?: SortOrder
    id_nivel?: SortOrder
    _count?: GradoCountOrderByAggregateInput
    _avg?: GradoAvgOrderByAggregateInput
    _max?: GradoMaxOrderByAggregateInput
    _min?: GradoMinOrderByAggregateInput
    _sum?: GradoSumOrderByAggregateInput
  }

  export type GradoScalarWhereWithAggregatesInput = {
    AND?: GradoScalarWhereWithAggregatesInput | GradoScalarWhereWithAggregatesInput[]
    OR?: GradoScalarWhereWithAggregatesInput[]
    NOT?: GradoScalarWhereWithAggregatesInput | GradoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Grado"> | number
    nombre_grado?: StringWithAggregatesFilter<"Grado"> | string
    id_nivel?: IntWithAggregatesFilter<"Grado"> | number
  }

  export type PagoWhereInput = {
    AND?: PagoWhereInput | PagoWhereInput[]
    OR?: PagoWhereInput[]
    NOT?: PagoWhereInput | PagoWhereInput[]
    id?: IntFilter<"Pago"> | number
    inscripcion_id?: IntFilter<"Pago"> | number
    monto?: DecimalFilter<"Pago"> | Decimal | DecimalJsLike | number | string
    estado?: StringFilter<"Pago"> | string
    codigo_pago?: StringFilter<"Pago"> | string
    fecha_pago?: DateTimeFilter<"Pago"> | Date | string
    metodo_pago_id?: IntFilter<"Pago"> | number
    inscripcion?: XOR<InscripcionScalarRelationFilter, InscripcionWhereInput>
    metodo_pago?: XOR<Metodo_pagoScalarRelationFilter, Metodo_pagoWhereInput>
  }

  export type PagoOrderByWithRelationInput = {
    id?: SortOrder
    inscripcion_id?: SortOrder
    monto?: SortOrder
    estado?: SortOrder
    codigo_pago?: SortOrder
    fecha_pago?: SortOrder
    metodo_pago_id?: SortOrder
    inscripcion?: InscripcionOrderByWithRelationInput
    metodo_pago?: Metodo_pagoOrderByWithRelationInput
  }

  export type PagoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    codigo_pago?: string
    AND?: PagoWhereInput | PagoWhereInput[]
    OR?: PagoWhereInput[]
    NOT?: PagoWhereInput | PagoWhereInput[]
    inscripcion_id?: IntFilter<"Pago"> | number
    monto?: DecimalFilter<"Pago"> | Decimal | DecimalJsLike | number | string
    estado?: StringFilter<"Pago"> | string
    fecha_pago?: DateTimeFilter<"Pago"> | Date | string
    metodo_pago_id?: IntFilter<"Pago"> | number
    inscripcion?: XOR<InscripcionScalarRelationFilter, InscripcionWhereInput>
    metodo_pago?: XOR<Metodo_pagoScalarRelationFilter, Metodo_pagoWhereInput>
  }, "id" | "codigo_pago">

  export type PagoOrderByWithAggregationInput = {
    id?: SortOrder
    inscripcion_id?: SortOrder
    monto?: SortOrder
    estado?: SortOrder
    codigo_pago?: SortOrder
    fecha_pago?: SortOrder
    metodo_pago_id?: SortOrder
    _count?: PagoCountOrderByAggregateInput
    _avg?: PagoAvgOrderByAggregateInput
    _max?: PagoMaxOrderByAggregateInput
    _min?: PagoMinOrderByAggregateInput
    _sum?: PagoSumOrderByAggregateInput
  }

  export type PagoScalarWhereWithAggregatesInput = {
    AND?: PagoScalarWhereWithAggregatesInput | PagoScalarWhereWithAggregatesInput[]
    OR?: PagoScalarWhereWithAggregatesInput[]
    NOT?: PagoScalarWhereWithAggregatesInput | PagoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Pago"> | number
    inscripcion_id?: IntWithAggregatesFilter<"Pago"> | number
    monto?: DecimalWithAggregatesFilter<"Pago"> | Decimal | DecimalJsLike | number | string
    estado?: StringWithAggregatesFilter<"Pago"> | string
    codigo_pago?: StringWithAggregatesFilter<"Pago"> | string
    fecha_pago?: DateTimeWithAggregatesFilter<"Pago"> | Date | string
    metodo_pago_id?: IntWithAggregatesFilter<"Pago"> | number
  }

  export type Area_convocatoriaWhereInput = {
    AND?: Area_convocatoriaWhereInput | Area_convocatoriaWhereInput[]
    OR?: Area_convocatoriaWhereInput[]
    NOT?: Area_convocatoriaWhereInput | Area_convocatoriaWhereInput[]
    id?: IntFilter<"Area_convocatoria"> | number
    area_id?: IntFilter<"Area_convocatoria"> | number
    convocatoria_id?: IntFilter<"Area_convocatoria"> | number
    area?: XOR<AreaScalarRelationFilter, AreaWhereInput>
    convocatoria?: XOR<ConvocatoriaScalarRelationFilter, ConvocatoriaWhereInput>
  }

  export type Area_convocatoriaOrderByWithRelationInput = {
    id?: SortOrder
    area_id?: SortOrder
    convocatoria_id?: SortOrder
    area?: AreaOrderByWithRelationInput
    convocatoria?: ConvocatoriaOrderByWithRelationInput
  }

  export type Area_convocatoriaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: Area_convocatoriaWhereInput | Area_convocatoriaWhereInput[]
    OR?: Area_convocatoriaWhereInput[]
    NOT?: Area_convocatoriaWhereInput | Area_convocatoriaWhereInput[]
    area_id?: IntFilter<"Area_convocatoria"> | number
    convocatoria_id?: IntFilter<"Area_convocatoria"> | number
    area?: XOR<AreaScalarRelationFilter, AreaWhereInput>
    convocatoria?: XOR<ConvocatoriaScalarRelationFilter, ConvocatoriaWhereInput>
  }, "id">

  export type Area_convocatoriaOrderByWithAggregationInput = {
    id?: SortOrder
    area_id?: SortOrder
    convocatoria_id?: SortOrder
    _count?: Area_convocatoriaCountOrderByAggregateInput
    _avg?: Area_convocatoriaAvgOrderByAggregateInput
    _max?: Area_convocatoriaMaxOrderByAggregateInput
    _min?: Area_convocatoriaMinOrderByAggregateInput
    _sum?: Area_convocatoriaSumOrderByAggregateInput
  }

  export type Area_convocatoriaScalarWhereWithAggregatesInput = {
    AND?: Area_convocatoriaScalarWhereWithAggregatesInput | Area_convocatoriaScalarWhereWithAggregatesInput[]
    OR?: Area_convocatoriaScalarWhereWithAggregatesInput[]
    NOT?: Area_convocatoriaScalarWhereWithAggregatesInput | Area_convocatoriaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Area_convocatoria"> | number
    area_id?: IntWithAggregatesFilter<"Area_convocatoria"> | number
    convocatoria_id?: IntWithAggregatesFilter<"Area_convocatoria"> | number
  }

  export type Categoria_areaWhereInput = {
    AND?: Categoria_areaWhereInput | Categoria_areaWhereInput[]
    OR?: Categoria_areaWhereInput[]
    NOT?: Categoria_areaWhereInput | Categoria_areaWhereInput[]
    id?: IntFilter<"Categoria_area"> | number
    categoria_id?: IntFilter<"Categoria_area"> | number
    area_id?: IntFilter<"Categoria_area"> | number
    area?: XOR<AreaScalarRelationFilter, AreaWhereInput>
    categoria?: XOR<CategoriaScalarRelationFilter, CategoriaWhereInput>
  }

  export type Categoria_areaOrderByWithRelationInput = {
    id?: SortOrder
    categoria_id?: SortOrder
    area_id?: SortOrder
    area?: AreaOrderByWithRelationInput
    categoria?: CategoriaOrderByWithRelationInput
  }

  export type Categoria_areaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: Categoria_areaWhereInput | Categoria_areaWhereInput[]
    OR?: Categoria_areaWhereInput[]
    NOT?: Categoria_areaWhereInput | Categoria_areaWhereInput[]
    categoria_id?: IntFilter<"Categoria_area"> | number
    area_id?: IntFilter<"Categoria_area"> | number
    area?: XOR<AreaScalarRelationFilter, AreaWhereInput>
    categoria?: XOR<CategoriaScalarRelationFilter, CategoriaWhereInput>
  }, "id">

  export type Categoria_areaOrderByWithAggregationInput = {
    id?: SortOrder
    categoria_id?: SortOrder
    area_id?: SortOrder
    _count?: Categoria_areaCountOrderByAggregateInput
    _avg?: Categoria_areaAvgOrderByAggregateInput
    _max?: Categoria_areaMaxOrderByAggregateInput
    _min?: Categoria_areaMinOrderByAggregateInput
    _sum?: Categoria_areaSumOrderByAggregateInput
  }

  export type Categoria_areaScalarWhereWithAggregatesInput = {
    AND?: Categoria_areaScalarWhereWithAggregatesInput | Categoria_areaScalarWhereWithAggregatesInput[]
    OR?: Categoria_areaScalarWhereWithAggregatesInput[]
    NOT?: Categoria_areaScalarWhereWithAggregatesInput | Categoria_areaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Categoria_area"> | number
    categoria_id?: IntWithAggregatesFilter<"Categoria_area"> | number
    area_id?: IntWithAggregatesFilter<"Categoria_area"> | number
  }

  export type Inscripcion_tutorWhereInput = {
    AND?: Inscripcion_tutorWhereInput | Inscripcion_tutorWhereInput[]
    OR?: Inscripcion_tutorWhereInput[]
    NOT?: Inscripcion_tutorWhereInput | Inscripcion_tutorWhereInput[]
    id?: IntFilter<"Inscripcion_tutor"> | number
    inscripcion_id?: IntFilter<"Inscripcion_tutor"> | number
    tutor_id?: StringFilter<"Inscripcion_tutor"> | string
    aprobado?: BoolFilter<"Inscripcion_tutor"> | boolean
    fecha_aprobacion?: DateTimeNullableFilter<"Inscripcion_tutor"> | Date | string | null
    motivo_rechazo_id?: IntNullableFilter<"Inscripcion_tutor"> | number | null
    descripcion_rechazo?: StringNullableFilter<"Inscripcion_tutor"> | string | null
    competidorId?: StringNullableFilter<"Inscripcion_tutor"> | string | null
    inscripcion?: XOR<InscripcionScalarRelationFilter, InscripcionWhereInput>
    tutor?: XOR<TutorScalarRelationFilter, TutorWhereInput>
    Competidor?: XOR<CompetidorNullableScalarRelationFilter, CompetidorWhereInput> | null
    MotivoRechazo?: XOR<Motivo_rechazoNullableScalarRelationFilter, Motivo_rechazoWhereInput> | null
  }

  export type Inscripcion_tutorOrderByWithRelationInput = {
    id?: SortOrder
    inscripcion_id?: SortOrder
    tutor_id?: SortOrder
    aprobado?: SortOrder
    fecha_aprobacion?: SortOrderInput | SortOrder
    motivo_rechazo_id?: SortOrderInput | SortOrder
    descripcion_rechazo?: SortOrderInput | SortOrder
    competidorId?: SortOrderInput | SortOrder
    inscripcion?: InscripcionOrderByWithRelationInput
    tutor?: TutorOrderByWithRelationInput
    Competidor?: CompetidorOrderByWithRelationInput
    MotivoRechazo?: Motivo_rechazoOrderByWithRelationInput
  }

  export type Inscripcion_tutorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: Inscripcion_tutorWhereInput | Inscripcion_tutorWhereInput[]
    OR?: Inscripcion_tutorWhereInput[]
    NOT?: Inscripcion_tutorWhereInput | Inscripcion_tutorWhereInput[]
    inscripcion_id?: IntFilter<"Inscripcion_tutor"> | number
    tutor_id?: StringFilter<"Inscripcion_tutor"> | string
    aprobado?: BoolFilter<"Inscripcion_tutor"> | boolean
    fecha_aprobacion?: DateTimeNullableFilter<"Inscripcion_tutor"> | Date | string | null
    motivo_rechazo_id?: IntNullableFilter<"Inscripcion_tutor"> | number | null
    descripcion_rechazo?: StringNullableFilter<"Inscripcion_tutor"> | string | null
    competidorId?: StringNullableFilter<"Inscripcion_tutor"> | string | null
    inscripcion?: XOR<InscripcionScalarRelationFilter, InscripcionWhereInput>
    tutor?: XOR<TutorScalarRelationFilter, TutorWhereInput>
    Competidor?: XOR<CompetidorNullableScalarRelationFilter, CompetidorWhereInput> | null
    MotivoRechazo?: XOR<Motivo_rechazoNullableScalarRelationFilter, Motivo_rechazoWhereInput> | null
  }, "id">

  export type Inscripcion_tutorOrderByWithAggregationInput = {
    id?: SortOrder
    inscripcion_id?: SortOrder
    tutor_id?: SortOrder
    aprobado?: SortOrder
    fecha_aprobacion?: SortOrderInput | SortOrder
    motivo_rechazo_id?: SortOrderInput | SortOrder
    descripcion_rechazo?: SortOrderInput | SortOrder
    competidorId?: SortOrderInput | SortOrder
    _count?: Inscripcion_tutorCountOrderByAggregateInput
    _avg?: Inscripcion_tutorAvgOrderByAggregateInput
    _max?: Inscripcion_tutorMaxOrderByAggregateInput
    _min?: Inscripcion_tutorMinOrderByAggregateInput
    _sum?: Inscripcion_tutorSumOrderByAggregateInput
  }

  export type Inscripcion_tutorScalarWhereWithAggregatesInput = {
    AND?: Inscripcion_tutorScalarWhereWithAggregatesInput | Inscripcion_tutorScalarWhereWithAggregatesInput[]
    OR?: Inscripcion_tutorScalarWhereWithAggregatesInput[]
    NOT?: Inscripcion_tutorScalarWhereWithAggregatesInput | Inscripcion_tutorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Inscripcion_tutor"> | number
    inscripcion_id?: IntWithAggregatesFilter<"Inscripcion_tutor"> | number
    tutor_id?: StringWithAggregatesFilter<"Inscripcion_tutor"> | string
    aprobado?: BoolWithAggregatesFilter<"Inscripcion_tutor"> | boolean
    fecha_aprobacion?: DateTimeNullableWithAggregatesFilter<"Inscripcion_tutor"> | Date | string | null
    motivo_rechazo_id?: IntNullableWithAggregatesFilter<"Inscripcion_tutor"> | number | null
    descripcion_rechazo?: StringNullableWithAggregatesFilter<"Inscripcion_tutor"> | string | null
    competidorId?: StringNullableWithAggregatesFilter<"Inscripcion_tutor"> | string | null
  }

  export type Metodo_pagoWhereInput = {
    AND?: Metodo_pagoWhereInput | Metodo_pagoWhereInput[]
    OR?: Metodo_pagoWhereInput[]
    NOT?: Metodo_pagoWhereInput | Metodo_pagoWhereInput[]
    id?: IntFilter<"Metodo_pago"> | number
    nombre?: StringFilter<"Metodo_pago"> | string
    Pago?: PagoListRelationFilter
  }

  export type Metodo_pagoOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    Pago?: PagoOrderByRelationAggregateInput
  }

  export type Metodo_pagoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nombre?: string
    AND?: Metodo_pagoWhereInput | Metodo_pagoWhereInput[]
    OR?: Metodo_pagoWhereInput[]
    NOT?: Metodo_pagoWhereInput | Metodo_pagoWhereInput[]
    Pago?: PagoListRelationFilter
  }, "id" | "nombre">

  export type Metodo_pagoOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    _count?: Metodo_pagoCountOrderByAggregateInput
    _avg?: Metodo_pagoAvgOrderByAggregateInput
    _max?: Metodo_pagoMaxOrderByAggregateInput
    _min?: Metodo_pagoMinOrderByAggregateInput
    _sum?: Metodo_pagoSumOrderByAggregateInput
  }

  export type Metodo_pagoScalarWhereWithAggregatesInput = {
    AND?: Metodo_pagoScalarWhereWithAggregatesInput | Metodo_pagoScalarWhereWithAggregatesInput[]
    OR?: Metodo_pagoScalarWhereWithAggregatesInput[]
    NOT?: Metodo_pagoScalarWhereWithAggregatesInput | Metodo_pagoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Metodo_pago"> | number
    nombre?: StringWithAggregatesFilter<"Metodo_pago"> | string
  }

  export type estado_convocatoriaWhereInput = {
    AND?: estado_convocatoriaWhereInput | estado_convocatoriaWhereInput[]
    OR?: estado_convocatoriaWhereInput[]
    NOT?: estado_convocatoriaWhereInput | estado_convocatoriaWhereInput[]
    id?: IntFilter<"estado_convocatoria"> | number
    nombre?: StringFilter<"estado_convocatoria"> | string
    Convocatoria?: ConvocatoriaListRelationFilter
  }

  export type estado_convocatoriaOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    Convocatoria?: ConvocatoriaOrderByRelationAggregateInput
  }

  export type estado_convocatoriaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nombre?: string
    AND?: estado_convocatoriaWhereInput | estado_convocatoriaWhereInput[]
    OR?: estado_convocatoriaWhereInput[]
    NOT?: estado_convocatoriaWhereInput | estado_convocatoriaWhereInput[]
    Convocatoria?: ConvocatoriaListRelationFilter
  }, "id" | "nombre">

  export type estado_convocatoriaOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    _count?: estado_convocatoriaCountOrderByAggregateInput
    _avg?: estado_convocatoriaAvgOrderByAggregateInput
    _max?: estado_convocatoriaMaxOrderByAggregateInput
    _min?: estado_convocatoriaMinOrderByAggregateInput
    _sum?: estado_convocatoriaSumOrderByAggregateInput
  }

  export type estado_convocatoriaScalarWhereWithAggregatesInput = {
    AND?: estado_convocatoriaScalarWhereWithAggregatesInput | estado_convocatoriaScalarWhereWithAggregatesInput[]
    OR?: estado_convocatoriaScalarWhereWithAggregatesInput[]
    NOT?: estado_convocatoriaScalarWhereWithAggregatesInput | estado_convocatoriaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"estado_convocatoria"> | number
    nombre?: StringWithAggregatesFilter<"estado_convocatoria"> | string
  }

  export type InscripcionWhereInput = {
    AND?: InscripcionWhereInput | InscripcionWhereInput[]
    OR?: InscripcionWhereInput[]
    NOT?: InscripcionWhereInput | InscripcionWhereInput[]
    id?: IntFilter<"Inscripcion"> | number
    competidor_id?: StringFilter<"Inscripcion"> | string
    area_id?: IntFilter<"Inscripcion"> | number
    convocatoria_id?: IntFilter<"Inscripcion"> | number
    categoria_id?: IntFilter<"Inscripcion"> | number
    fecha_inscripcion?: DateTimeFilter<"Inscripcion"> | Date | string
    estado_inscripcion?: StringFilter<"Inscripcion"> | string
    tutorInscripciones?: Inscripcion_tutorListRelationFilter
    pagos?: PagoListRelationFilter
    competidor?: XOR<CompetidorScalarRelationFilter, CompetidorWhereInput>
    area?: XOR<AreaScalarRelationFilter, AreaWhereInput>
    convocatoria?: XOR<ConvocatoriaScalarRelationFilter, ConvocatoriaWhereInput>
    categoria?: XOR<CategoriaScalarRelationFilter, CategoriaWhereInput>
  }

  export type InscripcionOrderByWithRelationInput = {
    id?: SortOrder
    competidor_id?: SortOrder
    area_id?: SortOrder
    convocatoria_id?: SortOrder
    categoria_id?: SortOrder
    fecha_inscripcion?: SortOrder
    estado_inscripcion?: SortOrder
    tutorInscripciones?: Inscripcion_tutorOrderByRelationAggregateInput
    pagos?: PagoOrderByRelationAggregateInput
    competidor?: CompetidorOrderByWithRelationInput
    area?: AreaOrderByWithRelationInput
    convocatoria?: ConvocatoriaOrderByWithRelationInput
    categoria?: CategoriaOrderByWithRelationInput
  }

  export type InscripcionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: InscripcionWhereInput | InscripcionWhereInput[]
    OR?: InscripcionWhereInput[]
    NOT?: InscripcionWhereInput | InscripcionWhereInput[]
    competidor_id?: StringFilter<"Inscripcion"> | string
    area_id?: IntFilter<"Inscripcion"> | number
    convocatoria_id?: IntFilter<"Inscripcion"> | number
    categoria_id?: IntFilter<"Inscripcion"> | number
    fecha_inscripcion?: DateTimeFilter<"Inscripcion"> | Date | string
    estado_inscripcion?: StringFilter<"Inscripcion"> | string
    tutorInscripciones?: Inscripcion_tutorListRelationFilter
    pagos?: PagoListRelationFilter
    competidor?: XOR<CompetidorScalarRelationFilter, CompetidorWhereInput>
    area?: XOR<AreaScalarRelationFilter, AreaWhereInput>
    convocatoria?: XOR<ConvocatoriaScalarRelationFilter, ConvocatoriaWhereInput>
    categoria?: XOR<CategoriaScalarRelationFilter, CategoriaWhereInput>
  }, "id">

  export type InscripcionOrderByWithAggregationInput = {
    id?: SortOrder
    competidor_id?: SortOrder
    area_id?: SortOrder
    convocatoria_id?: SortOrder
    categoria_id?: SortOrder
    fecha_inscripcion?: SortOrder
    estado_inscripcion?: SortOrder
    _count?: InscripcionCountOrderByAggregateInput
    _avg?: InscripcionAvgOrderByAggregateInput
    _max?: InscripcionMaxOrderByAggregateInput
    _min?: InscripcionMinOrderByAggregateInput
    _sum?: InscripcionSumOrderByAggregateInput
  }

  export type InscripcionScalarWhereWithAggregatesInput = {
    AND?: InscripcionScalarWhereWithAggregatesInput | InscripcionScalarWhereWithAggregatesInput[]
    OR?: InscripcionScalarWhereWithAggregatesInput[]
    NOT?: InscripcionScalarWhereWithAggregatesInput | InscripcionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Inscripcion"> | number
    competidor_id?: StringWithAggregatesFilter<"Inscripcion"> | string
    area_id?: IntWithAggregatesFilter<"Inscripcion"> | number
    convocatoria_id?: IntWithAggregatesFilter<"Inscripcion"> | number
    categoria_id?: IntWithAggregatesFilter<"Inscripcion"> | number
    fecha_inscripcion?: DateTimeWithAggregatesFilter<"Inscripcion"> | Date | string
    estado_inscripcion?: StringWithAggregatesFilter<"Inscripcion"> | string
  }

  export type NivelWhereInput = {
    AND?: NivelWhereInput | NivelWhereInput[]
    OR?: NivelWhereInput[]
    NOT?: NivelWhereInput | NivelWhereInput[]
    id?: IntFilter<"Nivel"> | number
    nombre_nivel?: StringFilter<"Nivel"> | string
    Grado?: GradoListRelationFilter
  }

  export type NivelOrderByWithRelationInput = {
    id?: SortOrder
    nombre_nivel?: SortOrder
    Grado?: GradoOrderByRelationAggregateInput
  }

  export type NivelWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: NivelWhereInput | NivelWhereInput[]
    OR?: NivelWhereInput[]
    NOT?: NivelWhereInput | NivelWhereInput[]
    nombre_nivel?: StringFilter<"Nivel"> | string
    Grado?: GradoListRelationFilter
  }, "id">

  export type NivelOrderByWithAggregationInput = {
    id?: SortOrder
    nombre_nivel?: SortOrder
    _count?: NivelCountOrderByAggregateInput
    _avg?: NivelAvgOrderByAggregateInput
    _max?: NivelMaxOrderByAggregateInput
    _min?: NivelMinOrderByAggregateInput
    _sum?: NivelSumOrderByAggregateInput
  }

  export type NivelScalarWhereWithAggregatesInput = {
    AND?: NivelScalarWhereWithAggregatesInput | NivelScalarWhereWithAggregatesInput[]
    OR?: NivelScalarWhereWithAggregatesInput[]
    NOT?: NivelScalarWhereWithAggregatesInput | NivelScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Nivel"> | number
    nombre_nivel?: StringWithAggregatesFilter<"Nivel"> | string
  }

  export type NotificacionWhereInput = {
    AND?: NotificacionWhereInput | NotificacionWhereInput[]
    OR?: NotificacionWhereInput[]
    NOT?: NotificacionWhereInput | NotificacionWhereInput[]
    id?: IntFilter<"Notificacion"> | number
    usuarioId?: StringFilter<"Notificacion"> | string
    tipo?: StringFilter<"Notificacion"> | string
    mensaje?: StringFilter<"Notificacion"> | string
    leido?: BoolFilter<"Notificacion"> | boolean
    createdAt?: DateTimeFilter<"Notificacion"> | Date | string
    usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
  }

  export type NotificacionOrderByWithRelationInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    tipo?: SortOrder
    mensaje?: SortOrder
    leido?: SortOrder
    createdAt?: SortOrder
    usuario?: UsuarioOrderByWithRelationInput
  }

  export type NotificacionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: NotificacionWhereInput | NotificacionWhereInput[]
    OR?: NotificacionWhereInput[]
    NOT?: NotificacionWhereInput | NotificacionWhereInput[]
    usuarioId?: StringFilter<"Notificacion"> | string
    tipo?: StringFilter<"Notificacion"> | string
    mensaje?: StringFilter<"Notificacion"> | string
    leido?: BoolFilter<"Notificacion"> | boolean
    createdAt?: DateTimeFilter<"Notificacion"> | Date | string
    usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
  }, "id">

  export type NotificacionOrderByWithAggregationInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    tipo?: SortOrder
    mensaje?: SortOrder
    leido?: SortOrder
    createdAt?: SortOrder
    _count?: NotificacionCountOrderByAggregateInput
    _avg?: NotificacionAvgOrderByAggregateInput
    _max?: NotificacionMaxOrderByAggregateInput
    _min?: NotificacionMinOrderByAggregateInput
    _sum?: NotificacionSumOrderByAggregateInput
  }

  export type NotificacionScalarWhereWithAggregatesInput = {
    AND?: NotificacionScalarWhereWithAggregatesInput | NotificacionScalarWhereWithAggregatesInput[]
    OR?: NotificacionScalarWhereWithAggregatesInput[]
    NOT?: NotificacionScalarWhereWithAggregatesInput | NotificacionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Notificacion"> | number
    usuarioId?: StringWithAggregatesFilter<"Notificacion"> | string
    tipo?: StringWithAggregatesFilter<"Notificacion"> | string
    mensaje?: StringWithAggregatesFilter<"Notificacion"> | string
    leido?: BoolWithAggregatesFilter<"Notificacion"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notificacion"> | Date | string
  }

  export type Motivo_rechazoWhereInput = {
    AND?: Motivo_rechazoWhereInput | Motivo_rechazoWhereInput[]
    OR?: Motivo_rechazoWhereInput[]
    NOT?: Motivo_rechazoWhereInput | Motivo_rechazoWhereInput[]
    id?: IntFilter<"Motivo_rechazo"> | number
    mensaje?: StringFilter<"Motivo_rechazo"> | string
    inscripcionesTutor?: Inscripcion_tutorListRelationFilter
  }

  export type Motivo_rechazoOrderByWithRelationInput = {
    id?: SortOrder
    mensaje?: SortOrder
    inscripcionesTutor?: Inscripcion_tutorOrderByRelationAggregateInput
  }

  export type Motivo_rechazoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: Motivo_rechazoWhereInput | Motivo_rechazoWhereInput[]
    OR?: Motivo_rechazoWhereInput[]
    NOT?: Motivo_rechazoWhereInput | Motivo_rechazoWhereInput[]
    mensaje?: StringFilter<"Motivo_rechazo"> | string
    inscripcionesTutor?: Inscripcion_tutorListRelationFilter
  }, "id">

  export type Motivo_rechazoOrderByWithAggregationInput = {
    id?: SortOrder
    mensaje?: SortOrder
    _count?: Motivo_rechazoCountOrderByAggregateInput
    _avg?: Motivo_rechazoAvgOrderByAggregateInput
    _max?: Motivo_rechazoMaxOrderByAggregateInput
    _min?: Motivo_rechazoMinOrderByAggregateInput
    _sum?: Motivo_rechazoSumOrderByAggregateInput
  }

  export type Motivo_rechazoScalarWhereWithAggregatesInput = {
    AND?: Motivo_rechazoScalarWhereWithAggregatesInput | Motivo_rechazoScalarWhereWithAggregatesInput[]
    OR?: Motivo_rechazoScalarWhereWithAggregatesInput[]
    NOT?: Motivo_rechazoScalarWhereWithAggregatesInput | Motivo_rechazoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Motivo_rechazo"> | number
    mensaje?: StringWithAggregatesFilter<"Motivo_rechazo"> | string
  }

  export type UsuarioCreateInput = {
    id?: string
    correo_electronico: string
    nombre: string
    apellido: string
    estado?: boolean
    password: string
    createdAt?: Date | string
    competidor?: CompetidorCreateNestedOneWithoutUsuarioInput
    tutor?: TutorCreateNestedOneWithoutUsuarioInput
    role: RolCreateNestedOneWithoutUsuariosInput
    Notificacion?: NotificacionCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateInput = {
    id?: string
    correo_electronico: string
    nombre: string
    apellido: string
    estado?: boolean
    password: string
    rol_id: number
    createdAt?: Date | string
    competidor?: CompetidorUncheckedCreateNestedOneWithoutUsuarioInput
    tutor?: TutorUncheckedCreateNestedOneWithoutUsuarioInput
    Notificacion?: NotificacionUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    correo_electronico?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    competidor?: CompetidorUpdateOneWithoutUsuarioNestedInput
    tutor?: TutorUpdateOneWithoutUsuarioNestedInput
    role?: RolUpdateOneRequiredWithoutUsuariosNestedInput
    Notificacion?: NotificacionUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    correo_electronico?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    rol_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    competidor?: CompetidorUncheckedUpdateOneWithoutUsuarioNestedInput
    tutor?: TutorUncheckedUpdateOneWithoutUsuarioNestedInput
    Notificacion?: NotificacionUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioCreateManyInput = {
    id?: string
    correo_electronico: string
    nombre: string
    apellido: string
    estado?: boolean
    password: string
    rol_id: number
    createdAt?: Date | string
  }

  export type UsuarioUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    correo_electronico?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsuarioUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    correo_electronico?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    rol_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolCreateInput = {
    nombre: string
    roles?: Rol_permisoCreateNestedManyWithoutRolInput
    usuarios?: UsuarioCreateNestedManyWithoutRoleInput
  }

  export type RolUncheckedCreateInput = {
    id?: number
    nombre: string
    roles?: Rol_permisoUncheckedCreateNestedManyWithoutRolInput
    usuarios?: UsuarioUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RolUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    roles?: Rol_permisoUpdateManyWithoutRolNestedInput
    usuarios?: UsuarioUpdateManyWithoutRoleNestedInput
  }

  export type RolUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    roles?: Rol_permisoUncheckedUpdateManyWithoutRolNestedInput
    usuarios?: UsuarioUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RolCreateManyInput = {
    id?: number
    nombre: string
  }

  export type RolUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type RolUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type PermisoCreateInput = {
    nombre: string
    descripcion: string
    roles?: Rol_permisoCreateNestedManyWithoutPermisoInput
  }

  export type PermisoUncheckedCreateInput = {
    id?: number
    nombre: string
    descripcion: string
    roles?: Rol_permisoUncheckedCreateNestedManyWithoutPermisoInput
  }

  export type PermisoUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    roles?: Rol_permisoUpdateManyWithoutPermisoNestedInput
  }

  export type PermisoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    roles?: Rol_permisoUncheckedUpdateManyWithoutPermisoNestedInput
  }

  export type PermisoCreateManyInput = {
    id?: number
    nombre: string
    descripcion: string
  }

  export type PermisoUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type PermisoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type Rol_permisoCreateInput = {
    permiso: PermisoCreateNestedOneWithoutRolesInput
    rol: RolCreateNestedOneWithoutRolesInput
  }

  export type Rol_permisoUncheckedCreateInput = {
    id?: number
    rol_id: number
    permiso_id: number
  }

  export type Rol_permisoUpdateInput = {
    permiso?: PermisoUpdateOneRequiredWithoutRolesNestedInput
    rol?: RolUpdateOneRequiredWithoutRolesNestedInput
  }

  export type Rol_permisoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    rol_id?: IntFieldUpdateOperationsInput | number
    permiso_id?: IntFieldUpdateOperationsInput | number
  }

  export type Rol_permisoCreateManyInput = {
    id?: number
    rol_id: number
    permiso_id: number
  }

  export type Rol_permisoUpdateManyMutationInput = {

  }

  export type Rol_permisoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    rol_id?: IntFieldUpdateOperationsInput | number
    permiso_id?: IntFieldUpdateOperationsInput | number
  }

  export type CompetidorCreateInput = {
    id?: string
    carnet_identidad: string
    fecha_nacimiento: Date | string
    colegio: ColegioCreateNestedOneWithoutCompetidoresInput
    provincia: ProvinciaCreateNestedOneWithoutCompetidorInput
    usuario: UsuarioCreateNestedOneWithoutCompetidorInput
    Inscripciones?: Inscripcion_tutorCreateNestedManyWithoutCompetidorInput
    Inscripcion?: InscripcionCreateNestedManyWithoutCompetidorInput
  }

  export type CompetidorUncheckedCreateInput = {
    id?: string
    usuario_id: string
    colegio_id: number
    provincia_id: number
    carnet_identidad: string
    fecha_nacimiento: Date | string
    Inscripciones?: Inscripcion_tutorUncheckedCreateNestedManyWithoutCompetidorInput
    Inscripcion?: InscripcionUncheckedCreateNestedManyWithoutCompetidorInput
  }

  export type CompetidorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    carnet_identidad?: StringFieldUpdateOperationsInput | string
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    colegio?: ColegioUpdateOneRequiredWithoutCompetidoresNestedInput
    provincia?: ProvinciaUpdateOneRequiredWithoutCompetidorNestedInput
    usuario?: UsuarioUpdateOneRequiredWithoutCompetidorNestedInput
    Inscripciones?: Inscripcion_tutorUpdateManyWithoutCompetidorNestedInput
    Inscripcion?: InscripcionUpdateManyWithoutCompetidorNestedInput
  }

  export type CompetidorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuario_id?: StringFieldUpdateOperationsInput | string
    colegio_id?: IntFieldUpdateOperationsInput | number
    provincia_id?: IntFieldUpdateOperationsInput | number
    carnet_identidad?: StringFieldUpdateOperationsInput | string
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    Inscripciones?: Inscripcion_tutorUncheckedUpdateManyWithoutCompetidorNestedInput
    Inscripcion?: InscripcionUncheckedUpdateManyWithoutCompetidorNestedInput
  }

  export type CompetidorCreateManyInput = {
    id?: string
    usuario_id: string
    colegio_id: number
    provincia_id: number
    carnet_identidad: string
    fecha_nacimiento: Date | string
  }

  export type CompetidorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    carnet_identidad?: StringFieldUpdateOperationsInput | string
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompetidorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuario_id?: StringFieldUpdateOperationsInput | string
    colegio_id?: IntFieldUpdateOperationsInput | number
    provincia_id?: IntFieldUpdateOperationsInput | number
    carnet_identidad?: StringFieldUpdateOperationsInput | string
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TutorCreateInput = {
    id?: string
    carnet_identidad: string
    numero_celular: string
    Inscripciones_tutor?: Inscripcion_tutorCreateNestedManyWithoutTutorInput
    area: AreaCreateNestedOneWithoutTutorInput
    usuario: UsuarioCreateNestedOneWithoutTutorInput
  }

  export type TutorUncheckedCreateInput = {
    id?: string
    usuario_id: string
    carnet_identidad: string
    numero_celular: string
    area_id: number
    Inscripciones_tutor?: Inscripcion_tutorUncheckedCreateNestedManyWithoutTutorInput
  }

  export type TutorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    carnet_identidad?: StringFieldUpdateOperationsInput | string
    numero_celular?: StringFieldUpdateOperationsInput | string
    Inscripciones_tutor?: Inscripcion_tutorUpdateManyWithoutTutorNestedInput
    area?: AreaUpdateOneRequiredWithoutTutorNestedInput
    usuario?: UsuarioUpdateOneRequiredWithoutTutorNestedInput
  }

  export type TutorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuario_id?: StringFieldUpdateOperationsInput | string
    carnet_identidad?: StringFieldUpdateOperationsInput | string
    numero_celular?: StringFieldUpdateOperationsInput | string
    area_id?: IntFieldUpdateOperationsInput | number
    Inscripciones_tutor?: Inscripcion_tutorUncheckedUpdateManyWithoutTutorNestedInput
  }

  export type TutorCreateManyInput = {
    id?: string
    usuario_id: string
    carnet_identidad: string
    numero_celular: string
    area_id: number
  }

  export type TutorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    carnet_identidad?: StringFieldUpdateOperationsInput | string
    numero_celular?: StringFieldUpdateOperationsInput | string
  }

  export type TutorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuario_id?: StringFieldUpdateOperationsInput | string
    carnet_identidad?: StringFieldUpdateOperationsInput | string
    numero_celular?: StringFieldUpdateOperationsInput | string
    area_id?: IntFieldUpdateOperationsInput | number
  }

  export type DepartamentoCreateInput = {
    nombre_departamento: string
    Provincia?: ProvinciaCreateNestedManyWithoutDepartamentoInput
  }

  export type DepartamentoUncheckedCreateInput = {
    id?: number
    nombre_departamento: string
    Provincia?: ProvinciaUncheckedCreateNestedManyWithoutDepartamentoInput
  }

  export type DepartamentoUpdateInput = {
    nombre_departamento?: StringFieldUpdateOperationsInput | string
    Provincia?: ProvinciaUpdateManyWithoutDepartamentoNestedInput
  }

  export type DepartamentoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre_departamento?: StringFieldUpdateOperationsInput | string
    Provincia?: ProvinciaUncheckedUpdateManyWithoutDepartamentoNestedInput
  }

  export type DepartamentoCreateManyInput = {
    id?: number
    nombre_departamento: string
  }

  export type DepartamentoUpdateManyMutationInput = {
    nombre_departamento?: StringFieldUpdateOperationsInput | string
  }

  export type DepartamentoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre_departamento?: StringFieldUpdateOperationsInput | string
  }

  export type ProvinciaCreateInput = {
    nombre_provincia: string
    Colegio?: ColegioCreateNestedManyWithoutProvinciaInput
    Competidor?: CompetidorCreateNestedManyWithoutProvinciaInput
    departamento: DepartamentoCreateNestedOneWithoutProvinciaInput
  }

  export type ProvinciaUncheckedCreateInput = {
    id?: number
    nombre_provincia: string
    departamento_id: number
    Colegio?: ColegioUncheckedCreateNestedManyWithoutProvinciaInput
    Competidor?: CompetidorUncheckedCreateNestedManyWithoutProvinciaInput
  }

  export type ProvinciaUpdateInput = {
    nombre_provincia?: StringFieldUpdateOperationsInput | string
    Colegio?: ColegioUpdateManyWithoutProvinciaNestedInput
    Competidor?: CompetidorUpdateManyWithoutProvinciaNestedInput
    departamento?: DepartamentoUpdateOneRequiredWithoutProvinciaNestedInput
  }

  export type ProvinciaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre_provincia?: StringFieldUpdateOperationsInput | string
    departamento_id?: IntFieldUpdateOperationsInput | number
    Colegio?: ColegioUncheckedUpdateManyWithoutProvinciaNestedInput
    Competidor?: CompetidorUncheckedUpdateManyWithoutProvinciaNestedInput
  }

  export type ProvinciaCreateManyInput = {
    id?: number
    nombre_provincia: string
    departamento_id: number
  }

  export type ProvinciaUpdateManyMutationInput = {
    nombre_provincia?: StringFieldUpdateOperationsInput | string
  }

  export type ProvinciaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre_provincia?: StringFieldUpdateOperationsInput | string
    departamento_id?: IntFieldUpdateOperationsInput | number
  }

  export type ColegioCreateInput = {
    nombre_colegio: string
    provincia: ProvinciaCreateNestedOneWithoutColegioInput
    Competidores?: CompetidorCreateNestedManyWithoutColegioInput
  }

  export type ColegioUncheckedCreateInput = {
    id?: number
    nombre_colegio: string
    provincia_id: number
    Competidores?: CompetidorUncheckedCreateNestedManyWithoutColegioInput
  }

  export type ColegioUpdateInput = {
    nombre_colegio?: StringFieldUpdateOperationsInput | string
    provincia?: ProvinciaUpdateOneRequiredWithoutColegioNestedInput
    Competidores?: CompetidorUpdateManyWithoutColegioNestedInput
  }

  export type ColegioUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre_colegio?: StringFieldUpdateOperationsInput | string
    provincia_id?: IntFieldUpdateOperationsInput | number
    Competidores?: CompetidorUncheckedUpdateManyWithoutColegioNestedInput
  }

  export type ColegioCreateManyInput = {
    id?: number
    nombre_colegio: string
    provincia_id: number
  }

  export type ColegioUpdateManyMutationInput = {
    nombre_colegio?: StringFieldUpdateOperationsInput | string
  }

  export type ColegioUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre_colegio?: StringFieldUpdateOperationsInput | string
    provincia_id?: IntFieldUpdateOperationsInput | number
  }

  export type ConvocatoriaCreateInput = {
    nombre_convocatoria: string
    fecha_inicio: Date | string
    fecha_fin: Date | string
    pago_fin: Date | string
    pago_inicio: Date | string
    competicion_inicio: Date | string
    competicion_fin: Date | string
    descripcion_convocatoria: string
    Area_convocatoria?: Area_convocatoriaCreateNestedManyWithoutConvocatoriaInput
    estado_convocatoria: estado_convocatoriaCreateNestedOneWithoutConvocatoriaInput
    Inscripcion?: InscripcionCreateNestedManyWithoutConvocatoriaInput
  }

  export type ConvocatoriaUncheckedCreateInput = {
    id?: number
    nombre_convocatoria: string
    id_estado_convocatoria: number
    fecha_inicio: Date | string
    fecha_fin: Date | string
    pago_fin: Date | string
    pago_inicio: Date | string
    competicion_inicio: Date | string
    competicion_fin: Date | string
    descripcion_convocatoria: string
    Area_convocatoria?: Area_convocatoriaUncheckedCreateNestedManyWithoutConvocatoriaInput
    Inscripcion?: InscripcionUncheckedCreateNestedManyWithoutConvocatoriaInput
  }

  export type ConvocatoriaUpdateInput = {
    nombre_convocatoria?: StringFieldUpdateOperationsInput | string
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    pago_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    pago_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    competicion_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    competicion_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    descripcion_convocatoria?: StringFieldUpdateOperationsInput | string
    Area_convocatoria?: Area_convocatoriaUpdateManyWithoutConvocatoriaNestedInput
    estado_convocatoria?: estado_convocatoriaUpdateOneRequiredWithoutConvocatoriaNestedInput
    Inscripcion?: InscripcionUpdateManyWithoutConvocatoriaNestedInput
  }

  export type ConvocatoriaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre_convocatoria?: StringFieldUpdateOperationsInput | string
    id_estado_convocatoria?: IntFieldUpdateOperationsInput | number
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    pago_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    pago_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    competicion_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    competicion_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    descripcion_convocatoria?: StringFieldUpdateOperationsInput | string
    Area_convocatoria?: Area_convocatoriaUncheckedUpdateManyWithoutConvocatoriaNestedInput
    Inscripcion?: InscripcionUncheckedUpdateManyWithoutConvocatoriaNestedInput
  }

  export type ConvocatoriaCreateManyInput = {
    id?: number
    nombre_convocatoria: string
    id_estado_convocatoria: number
    fecha_inicio: Date | string
    fecha_fin: Date | string
    pago_fin: Date | string
    pago_inicio: Date | string
    competicion_inicio: Date | string
    competicion_fin: Date | string
    descripcion_convocatoria: string
  }

  export type ConvocatoriaUpdateManyMutationInput = {
    nombre_convocatoria?: StringFieldUpdateOperationsInput | string
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    pago_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    pago_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    competicion_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    competicion_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    descripcion_convocatoria?: StringFieldUpdateOperationsInput | string
  }

  export type ConvocatoriaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre_convocatoria?: StringFieldUpdateOperationsInput | string
    id_estado_convocatoria?: IntFieldUpdateOperationsInput | number
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    pago_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    pago_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    competicion_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    competicion_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    descripcion_convocatoria?: StringFieldUpdateOperationsInput | string
  }

  export type AreaCreateInput = {
    nombre_area: string
    descripcion_area: string
    costo: Decimal | DecimalJsLike | number | string
    Area_convocatoria?: Area_convocatoriaCreateNestedManyWithoutAreaInput
    area_categoria?: Categoria_areaCreateNestedManyWithoutAreaInput
    Tutor?: TutorCreateNestedManyWithoutAreaInput
    Inscripcion?: InscripcionCreateNestedManyWithoutAreaInput
  }

  export type AreaUncheckedCreateInput = {
    id?: number
    nombre_area: string
    descripcion_area: string
    costo: Decimal | DecimalJsLike | number | string
    Area_convocatoria?: Area_convocatoriaUncheckedCreateNestedManyWithoutAreaInput
    area_categoria?: Categoria_areaUncheckedCreateNestedManyWithoutAreaInput
    Tutor?: TutorUncheckedCreateNestedManyWithoutAreaInput
    Inscripcion?: InscripcionUncheckedCreateNestedManyWithoutAreaInput
  }

  export type AreaUpdateInput = {
    nombre_area?: StringFieldUpdateOperationsInput | string
    descripcion_area?: StringFieldUpdateOperationsInput | string
    costo?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Area_convocatoria?: Area_convocatoriaUpdateManyWithoutAreaNestedInput
    area_categoria?: Categoria_areaUpdateManyWithoutAreaNestedInput
    Tutor?: TutorUpdateManyWithoutAreaNestedInput
    Inscripcion?: InscripcionUpdateManyWithoutAreaNestedInput
  }

  export type AreaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre_area?: StringFieldUpdateOperationsInput | string
    descripcion_area?: StringFieldUpdateOperationsInput | string
    costo?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Area_convocatoria?: Area_convocatoriaUncheckedUpdateManyWithoutAreaNestedInput
    area_categoria?: Categoria_areaUncheckedUpdateManyWithoutAreaNestedInput
    Tutor?: TutorUncheckedUpdateManyWithoutAreaNestedInput
    Inscripcion?: InscripcionUncheckedUpdateManyWithoutAreaNestedInput
  }

  export type AreaCreateManyInput = {
    id?: number
    nombre_area: string
    descripcion_area: string
    costo: Decimal | DecimalJsLike | number | string
  }

  export type AreaUpdateManyMutationInput = {
    nombre_area?: StringFieldUpdateOperationsInput | string
    descripcion_area?: StringFieldUpdateOperationsInput | string
    costo?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type AreaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre_area?: StringFieldUpdateOperationsInput | string
    descripcion_area?: StringFieldUpdateOperationsInput | string
    costo?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type CategoriaCreateInput = {
    nombre_categoria: string
    descripcion_cat: string
    grado_max: GradoCreateNestedOneWithoutCategorias_maxInput
    grado_min: GradoCreateNestedOneWithoutCategorias_minInput
    Categoria_convocatoria?: Categoria_areaCreateNestedManyWithoutCategoriaInput
    Inscripcion?: InscripcionCreateNestedManyWithoutCategoriaInput
  }

  export type CategoriaUncheckedCreateInput = {
    id?: number
    nombre_categoria: string
    grado_min_id: number
    grado_max_id: number
    descripcion_cat: string
    Categoria_convocatoria?: Categoria_areaUncheckedCreateNestedManyWithoutCategoriaInput
    Inscripcion?: InscripcionUncheckedCreateNestedManyWithoutCategoriaInput
  }

  export type CategoriaUpdateInput = {
    nombre_categoria?: StringFieldUpdateOperationsInput | string
    descripcion_cat?: StringFieldUpdateOperationsInput | string
    grado_max?: GradoUpdateOneRequiredWithoutCategorias_maxNestedInput
    grado_min?: GradoUpdateOneRequiredWithoutCategorias_minNestedInput
    Categoria_convocatoria?: Categoria_areaUpdateManyWithoutCategoriaNestedInput
    Inscripcion?: InscripcionUpdateManyWithoutCategoriaNestedInput
  }

  export type CategoriaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre_categoria?: StringFieldUpdateOperationsInput | string
    grado_min_id?: IntFieldUpdateOperationsInput | number
    grado_max_id?: IntFieldUpdateOperationsInput | number
    descripcion_cat?: StringFieldUpdateOperationsInput | string
    Categoria_convocatoria?: Categoria_areaUncheckedUpdateManyWithoutCategoriaNestedInput
    Inscripcion?: InscripcionUncheckedUpdateManyWithoutCategoriaNestedInput
  }

  export type CategoriaCreateManyInput = {
    id?: number
    nombre_categoria: string
    grado_min_id: number
    grado_max_id: number
    descripcion_cat: string
  }

  export type CategoriaUpdateManyMutationInput = {
    nombre_categoria?: StringFieldUpdateOperationsInput | string
    descripcion_cat?: StringFieldUpdateOperationsInput | string
  }

  export type CategoriaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre_categoria?: StringFieldUpdateOperationsInput | string
    grado_min_id?: IntFieldUpdateOperationsInput | number
    grado_max_id?: IntFieldUpdateOperationsInput | number
    descripcion_cat?: StringFieldUpdateOperationsInput | string
  }

  export type GradoCreateInput = {
    nombre_grado: string
    categorias_max?: CategoriaCreateNestedManyWithoutGrado_maxInput
    categorias_min?: CategoriaCreateNestedManyWithoutGrado_minInput
    nivel: NivelCreateNestedOneWithoutGradoInput
  }

  export type GradoUncheckedCreateInput = {
    id?: number
    nombre_grado: string
    id_nivel: number
    categorias_max?: CategoriaUncheckedCreateNestedManyWithoutGrado_maxInput
    categorias_min?: CategoriaUncheckedCreateNestedManyWithoutGrado_minInput
  }

  export type GradoUpdateInput = {
    nombre_grado?: StringFieldUpdateOperationsInput | string
    categorias_max?: CategoriaUpdateManyWithoutGrado_maxNestedInput
    categorias_min?: CategoriaUpdateManyWithoutGrado_minNestedInput
    nivel?: NivelUpdateOneRequiredWithoutGradoNestedInput
  }

  export type GradoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre_grado?: StringFieldUpdateOperationsInput | string
    id_nivel?: IntFieldUpdateOperationsInput | number
    categorias_max?: CategoriaUncheckedUpdateManyWithoutGrado_maxNestedInput
    categorias_min?: CategoriaUncheckedUpdateManyWithoutGrado_minNestedInput
  }

  export type GradoCreateManyInput = {
    id?: number
    nombre_grado: string
    id_nivel: number
  }

  export type GradoUpdateManyMutationInput = {
    nombre_grado?: StringFieldUpdateOperationsInput | string
  }

  export type GradoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre_grado?: StringFieldUpdateOperationsInput | string
    id_nivel?: IntFieldUpdateOperationsInput | number
  }

  export type PagoCreateInput = {
    monto: Decimal | DecimalJsLike | number | string
    estado?: string
    codigo_pago: string
    fecha_pago?: Date | string
    inscripcion: InscripcionCreateNestedOneWithoutPagosInput
    metodo_pago: Metodo_pagoCreateNestedOneWithoutPagoInput
  }

  export type PagoUncheckedCreateInput = {
    id?: number
    inscripcion_id: number
    monto: Decimal | DecimalJsLike | number | string
    estado?: string
    codigo_pago: string
    fecha_pago?: Date | string
    metodo_pago_id: number
  }

  export type PagoUpdateInput = {
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: StringFieldUpdateOperationsInput | string
    codigo_pago?: StringFieldUpdateOperationsInput | string
    fecha_pago?: DateTimeFieldUpdateOperationsInput | Date | string
    inscripcion?: InscripcionUpdateOneRequiredWithoutPagosNestedInput
    metodo_pago?: Metodo_pagoUpdateOneRequiredWithoutPagoNestedInput
  }

  export type PagoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    inscripcion_id?: IntFieldUpdateOperationsInput | number
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: StringFieldUpdateOperationsInput | string
    codigo_pago?: StringFieldUpdateOperationsInput | string
    fecha_pago?: DateTimeFieldUpdateOperationsInput | Date | string
    metodo_pago_id?: IntFieldUpdateOperationsInput | number
  }

  export type PagoCreateManyInput = {
    id?: number
    inscripcion_id: number
    monto: Decimal | DecimalJsLike | number | string
    estado?: string
    codigo_pago: string
    fecha_pago?: Date | string
    metodo_pago_id: number
  }

  export type PagoUpdateManyMutationInput = {
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: StringFieldUpdateOperationsInput | string
    codigo_pago?: StringFieldUpdateOperationsInput | string
    fecha_pago?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PagoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    inscripcion_id?: IntFieldUpdateOperationsInput | number
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: StringFieldUpdateOperationsInput | string
    codigo_pago?: StringFieldUpdateOperationsInput | string
    fecha_pago?: DateTimeFieldUpdateOperationsInput | Date | string
    metodo_pago_id?: IntFieldUpdateOperationsInput | number
  }

  export type Area_convocatoriaCreateInput = {
    area: AreaCreateNestedOneWithoutArea_convocatoriaInput
    convocatoria: ConvocatoriaCreateNestedOneWithoutArea_convocatoriaInput
  }

  export type Area_convocatoriaUncheckedCreateInput = {
    id?: number
    area_id: number
    convocatoria_id: number
  }

  export type Area_convocatoriaUpdateInput = {
    area?: AreaUpdateOneRequiredWithoutArea_convocatoriaNestedInput
    convocatoria?: ConvocatoriaUpdateOneRequiredWithoutArea_convocatoriaNestedInput
  }

  export type Area_convocatoriaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    area_id?: IntFieldUpdateOperationsInput | number
    convocatoria_id?: IntFieldUpdateOperationsInput | number
  }

  export type Area_convocatoriaCreateManyInput = {
    id?: number
    area_id: number
    convocatoria_id: number
  }

  export type Area_convocatoriaUpdateManyMutationInput = {

  }

  export type Area_convocatoriaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    area_id?: IntFieldUpdateOperationsInput | number
    convocatoria_id?: IntFieldUpdateOperationsInput | number
  }

  export type Categoria_areaCreateInput = {
    area: AreaCreateNestedOneWithoutArea_categoriaInput
    categoria: CategoriaCreateNestedOneWithoutCategoria_convocatoriaInput
  }

  export type Categoria_areaUncheckedCreateInput = {
    id?: number
    categoria_id: number
    area_id: number
  }

  export type Categoria_areaUpdateInput = {
    area?: AreaUpdateOneRequiredWithoutArea_categoriaNestedInput
    categoria?: CategoriaUpdateOneRequiredWithoutCategoria_convocatoriaNestedInput
  }

  export type Categoria_areaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    categoria_id?: IntFieldUpdateOperationsInput | number
    area_id?: IntFieldUpdateOperationsInput | number
  }

  export type Categoria_areaCreateManyInput = {
    id?: number
    categoria_id: number
    area_id: number
  }

  export type Categoria_areaUpdateManyMutationInput = {

  }

  export type Categoria_areaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    categoria_id?: IntFieldUpdateOperationsInput | number
    area_id?: IntFieldUpdateOperationsInput | number
  }

  export type Inscripcion_tutorCreateInput = {
    aprobado?: boolean
    fecha_aprobacion?: Date | string | null
    descripcion_rechazo?: string | null
    inscripcion: InscripcionCreateNestedOneWithoutTutorInscripcionesInput
    tutor: TutorCreateNestedOneWithoutInscripciones_tutorInput
    Competidor?: CompetidorCreateNestedOneWithoutInscripcionesInput
    MotivoRechazo?: Motivo_rechazoCreateNestedOneWithoutInscripcionesTutorInput
  }

  export type Inscripcion_tutorUncheckedCreateInput = {
    id?: number
    inscripcion_id: number
    tutor_id: string
    aprobado?: boolean
    fecha_aprobacion?: Date | string | null
    motivo_rechazo_id?: number | null
    descripcion_rechazo?: string | null
    competidorId?: string | null
  }

  export type Inscripcion_tutorUpdateInput = {
    aprobado?: BoolFieldUpdateOperationsInput | boolean
    fecha_aprobacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    descripcion_rechazo?: NullableStringFieldUpdateOperationsInput | string | null
    inscripcion?: InscripcionUpdateOneRequiredWithoutTutorInscripcionesNestedInput
    tutor?: TutorUpdateOneRequiredWithoutInscripciones_tutorNestedInput
    Competidor?: CompetidorUpdateOneWithoutInscripcionesNestedInput
    MotivoRechazo?: Motivo_rechazoUpdateOneWithoutInscripcionesTutorNestedInput
  }

  export type Inscripcion_tutorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    inscripcion_id?: IntFieldUpdateOperationsInput | number
    tutor_id?: StringFieldUpdateOperationsInput | string
    aprobado?: BoolFieldUpdateOperationsInput | boolean
    fecha_aprobacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivo_rechazo_id?: NullableIntFieldUpdateOperationsInput | number | null
    descripcion_rechazo?: NullableStringFieldUpdateOperationsInput | string | null
    competidorId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Inscripcion_tutorCreateManyInput = {
    id?: number
    inscripcion_id: number
    tutor_id: string
    aprobado?: boolean
    fecha_aprobacion?: Date | string | null
    motivo_rechazo_id?: number | null
    descripcion_rechazo?: string | null
    competidorId?: string | null
  }

  export type Inscripcion_tutorUpdateManyMutationInput = {
    aprobado?: BoolFieldUpdateOperationsInput | boolean
    fecha_aprobacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    descripcion_rechazo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Inscripcion_tutorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    inscripcion_id?: IntFieldUpdateOperationsInput | number
    tutor_id?: StringFieldUpdateOperationsInput | string
    aprobado?: BoolFieldUpdateOperationsInput | boolean
    fecha_aprobacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivo_rechazo_id?: NullableIntFieldUpdateOperationsInput | number | null
    descripcion_rechazo?: NullableStringFieldUpdateOperationsInput | string | null
    competidorId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Metodo_pagoCreateInput = {
    nombre: string
    Pago?: PagoCreateNestedManyWithoutMetodo_pagoInput
  }

  export type Metodo_pagoUncheckedCreateInput = {
    id?: number
    nombre: string
    Pago?: PagoUncheckedCreateNestedManyWithoutMetodo_pagoInput
  }

  export type Metodo_pagoUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    Pago?: PagoUpdateManyWithoutMetodo_pagoNestedInput
  }

  export type Metodo_pagoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    Pago?: PagoUncheckedUpdateManyWithoutMetodo_pagoNestedInput
  }

  export type Metodo_pagoCreateManyInput = {
    id?: number
    nombre: string
  }

  export type Metodo_pagoUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type Metodo_pagoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type estado_convocatoriaCreateInput = {
    nombre: string
    Convocatoria?: ConvocatoriaCreateNestedManyWithoutEstado_convocatoriaInput
  }

  export type estado_convocatoriaUncheckedCreateInput = {
    id?: number
    nombre: string
    Convocatoria?: ConvocatoriaUncheckedCreateNestedManyWithoutEstado_convocatoriaInput
  }

  export type estado_convocatoriaUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    Convocatoria?: ConvocatoriaUpdateManyWithoutEstado_convocatoriaNestedInput
  }

  export type estado_convocatoriaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    Convocatoria?: ConvocatoriaUncheckedUpdateManyWithoutEstado_convocatoriaNestedInput
  }

  export type estado_convocatoriaCreateManyInput = {
    id?: number
    nombre: string
  }

  export type estado_convocatoriaUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type estado_convocatoriaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type InscripcionCreateInput = {
    fecha_inscripcion?: Date | string
    estado_inscripcion?: string
    tutorInscripciones?: Inscripcion_tutorCreateNestedManyWithoutInscripcionInput
    pagos?: PagoCreateNestedManyWithoutInscripcionInput
    competidor: CompetidorCreateNestedOneWithoutInscripcionInput
    area: AreaCreateNestedOneWithoutInscripcionInput
    convocatoria: ConvocatoriaCreateNestedOneWithoutInscripcionInput
    categoria: CategoriaCreateNestedOneWithoutInscripcionInput
  }

  export type InscripcionUncheckedCreateInput = {
    id?: number
    competidor_id: string
    area_id: number
    convocatoria_id: number
    categoria_id: number
    fecha_inscripcion?: Date | string
    estado_inscripcion?: string
    tutorInscripciones?: Inscripcion_tutorUncheckedCreateNestedManyWithoutInscripcionInput
    pagos?: PagoUncheckedCreateNestedManyWithoutInscripcionInput
  }

  export type InscripcionUpdateInput = {
    fecha_inscripcion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado_inscripcion?: StringFieldUpdateOperationsInput | string
    tutorInscripciones?: Inscripcion_tutorUpdateManyWithoutInscripcionNestedInput
    pagos?: PagoUpdateManyWithoutInscripcionNestedInput
    competidor?: CompetidorUpdateOneRequiredWithoutInscripcionNestedInput
    area?: AreaUpdateOneRequiredWithoutInscripcionNestedInput
    convocatoria?: ConvocatoriaUpdateOneRequiredWithoutInscripcionNestedInput
    categoria?: CategoriaUpdateOneRequiredWithoutInscripcionNestedInput
  }

  export type InscripcionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    competidor_id?: StringFieldUpdateOperationsInput | string
    area_id?: IntFieldUpdateOperationsInput | number
    convocatoria_id?: IntFieldUpdateOperationsInput | number
    categoria_id?: IntFieldUpdateOperationsInput | number
    fecha_inscripcion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado_inscripcion?: StringFieldUpdateOperationsInput | string
    tutorInscripciones?: Inscripcion_tutorUncheckedUpdateManyWithoutInscripcionNestedInput
    pagos?: PagoUncheckedUpdateManyWithoutInscripcionNestedInput
  }

  export type InscripcionCreateManyInput = {
    id?: number
    competidor_id: string
    area_id: number
    convocatoria_id: number
    categoria_id: number
    fecha_inscripcion?: Date | string
    estado_inscripcion?: string
  }

  export type InscripcionUpdateManyMutationInput = {
    fecha_inscripcion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado_inscripcion?: StringFieldUpdateOperationsInput | string
  }

  export type InscripcionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    competidor_id?: StringFieldUpdateOperationsInput | string
    area_id?: IntFieldUpdateOperationsInput | number
    convocatoria_id?: IntFieldUpdateOperationsInput | number
    categoria_id?: IntFieldUpdateOperationsInput | number
    fecha_inscripcion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado_inscripcion?: StringFieldUpdateOperationsInput | string
  }

  export type NivelCreateInput = {
    nombre_nivel: string
    Grado?: GradoCreateNestedManyWithoutNivelInput
  }

  export type NivelUncheckedCreateInput = {
    id?: number
    nombre_nivel: string
    Grado?: GradoUncheckedCreateNestedManyWithoutNivelInput
  }

  export type NivelUpdateInput = {
    nombre_nivel?: StringFieldUpdateOperationsInput | string
    Grado?: GradoUpdateManyWithoutNivelNestedInput
  }

  export type NivelUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre_nivel?: StringFieldUpdateOperationsInput | string
    Grado?: GradoUncheckedUpdateManyWithoutNivelNestedInput
  }

  export type NivelCreateManyInput = {
    id?: number
    nombre_nivel: string
  }

  export type NivelUpdateManyMutationInput = {
    nombre_nivel?: StringFieldUpdateOperationsInput | string
  }

  export type NivelUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre_nivel?: StringFieldUpdateOperationsInput | string
  }

  export type NotificacionCreateInput = {
    tipo: string
    mensaje: string
    leido?: boolean
    createdAt?: Date | string
    usuario: UsuarioCreateNestedOneWithoutNotificacionInput
  }

  export type NotificacionUncheckedCreateInput = {
    id?: number
    usuarioId: string
    tipo: string
    mensaje: string
    leido?: boolean
    createdAt?: Date | string
  }

  export type NotificacionUpdateInput = {
    tipo?: StringFieldUpdateOperationsInput | string
    mensaje?: StringFieldUpdateOperationsInput | string
    leido?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: UsuarioUpdateOneRequiredWithoutNotificacionNestedInput
  }

  export type NotificacionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    mensaje?: StringFieldUpdateOperationsInput | string
    leido?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificacionCreateManyInput = {
    id?: number
    usuarioId: string
    tipo: string
    mensaje: string
    leido?: boolean
    createdAt?: Date | string
  }

  export type NotificacionUpdateManyMutationInput = {
    tipo?: StringFieldUpdateOperationsInput | string
    mensaje?: StringFieldUpdateOperationsInput | string
    leido?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificacionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    mensaje?: StringFieldUpdateOperationsInput | string
    leido?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Motivo_rechazoCreateInput = {
    mensaje: string
    inscripcionesTutor?: Inscripcion_tutorCreateNestedManyWithoutMotivoRechazoInput
  }

  export type Motivo_rechazoUncheckedCreateInput = {
    id?: number
    mensaje: string
    inscripcionesTutor?: Inscripcion_tutorUncheckedCreateNestedManyWithoutMotivoRechazoInput
  }

  export type Motivo_rechazoUpdateInput = {
    mensaje?: StringFieldUpdateOperationsInput | string
    inscripcionesTutor?: Inscripcion_tutorUpdateManyWithoutMotivoRechazoNestedInput
  }

  export type Motivo_rechazoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    mensaje?: StringFieldUpdateOperationsInput | string
    inscripcionesTutor?: Inscripcion_tutorUncheckedUpdateManyWithoutMotivoRechazoNestedInput
  }

  export type Motivo_rechazoCreateManyInput = {
    id?: number
    mensaje: string
  }

  export type Motivo_rechazoUpdateManyMutationInput = {
    mensaje?: StringFieldUpdateOperationsInput | string
  }

  export type Motivo_rechazoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    mensaje?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type CompetidorNullableScalarRelationFilter = {
    is?: CompetidorWhereInput | null
    isNot?: CompetidorWhereInput | null
  }

  export type TutorNullableScalarRelationFilter = {
    is?: TutorWhereInput | null
    isNot?: TutorWhereInput | null
  }

  export type RolScalarRelationFilter = {
    is?: RolWhereInput
    isNot?: RolWhereInput
  }

  export type NotificacionListRelationFilter = {
    every?: NotificacionWhereInput
    some?: NotificacionWhereInput
    none?: NotificacionWhereInput
  }

  export type NotificacionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsuarioCountOrderByAggregateInput = {
    id?: SortOrder
    correo_electronico?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    estado?: SortOrder
    password?: SortOrder
    rol_id?: SortOrder
    createdAt?: SortOrder
  }

  export type UsuarioAvgOrderByAggregateInput = {
    rol_id?: SortOrder
  }

  export type UsuarioMaxOrderByAggregateInput = {
    id?: SortOrder
    correo_electronico?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    estado?: SortOrder
    password?: SortOrder
    rol_id?: SortOrder
    createdAt?: SortOrder
  }

  export type UsuarioMinOrderByAggregateInput = {
    id?: SortOrder
    correo_electronico?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    estado?: SortOrder
    password?: SortOrder
    rol_id?: SortOrder
    createdAt?: SortOrder
  }

  export type UsuarioSumOrderByAggregateInput = {
    rol_id?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type Rol_permisoListRelationFilter = {
    every?: Rol_permisoWhereInput
    some?: Rol_permisoWhereInput
    none?: Rol_permisoWhereInput
  }

  export type UsuarioListRelationFilter = {
    every?: UsuarioWhereInput
    some?: UsuarioWhereInput
    none?: UsuarioWhereInput
  }

  export type Rol_permisoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsuarioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RolCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type RolAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RolMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type RolMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type RolSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PermisoCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
  }

  export type PermisoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PermisoMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
  }

  export type PermisoMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
  }

  export type PermisoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PermisoScalarRelationFilter = {
    is?: PermisoWhereInput
    isNot?: PermisoWhereInput
  }

  export type Rol_permisoCountOrderByAggregateInput = {
    id?: SortOrder
    rol_id?: SortOrder
    permiso_id?: SortOrder
  }

  export type Rol_permisoAvgOrderByAggregateInput = {
    id?: SortOrder
    rol_id?: SortOrder
    permiso_id?: SortOrder
  }

  export type Rol_permisoMaxOrderByAggregateInput = {
    id?: SortOrder
    rol_id?: SortOrder
    permiso_id?: SortOrder
  }

  export type Rol_permisoMinOrderByAggregateInput = {
    id?: SortOrder
    rol_id?: SortOrder
    permiso_id?: SortOrder
  }

  export type Rol_permisoSumOrderByAggregateInput = {
    id?: SortOrder
    rol_id?: SortOrder
    permiso_id?: SortOrder
  }

  export type ColegioScalarRelationFilter = {
    is?: ColegioWhereInput
    isNot?: ColegioWhereInput
  }

  export type ProvinciaScalarRelationFilter = {
    is?: ProvinciaWhereInput
    isNot?: ProvinciaWhereInput
  }

  export type UsuarioScalarRelationFilter = {
    is?: UsuarioWhereInput
    isNot?: UsuarioWhereInput
  }

  export type Inscripcion_tutorListRelationFilter = {
    every?: Inscripcion_tutorWhereInput
    some?: Inscripcion_tutorWhereInput
    none?: Inscripcion_tutorWhereInput
  }

  export type InscripcionListRelationFilter = {
    every?: InscripcionWhereInput
    some?: InscripcionWhereInput
    none?: InscripcionWhereInput
  }

  export type Inscripcion_tutorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InscripcionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompetidorCountOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    colegio_id?: SortOrder
    provincia_id?: SortOrder
    carnet_identidad?: SortOrder
    fecha_nacimiento?: SortOrder
  }

  export type CompetidorAvgOrderByAggregateInput = {
    colegio_id?: SortOrder
    provincia_id?: SortOrder
  }

  export type CompetidorMaxOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    colegio_id?: SortOrder
    provincia_id?: SortOrder
    carnet_identidad?: SortOrder
    fecha_nacimiento?: SortOrder
  }

  export type CompetidorMinOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    colegio_id?: SortOrder
    provincia_id?: SortOrder
    carnet_identidad?: SortOrder
    fecha_nacimiento?: SortOrder
  }

  export type CompetidorSumOrderByAggregateInput = {
    colegio_id?: SortOrder
    provincia_id?: SortOrder
  }

  export type AreaScalarRelationFilter = {
    is?: AreaWhereInput
    isNot?: AreaWhereInput
  }

  export type TutorCountOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    carnet_identidad?: SortOrder
    numero_celular?: SortOrder
    area_id?: SortOrder
  }

  export type TutorAvgOrderByAggregateInput = {
    area_id?: SortOrder
  }

  export type TutorMaxOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    carnet_identidad?: SortOrder
    numero_celular?: SortOrder
    area_id?: SortOrder
  }

  export type TutorMinOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    carnet_identidad?: SortOrder
    numero_celular?: SortOrder
    area_id?: SortOrder
  }

  export type TutorSumOrderByAggregateInput = {
    area_id?: SortOrder
  }

  export type ProvinciaListRelationFilter = {
    every?: ProvinciaWhereInput
    some?: ProvinciaWhereInput
    none?: ProvinciaWhereInput
  }

  export type ProvinciaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DepartamentoCountOrderByAggregateInput = {
    id?: SortOrder
    nombre_departamento?: SortOrder
  }

  export type DepartamentoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DepartamentoMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre_departamento?: SortOrder
  }

  export type DepartamentoMinOrderByAggregateInput = {
    id?: SortOrder
    nombre_departamento?: SortOrder
  }

  export type DepartamentoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ColegioListRelationFilter = {
    every?: ColegioWhereInput
    some?: ColegioWhereInput
    none?: ColegioWhereInput
  }

  export type CompetidorListRelationFilter = {
    every?: CompetidorWhereInput
    some?: CompetidorWhereInput
    none?: CompetidorWhereInput
  }

  export type DepartamentoScalarRelationFilter = {
    is?: DepartamentoWhereInput
    isNot?: DepartamentoWhereInput
  }

  export type ColegioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompetidorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProvinciaCountOrderByAggregateInput = {
    id?: SortOrder
    nombre_provincia?: SortOrder
    departamento_id?: SortOrder
  }

  export type ProvinciaAvgOrderByAggregateInput = {
    id?: SortOrder
    departamento_id?: SortOrder
  }

  export type ProvinciaMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre_provincia?: SortOrder
    departamento_id?: SortOrder
  }

  export type ProvinciaMinOrderByAggregateInput = {
    id?: SortOrder
    nombre_provincia?: SortOrder
    departamento_id?: SortOrder
  }

  export type ProvinciaSumOrderByAggregateInput = {
    id?: SortOrder
    departamento_id?: SortOrder
  }

  export type ColegioCountOrderByAggregateInput = {
    id?: SortOrder
    nombre_colegio?: SortOrder
    provincia_id?: SortOrder
  }

  export type ColegioAvgOrderByAggregateInput = {
    id?: SortOrder
    provincia_id?: SortOrder
  }

  export type ColegioMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre_colegio?: SortOrder
    provincia_id?: SortOrder
  }

  export type ColegioMinOrderByAggregateInput = {
    id?: SortOrder
    nombre_colegio?: SortOrder
    provincia_id?: SortOrder
  }

  export type ColegioSumOrderByAggregateInput = {
    id?: SortOrder
    provincia_id?: SortOrder
  }

  export type Area_convocatoriaListRelationFilter = {
    every?: Area_convocatoriaWhereInput
    some?: Area_convocatoriaWhereInput
    none?: Area_convocatoriaWhereInput
  }

  export type Estado_convocatoriaScalarRelationFilter = {
    is?: estado_convocatoriaWhereInput
    isNot?: estado_convocatoriaWhereInput
  }

  export type Area_convocatoriaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConvocatoriaCountOrderByAggregateInput = {
    id?: SortOrder
    nombre_convocatoria?: SortOrder
    id_estado_convocatoria?: SortOrder
    fecha_inicio?: SortOrder
    fecha_fin?: SortOrder
    pago_fin?: SortOrder
    pago_inicio?: SortOrder
    competicion_inicio?: SortOrder
    competicion_fin?: SortOrder
    descripcion_convocatoria?: SortOrder
  }

  export type ConvocatoriaAvgOrderByAggregateInput = {
    id?: SortOrder
    id_estado_convocatoria?: SortOrder
  }

  export type ConvocatoriaMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre_convocatoria?: SortOrder
    id_estado_convocatoria?: SortOrder
    fecha_inicio?: SortOrder
    fecha_fin?: SortOrder
    pago_fin?: SortOrder
    pago_inicio?: SortOrder
    competicion_inicio?: SortOrder
    competicion_fin?: SortOrder
    descripcion_convocatoria?: SortOrder
  }

  export type ConvocatoriaMinOrderByAggregateInput = {
    id?: SortOrder
    nombre_convocatoria?: SortOrder
    id_estado_convocatoria?: SortOrder
    fecha_inicio?: SortOrder
    fecha_fin?: SortOrder
    pago_fin?: SortOrder
    pago_inicio?: SortOrder
    competicion_inicio?: SortOrder
    competicion_fin?: SortOrder
    descripcion_convocatoria?: SortOrder
  }

  export type ConvocatoriaSumOrderByAggregateInput = {
    id?: SortOrder
    id_estado_convocatoria?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type Categoria_areaListRelationFilter = {
    every?: Categoria_areaWhereInput
    some?: Categoria_areaWhereInput
    none?: Categoria_areaWhereInput
  }

  export type TutorListRelationFilter = {
    every?: TutorWhereInput
    some?: TutorWhereInput
    none?: TutorWhereInput
  }

  export type Categoria_areaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TutorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AreaCountOrderByAggregateInput = {
    id?: SortOrder
    nombre_area?: SortOrder
    descripcion_area?: SortOrder
    costo?: SortOrder
  }

  export type AreaAvgOrderByAggregateInput = {
    id?: SortOrder
    costo?: SortOrder
  }

  export type AreaMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre_area?: SortOrder
    descripcion_area?: SortOrder
    costo?: SortOrder
  }

  export type AreaMinOrderByAggregateInput = {
    id?: SortOrder
    nombre_area?: SortOrder
    descripcion_area?: SortOrder
    costo?: SortOrder
  }

  export type AreaSumOrderByAggregateInput = {
    id?: SortOrder
    costo?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type GradoScalarRelationFilter = {
    is?: GradoWhereInput
    isNot?: GradoWhereInput
  }

  export type CategoriaCountOrderByAggregateInput = {
    id?: SortOrder
    nombre_categoria?: SortOrder
    grado_min_id?: SortOrder
    grado_max_id?: SortOrder
    descripcion_cat?: SortOrder
  }

  export type CategoriaAvgOrderByAggregateInput = {
    id?: SortOrder
    grado_min_id?: SortOrder
    grado_max_id?: SortOrder
  }

  export type CategoriaMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre_categoria?: SortOrder
    grado_min_id?: SortOrder
    grado_max_id?: SortOrder
    descripcion_cat?: SortOrder
  }

  export type CategoriaMinOrderByAggregateInput = {
    id?: SortOrder
    nombre_categoria?: SortOrder
    grado_min_id?: SortOrder
    grado_max_id?: SortOrder
    descripcion_cat?: SortOrder
  }

  export type CategoriaSumOrderByAggregateInput = {
    id?: SortOrder
    grado_min_id?: SortOrder
    grado_max_id?: SortOrder
  }

  export type CategoriaListRelationFilter = {
    every?: CategoriaWhereInput
    some?: CategoriaWhereInput
    none?: CategoriaWhereInput
  }

  export type NivelScalarRelationFilter = {
    is?: NivelWhereInput
    isNot?: NivelWhereInput
  }

  export type CategoriaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GradoCountOrderByAggregateInput = {
    id?: SortOrder
    nombre_grado?: SortOrder
    id_nivel?: SortOrder
  }

  export type GradoAvgOrderByAggregateInput = {
    id?: SortOrder
    id_nivel?: SortOrder
  }

  export type GradoMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre_grado?: SortOrder
    id_nivel?: SortOrder
  }

  export type GradoMinOrderByAggregateInput = {
    id?: SortOrder
    nombre_grado?: SortOrder
    id_nivel?: SortOrder
  }

  export type GradoSumOrderByAggregateInput = {
    id?: SortOrder
    id_nivel?: SortOrder
  }

  export type InscripcionScalarRelationFilter = {
    is?: InscripcionWhereInput
    isNot?: InscripcionWhereInput
  }

  export type Metodo_pagoScalarRelationFilter = {
    is?: Metodo_pagoWhereInput
    isNot?: Metodo_pagoWhereInput
  }

  export type PagoCountOrderByAggregateInput = {
    id?: SortOrder
    inscripcion_id?: SortOrder
    monto?: SortOrder
    estado?: SortOrder
    codigo_pago?: SortOrder
    fecha_pago?: SortOrder
    metodo_pago_id?: SortOrder
  }

  export type PagoAvgOrderByAggregateInput = {
    id?: SortOrder
    inscripcion_id?: SortOrder
    monto?: SortOrder
    metodo_pago_id?: SortOrder
  }

  export type PagoMaxOrderByAggregateInput = {
    id?: SortOrder
    inscripcion_id?: SortOrder
    monto?: SortOrder
    estado?: SortOrder
    codigo_pago?: SortOrder
    fecha_pago?: SortOrder
    metodo_pago_id?: SortOrder
  }

  export type PagoMinOrderByAggregateInput = {
    id?: SortOrder
    inscripcion_id?: SortOrder
    monto?: SortOrder
    estado?: SortOrder
    codigo_pago?: SortOrder
    fecha_pago?: SortOrder
    metodo_pago_id?: SortOrder
  }

  export type PagoSumOrderByAggregateInput = {
    id?: SortOrder
    inscripcion_id?: SortOrder
    monto?: SortOrder
    metodo_pago_id?: SortOrder
  }

  export type ConvocatoriaScalarRelationFilter = {
    is?: ConvocatoriaWhereInput
    isNot?: ConvocatoriaWhereInput
  }

  export type Area_convocatoriaCountOrderByAggregateInput = {
    id?: SortOrder
    area_id?: SortOrder
    convocatoria_id?: SortOrder
  }

  export type Area_convocatoriaAvgOrderByAggregateInput = {
    id?: SortOrder
    area_id?: SortOrder
    convocatoria_id?: SortOrder
  }

  export type Area_convocatoriaMaxOrderByAggregateInput = {
    id?: SortOrder
    area_id?: SortOrder
    convocatoria_id?: SortOrder
  }

  export type Area_convocatoriaMinOrderByAggregateInput = {
    id?: SortOrder
    area_id?: SortOrder
    convocatoria_id?: SortOrder
  }

  export type Area_convocatoriaSumOrderByAggregateInput = {
    id?: SortOrder
    area_id?: SortOrder
    convocatoria_id?: SortOrder
  }

  export type CategoriaScalarRelationFilter = {
    is?: CategoriaWhereInput
    isNot?: CategoriaWhereInput
  }

  export type Categoria_areaCountOrderByAggregateInput = {
    id?: SortOrder
    categoria_id?: SortOrder
    area_id?: SortOrder
  }

  export type Categoria_areaAvgOrderByAggregateInput = {
    id?: SortOrder
    categoria_id?: SortOrder
    area_id?: SortOrder
  }

  export type Categoria_areaMaxOrderByAggregateInput = {
    id?: SortOrder
    categoria_id?: SortOrder
    area_id?: SortOrder
  }

  export type Categoria_areaMinOrderByAggregateInput = {
    id?: SortOrder
    categoria_id?: SortOrder
    area_id?: SortOrder
  }

  export type Categoria_areaSumOrderByAggregateInput = {
    id?: SortOrder
    categoria_id?: SortOrder
    area_id?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type TutorScalarRelationFilter = {
    is?: TutorWhereInput
    isNot?: TutorWhereInput
  }

  export type Motivo_rechazoNullableScalarRelationFilter = {
    is?: Motivo_rechazoWhereInput | null
    isNot?: Motivo_rechazoWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type Inscripcion_tutorCountOrderByAggregateInput = {
    id?: SortOrder
    inscripcion_id?: SortOrder
    tutor_id?: SortOrder
    aprobado?: SortOrder
    fecha_aprobacion?: SortOrder
    motivo_rechazo_id?: SortOrder
    descripcion_rechazo?: SortOrder
    competidorId?: SortOrder
  }

  export type Inscripcion_tutorAvgOrderByAggregateInput = {
    id?: SortOrder
    inscripcion_id?: SortOrder
    motivo_rechazo_id?: SortOrder
  }

  export type Inscripcion_tutorMaxOrderByAggregateInput = {
    id?: SortOrder
    inscripcion_id?: SortOrder
    tutor_id?: SortOrder
    aprobado?: SortOrder
    fecha_aprobacion?: SortOrder
    motivo_rechazo_id?: SortOrder
    descripcion_rechazo?: SortOrder
    competidorId?: SortOrder
  }

  export type Inscripcion_tutorMinOrderByAggregateInput = {
    id?: SortOrder
    inscripcion_id?: SortOrder
    tutor_id?: SortOrder
    aprobado?: SortOrder
    fecha_aprobacion?: SortOrder
    motivo_rechazo_id?: SortOrder
    descripcion_rechazo?: SortOrder
    competidorId?: SortOrder
  }

  export type Inscripcion_tutorSumOrderByAggregateInput = {
    id?: SortOrder
    inscripcion_id?: SortOrder
    motivo_rechazo_id?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type PagoListRelationFilter = {
    every?: PagoWhereInput
    some?: PagoWhereInput
    none?: PagoWhereInput
  }

  export type PagoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Metodo_pagoCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type Metodo_pagoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Metodo_pagoMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type Metodo_pagoMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type Metodo_pagoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ConvocatoriaListRelationFilter = {
    every?: ConvocatoriaWhereInput
    some?: ConvocatoriaWhereInput
    none?: ConvocatoriaWhereInput
  }

  export type ConvocatoriaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type estado_convocatoriaCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type estado_convocatoriaAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type estado_convocatoriaMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type estado_convocatoriaMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type estado_convocatoriaSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CompetidorScalarRelationFilter = {
    is?: CompetidorWhereInput
    isNot?: CompetidorWhereInput
  }

  export type InscripcionCountOrderByAggregateInput = {
    id?: SortOrder
    competidor_id?: SortOrder
    area_id?: SortOrder
    convocatoria_id?: SortOrder
    categoria_id?: SortOrder
    fecha_inscripcion?: SortOrder
    estado_inscripcion?: SortOrder
  }

  export type InscripcionAvgOrderByAggregateInput = {
    id?: SortOrder
    area_id?: SortOrder
    convocatoria_id?: SortOrder
    categoria_id?: SortOrder
  }

  export type InscripcionMaxOrderByAggregateInput = {
    id?: SortOrder
    competidor_id?: SortOrder
    area_id?: SortOrder
    convocatoria_id?: SortOrder
    categoria_id?: SortOrder
    fecha_inscripcion?: SortOrder
    estado_inscripcion?: SortOrder
  }

  export type InscripcionMinOrderByAggregateInput = {
    id?: SortOrder
    competidor_id?: SortOrder
    area_id?: SortOrder
    convocatoria_id?: SortOrder
    categoria_id?: SortOrder
    fecha_inscripcion?: SortOrder
    estado_inscripcion?: SortOrder
  }

  export type InscripcionSumOrderByAggregateInput = {
    id?: SortOrder
    area_id?: SortOrder
    convocatoria_id?: SortOrder
    categoria_id?: SortOrder
  }

  export type GradoListRelationFilter = {
    every?: GradoWhereInput
    some?: GradoWhereInput
    none?: GradoWhereInput
  }

  export type GradoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NivelCountOrderByAggregateInput = {
    id?: SortOrder
    nombre_nivel?: SortOrder
  }

  export type NivelAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type NivelMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre_nivel?: SortOrder
  }

  export type NivelMinOrderByAggregateInput = {
    id?: SortOrder
    nombre_nivel?: SortOrder
  }

  export type NivelSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type NotificacionCountOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    tipo?: SortOrder
    mensaje?: SortOrder
    leido?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificacionAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type NotificacionMaxOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    tipo?: SortOrder
    mensaje?: SortOrder
    leido?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificacionMinOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    tipo?: SortOrder
    mensaje?: SortOrder
    leido?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificacionSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Motivo_rechazoCountOrderByAggregateInput = {
    id?: SortOrder
    mensaje?: SortOrder
  }

  export type Motivo_rechazoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Motivo_rechazoMaxOrderByAggregateInput = {
    id?: SortOrder
    mensaje?: SortOrder
  }

  export type Motivo_rechazoMinOrderByAggregateInput = {
    id?: SortOrder
    mensaje?: SortOrder
  }

  export type Motivo_rechazoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CompetidorCreateNestedOneWithoutUsuarioInput = {
    create?: XOR<CompetidorCreateWithoutUsuarioInput, CompetidorUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: CompetidorCreateOrConnectWithoutUsuarioInput
    connect?: CompetidorWhereUniqueInput
  }

  export type TutorCreateNestedOneWithoutUsuarioInput = {
    create?: XOR<TutorCreateWithoutUsuarioInput, TutorUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: TutorCreateOrConnectWithoutUsuarioInput
    connect?: TutorWhereUniqueInput
  }

  export type RolCreateNestedOneWithoutUsuariosInput = {
    create?: XOR<RolCreateWithoutUsuariosInput, RolUncheckedCreateWithoutUsuariosInput>
    connectOrCreate?: RolCreateOrConnectWithoutUsuariosInput
    connect?: RolWhereUniqueInput
  }

  export type NotificacionCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<NotificacionCreateWithoutUsuarioInput, NotificacionUncheckedCreateWithoutUsuarioInput> | NotificacionCreateWithoutUsuarioInput[] | NotificacionUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: NotificacionCreateOrConnectWithoutUsuarioInput | NotificacionCreateOrConnectWithoutUsuarioInput[]
    createMany?: NotificacionCreateManyUsuarioInputEnvelope
    connect?: NotificacionWhereUniqueInput | NotificacionWhereUniqueInput[]
  }

  export type CompetidorUncheckedCreateNestedOneWithoutUsuarioInput = {
    create?: XOR<CompetidorCreateWithoutUsuarioInput, CompetidorUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: CompetidorCreateOrConnectWithoutUsuarioInput
    connect?: CompetidorWhereUniqueInput
  }

  export type TutorUncheckedCreateNestedOneWithoutUsuarioInput = {
    create?: XOR<TutorCreateWithoutUsuarioInput, TutorUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: TutorCreateOrConnectWithoutUsuarioInput
    connect?: TutorWhereUniqueInput
  }

  export type NotificacionUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<NotificacionCreateWithoutUsuarioInput, NotificacionUncheckedCreateWithoutUsuarioInput> | NotificacionCreateWithoutUsuarioInput[] | NotificacionUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: NotificacionCreateOrConnectWithoutUsuarioInput | NotificacionCreateOrConnectWithoutUsuarioInput[]
    createMany?: NotificacionCreateManyUsuarioInputEnvelope
    connect?: NotificacionWhereUniqueInput | NotificacionWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type CompetidorUpdateOneWithoutUsuarioNestedInput = {
    create?: XOR<CompetidorCreateWithoutUsuarioInput, CompetidorUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: CompetidorCreateOrConnectWithoutUsuarioInput
    upsert?: CompetidorUpsertWithoutUsuarioInput
    disconnect?: CompetidorWhereInput | boolean
    delete?: CompetidorWhereInput | boolean
    connect?: CompetidorWhereUniqueInput
    update?: XOR<XOR<CompetidorUpdateToOneWithWhereWithoutUsuarioInput, CompetidorUpdateWithoutUsuarioInput>, CompetidorUncheckedUpdateWithoutUsuarioInput>
  }

  export type TutorUpdateOneWithoutUsuarioNestedInput = {
    create?: XOR<TutorCreateWithoutUsuarioInput, TutorUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: TutorCreateOrConnectWithoutUsuarioInput
    upsert?: TutorUpsertWithoutUsuarioInput
    disconnect?: TutorWhereInput | boolean
    delete?: TutorWhereInput | boolean
    connect?: TutorWhereUniqueInput
    update?: XOR<XOR<TutorUpdateToOneWithWhereWithoutUsuarioInput, TutorUpdateWithoutUsuarioInput>, TutorUncheckedUpdateWithoutUsuarioInput>
  }

  export type RolUpdateOneRequiredWithoutUsuariosNestedInput = {
    create?: XOR<RolCreateWithoutUsuariosInput, RolUncheckedCreateWithoutUsuariosInput>
    connectOrCreate?: RolCreateOrConnectWithoutUsuariosInput
    upsert?: RolUpsertWithoutUsuariosInput
    connect?: RolWhereUniqueInput
    update?: XOR<XOR<RolUpdateToOneWithWhereWithoutUsuariosInput, RolUpdateWithoutUsuariosInput>, RolUncheckedUpdateWithoutUsuariosInput>
  }

  export type NotificacionUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<NotificacionCreateWithoutUsuarioInput, NotificacionUncheckedCreateWithoutUsuarioInput> | NotificacionCreateWithoutUsuarioInput[] | NotificacionUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: NotificacionCreateOrConnectWithoutUsuarioInput | NotificacionCreateOrConnectWithoutUsuarioInput[]
    upsert?: NotificacionUpsertWithWhereUniqueWithoutUsuarioInput | NotificacionUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: NotificacionCreateManyUsuarioInputEnvelope
    set?: NotificacionWhereUniqueInput | NotificacionWhereUniqueInput[]
    disconnect?: NotificacionWhereUniqueInput | NotificacionWhereUniqueInput[]
    delete?: NotificacionWhereUniqueInput | NotificacionWhereUniqueInput[]
    connect?: NotificacionWhereUniqueInput | NotificacionWhereUniqueInput[]
    update?: NotificacionUpdateWithWhereUniqueWithoutUsuarioInput | NotificacionUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: NotificacionUpdateManyWithWhereWithoutUsuarioInput | NotificacionUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: NotificacionScalarWhereInput | NotificacionScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CompetidorUncheckedUpdateOneWithoutUsuarioNestedInput = {
    create?: XOR<CompetidorCreateWithoutUsuarioInput, CompetidorUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: CompetidorCreateOrConnectWithoutUsuarioInput
    upsert?: CompetidorUpsertWithoutUsuarioInput
    disconnect?: CompetidorWhereInput | boolean
    delete?: CompetidorWhereInput | boolean
    connect?: CompetidorWhereUniqueInput
    update?: XOR<XOR<CompetidorUpdateToOneWithWhereWithoutUsuarioInput, CompetidorUpdateWithoutUsuarioInput>, CompetidorUncheckedUpdateWithoutUsuarioInput>
  }

  export type TutorUncheckedUpdateOneWithoutUsuarioNestedInput = {
    create?: XOR<TutorCreateWithoutUsuarioInput, TutorUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: TutorCreateOrConnectWithoutUsuarioInput
    upsert?: TutorUpsertWithoutUsuarioInput
    disconnect?: TutorWhereInput | boolean
    delete?: TutorWhereInput | boolean
    connect?: TutorWhereUniqueInput
    update?: XOR<XOR<TutorUpdateToOneWithWhereWithoutUsuarioInput, TutorUpdateWithoutUsuarioInput>, TutorUncheckedUpdateWithoutUsuarioInput>
  }

  export type NotificacionUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<NotificacionCreateWithoutUsuarioInput, NotificacionUncheckedCreateWithoutUsuarioInput> | NotificacionCreateWithoutUsuarioInput[] | NotificacionUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: NotificacionCreateOrConnectWithoutUsuarioInput | NotificacionCreateOrConnectWithoutUsuarioInput[]
    upsert?: NotificacionUpsertWithWhereUniqueWithoutUsuarioInput | NotificacionUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: NotificacionCreateManyUsuarioInputEnvelope
    set?: NotificacionWhereUniqueInput | NotificacionWhereUniqueInput[]
    disconnect?: NotificacionWhereUniqueInput | NotificacionWhereUniqueInput[]
    delete?: NotificacionWhereUniqueInput | NotificacionWhereUniqueInput[]
    connect?: NotificacionWhereUniqueInput | NotificacionWhereUniqueInput[]
    update?: NotificacionUpdateWithWhereUniqueWithoutUsuarioInput | NotificacionUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: NotificacionUpdateManyWithWhereWithoutUsuarioInput | NotificacionUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: NotificacionScalarWhereInput | NotificacionScalarWhereInput[]
  }

  export type Rol_permisoCreateNestedManyWithoutRolInput = {
    create?: XOR<Rol_permisoCreateWithoutRolInput, Rol_permisoUncheckedCreateWithoutRolInput> | Rol_permisoCreateWithoutRolInput[] | Rol_permisoUncheckedCreateWithoutRolInput[]
    connectOrCreate?: Rol_permisoCreateOrConnectWithoutRolInput | Rol_permisoCreateOrConnectWithoutRolInput[]
    createMany?: Rol_permisoCreateManyRolInputEnvelope
    connect?: Rol_permisoWhereUniqueInput | Rol_permisoWhereUniqueInput[]
  }

  export type UsuarioCreateNestedManyWithoutRoleInput = {
    create?: XOR<UsuarioCreateWithoutRoleInput, UsuarioUncheckedCreateWithoutRoleInput> | UsuarioCreateWithoutRoleInput[] | UsuarioUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutRoleInput | UsuarioCreateOrConnectWithoutRoleInput[]
    createMany?: UsuarioCreateManyRoleInputEnvelope
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
  }

  export type Rol_permisoUncheckedCreateNestedManyWithoutRolInput = {
    create?: XOR<Rol_permisoCreateWithoutRolInput, Rol_permisoUncheckedCreateWithoutRolInput> | Rol_permisoCreateWithoutRolInput[] | Rol_permisoUncheckedCreateWithoutRolInput[]
    connectOrCreate?: Rol_permisoCreateOrConnectWithoutRolInput | Rol_permisoCreateOrConnectWithoutRolInput[]
    createMany?: Rol_permisoCreateManyRolInputEnvelope
    connect?: Rol_permisoWhereUniqueInput | Rol_permisoWhereUniqueInput[]
  }

  export type UsuarioUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<UsuarioCreateWithoutRoleInput, UsuarioUncheckedCreateWithoutRoleInput> | UsuarioCreateWithoutRoleInput[] | UsuarioUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutRoleInput | UsuarioCreateOrConnectWithoutRoleInput[]
    createMany?: UsuarioCreateManyRoleInputEnvelope
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
  }

  export type Rol_permisoUpdateManyWithoutRolNestedInput = {
    create?: XOR<Rol_permisoCreateWithoutRolInput, Rol_permisoUncheckedCreateWithoutRolInput> | Rol_permisoCreateWithoutRolInput[] | Rol_permisoUncheckedCreateWithoutRolInput[]
    connectOrCreate?: Rol_permisoCreateOrConnectWithoutRolInput | Rol_permisoCreateOrConnectWithoutRolInput[]
    upsert?: Rol_permisoUpsertWithWhereUniqueWithoutRolInput | Rol_permisoUpsertWithWhereUniqueWithoutRolInput[]
    createMany?: Rol_permisoCreateManyRolInputEnvelope
    set?: Rol_permisoWhereUniqueInput | Rol_permisoWhereUniqueInput[]
    disconnect?: Rol_permisoWhereUniqueInput | Rol_permisoWhereUniqueInput[]
    delete?: Rol_permisoWhereUniqueInput | Rol_permisoWhereUniqueInput[]
    connect?: Rol_permisoWhereUniqueInput | Rol_permisoWhereUniqueInput[]
    update?: Rol_permisoUpdateWithWhereUniqueWithoutRolInput | Rol_permisoUpdateWithWhereUniqueWithoutRolInput[]
    updateMany?: Rol_permisoUpdateManyWithWhereWithoutRolInput | Rol_permisoUpdateManyWithWhereWithoutRolInput[]
    deleteMany?: Rol_permisoScalarWhereInput | Rol_permisoScalarWhereInput[]
  }

  export type UsuarioUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UsuarioCreateWithoutRoleInput, UsuarioUncheckedCreateWithoutRoleInput> | UsuarioCreateWithoutRoleInput[] | UsuarioUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutRoleInput | UsuarioCreateOrConnectWithoutRoleInput[]
    upsert?: UsuarioUpsertWithWhereUniqueWithoutRoleInput | UsuarioUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UsuarioCreateManyRoleInputEnvelope
    set?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    disconnect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    delete?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    update?: UsuarioUpdateWithWhereUniqueWithoutRoleInput | UsuarioUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UsuarioUpdateManyWithWhereWithoutRoleInput | UsuarioUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UsuarioScalarWhereInput | UsuarioScalarWhereInput[]
  }

  export type Rol_permisoUncheckedUpdateManyWithoutRolNestedInput = {
    create?: XOR<Rol_permisoCreateWithoutRolInput, Rol_permisoUncheckedCreateWithoutRolInput> | Rol_permisoCreateWithoutRolInput[] | Rol_permisoUncheckedCreateWithoutRolInput[]
    connectOrCreate?: Rol_permisoCreateOrConnectWithoutRolInput | Rol_permisoCreateOrConnectWithoutRolInput[]
    upsert?: Rol_permisoUpsertWithWhereUniqueWithoutRolInput | Rol_permisoUpsertWithWhereUniqueWithoutRolInput[]
    createMany?: Rol_permisoCreateManyRolInputEnvelope
    set?: Rol_permisoWhereUniqueInput | Rol_permisoWhereUniqueInput[]
    disconnect?: Rol_permisoWhereUniqueInput | Rol_permisoWhereUniqueInput[]
    delete?: Rol_permisoWhereUniqueInput | Rol_permisoWhereUniqueInput[]
    connect?: Rol_permisoWhereUniqueInput | Rol_permisoWhereUniqueInput[]
    update?: Rol_permisoUpdateWithWhereUniqueWithoutRolInput | Rol_permisoUpdateWithWhereUniqueWithoutRolInput[]
    updateMany?: Rol_permisoUpdateManyWithWhereWithoutRolInput | Rol_permisoUpdateManyWithWhereWithoutRolInput[]
    deleteMany?: Rol_permisoScalarWhereInput | Rol_permisoScalarWhereInput[]
  }

  export type UsuarioUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UsuarioCreateWithoutRoleInput, UsuarioUncheckedCreateWithoutRoleInput> | UsuarioCreateWithoutRoleInput[] | UsuarioUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutRoleInput | UsuarioCreateOrConnectWithoutRoleInput[]
    upsert?: UsuarioUpsertWithWhereUniqueWithoutRoleInput | UsuarioUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UsuarioCreateManyRoleInputEnvelope
    set?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    disconnect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    delete?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    update?: UsuarioUpdateWithWhereUniqueWithoutRoleInput | UsuarioUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UsuarioUpdateManyWithWhereWithoutRoleInput | UsuarioUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UsuarioScalarWhereInput | UsuarioScalarWhereInput[]
  }

  export type Rol_permisoCreateNestedManyWithoutPermisoInput = {
    create?: XOR<Rol_permisoCreateWithoutPermisoInput, Rol_permisoUncheckedCreateWithoutPermisoInput> | Rol_permisoCreateWithoutPermisoInput[] | Rol_permisoUncheckedCreateWithoutPermisoInput[]
    connectOrCreate?: Rol_permisoCreateOrConnectWithoutPermisoInput | Rol_permisoCreateOrConnectWithoutPermisoInput[]
    createMany?: Rol_permisoCreateManyPermisoInputEnvelope
    connect?: Rol_permisoWhereUniqueInput | Rol_permisoWhereUniqueInput[]
  }

  export type Rol_permisoUncheckedCreateNestedManyWithoutPermisoInput = {
    create?: XOR<Rol_permisoCreateWithoutPermisoInput, Rol_permisoUncheckedCreateWithoutPermisoInput> | Rol_permisoCreateWithoutPermisoInput[] | Rol_permisoUncheckedCreateWithoutPermisoInput[]
    connectOrCreate?: Rol_permisoCreateOrConnectWithoutPermisoInput | Rol_permisoCreateOrConnectWithoutPermisoInput[]
    createMany?: Rol_permisoCreateManyPermisoInputEnvelope
    connect?: Rol_permisoWhereUniqueInput | Rol_permisoWhereUniqueInput[]
  }

  export type Rol_permisoUpdateManyWithoutPermisoNestedInput = {
    create?: XOR<Rol_permisoCreateWithoutPermisoInput, Rol_permisoUncheckedCreateWithoutPermisoInput> | Rol_permisoCreateWithoutPermisoInput[] | Rol_permisoUncheckedCreateWithoutPermisoInput[]
    connectOrCreate?: Rol_permisoCreateOrConnectWithoutPermisoInput | Rol_permisoCreateOrConnectWithoutPermisoInput[]
    upsert?: Rol_permisoUpsertWithWhereUniqueWithoutPermisoInput | Rol_permisoUpsertWithWhereUniqueWithoutPermisoInput[]
    createMany?: Rol_permisoCreateManyPermisoInputEnvelope
    set?: Rol_permisoWhereUniqueInput | Rol_permisoWhereUniqueInput[]
    disconnect?: Rol_permisoWhereUniqueInput | Rol_permisoWhereUniqueInput[]
    delete?: Rol_permisoWhereUniqueInput | Rol_permisoWhereUniqueInput[]
    connect?: Rol_permisoWhereUniqueInput | Rol_permisoWhereUniqueInput[]
    update?: Rol_permisoUpdateWithWhereUniqueWithoutPermisoInput | Rol_permisoUpdateWithWhereUniqueWithoutPermisoInput[]
    updateMany?: Rol_permisoUpdateManyWithWhereWithoutPermisoInput | Rol_permisoUpdateManyWithWhereWithoutPermisoInput[]
    deleteMany?: Rol_permisoScalarWhereInput | Rol_permisoScalarWhereInput[]
  }

  export type Rol_permisoUncheckedUpdateManyWithoutPermisoNestedInput = {
    create?: XOR<Rol_permisoCreateWithoutPermisoInput, Rol_permisoUncheckedCreateWithoutPermisoInput> | Rol_permisoCreateWithoutPermisoInput[] | Rol_permisoUncheckedCreateWithoutPermisoInput[]
    connectOrCreate?: Rol_permisoCreateOrConnectWithoutPermisoInput | Rol_permisoCreateOrConnectWithoutPermisoInput[]
    upsert?: Rol_permisoUpsertWithWhereUniqueWithoutPermisoInput | Rol_permisoUpsertWithWhereUniqueWithoutPermisoInput[]
    createMany?: Rol_permisoCreateManyPermisoInputEnvelope
    set?: Rol_permisoWhereUniqueInput | Rol_permisoWhereUniqueInput[]
    disconnect?: Rol_permisoWhereUniqueInput | Rol_permisoWhereUniqueInput[]
    delete?: Rol_permisoWhereUniqueInput | Rol_permisoWhereUniqueInput[]
    connect?: Rol_permisoWhereUniqueInput | Rol_permisoWhereUniqueInput[]
    update?: Rol_permisoUpdateWithWhereUniqueWithoutPermisoInput | Rol_permisoUpdateWithWhereUniqueWithoutPermisoInput[]
    updateMany?: Rol_permisoUpdateManyWithWhereWithoutPermisoInput | Rol_permisoUpdateManyWithWhereWithoutPermisoInput[]
    deleteMany?: Rol_permisoScalarWhereInput | Rol_permisoScalarWhereInput[]
  }

  export type PermisoCreateNestedOneWithoutRolesInput = {
    create?: XOR<PermisoCreateWithoutRolesInput, PermisoUncheckedCreateWithoutRolesInput>
    connectOrCreate?: PermisoCreateOrConnectWithoutRolesInput
    connect?: PermisoWhereUniqueInput
  }

  export type RolCreateNestedOneWithoutRolesInput = {
    create?: XOR<RolCreateWithoutRolesInput, RolUncheckedCreateWithoutRolesInput>
    connectOrCreate?: RolCreateOrConnectWithoutRolesInput
    connect?: RolWhereUniqueInput
  }

  export type PermisoUpdateOneRequiredWithoutRolesNestedInput = {
    create?: XOR<PermisoCreateWithoutRolesInput, PermisoUncheckedCreateWithoutRolesInput>
    connectOrCreate?: PermisoCreateOrConnectWithoutRolesInput
    upsert?: PermisoUpsertWithoutRolesInput
    connect?: PermisoWhereUniqueInput
    update?: XOR<XOR<PermisoUpdateToOneWithWhereWithoutRolesInput, PermisoUpdateWithoutRolesInput>, PermisoUncheckedUpdateWithoutRolesInput>
  }

  export type RolUpdateOneRequiredWithoutRolesNestedInput = {
    create?: XOR<RolCreateWithoutRolesInput, RolUncheckedCreateWithoutRolesInput>
    connectOrCreate?: RolCreateOrConnectWithoutRolesInput
    upsert?: RolUpsertWithoutRolesInput
    connect?: RolWhereUniqueInput
    update?: XOR<XOR<RolUpdateToOneWithWhereWithoutRolesInput, RolUpdateWithoutRolesInput>, RolUncheckedUpdateWithoutRolesInput>
  }

  export type ColegioCreateNestedOneWithoutCompetidoresInput = {
    create?: XOR<ColegioCreateWithoutCompetidoresInput, ColegioUncheckedCreateWithoutCompetidoresInput>
    connectOrCreate?: ColegioCreateOrConnectWithoutCompetidoresInput
    connect?: ColegioWhereUniqueInput
  }

  export type ProvinciaCreateNestedOneWithoutCompetidorInput = {
    create?: XOR<ProvinciaCreateWithoutCompetidorInput, ProvinciaUncheckedCreateWithoutCompetidorInput>
    connectOrCreate?: ProvinciaCreateOrConnectWithoutCompetidorInput
    connect?: ProvinciaWhereUniqueInput
  }

  export type UsuarioCreateNestedOneWithoutCompetidorInput = {
    create?: XOR<UsuarioCreateWithoutCompetidorInput, UsuarioUncheckedCreateWithoutCompetidorInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutCompetidorInput
    connect?: UsuarioWhereUniqueInput
  }

  export type Inscripcion_tutorCreateNestedManyWithoutCompetidorInput = {
    create?: XOR<Inscripcion_tutorCreateWithoutCompetidorInput, Inscripcion_tutorUncheckedCreateWithoutCompetidorInput> | Inscripcion_tutorCreateWithoutCompetidorInput[] | Inscripcion_tutorUncheckedCreateWithoutCompetidorInput[]
    connectOrCreate?: Inscripcion_tutorCreateOrConnectWithoutCompetidorInput | Inscripcion_tutorCreateOrConnectWithoutCompetidorInput[]
    createMany?: Inscripcion_tutorCreateManyCompetidorInputEnvelope
    connect?: Inscripcion_tutorWhereUniqueInput | Inscripcion_tutorWhereUniqueInput[]
  }

  export type InscripcionCreateNestedManyWithoutCompetidorInput = {
    create?: XOR<InscripcionCreateWithoutCompetidorInput, InscripcionUncheckedCreateWithoutCompetidorInput> | InscripcionCreateWithoutCompetidorInput[] | InscripcionUncheckedCreateWithoutCompetidorInput[]
    connectOrCreate?: InscripcionCreateOrConnectWithoutCompetidorInput | InscripcionCreateOrConnectWithoutCompetidorInput[]
    createMany?: InscripcionCreateManyCompetidorInputEnvelope
    connect?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[]
  }

  export type Inscripcion_tutorUncheckedCreateNestedManyWithoutCompetidorInput = {
    create?: XOR<Inscripcion_tutorCreateWithoutCompetidorInput, Inscripcion_tutorUncheckedCreateWithoutCompetidorInput> | Inscripcion_tutorCreateWithoutCompetidorInput[] | Inscripcion_tutorUncheckedCreateWithoutCompetidorInput[]
    connectOrCreate?: Inscripcion_tutorCreateOrConnectWithoutCompetidorInput | Inscripcion_tutorCreateOrConnectWithoutCompetidorInput[]
    createMany?: Inscripcion_tutorCreateManyCompetidorInputEnvelope
    connect?: Inscripcion_tutorWhereUniqueInput | Inscripcion_tutorWhereUniqueInput[]
  }

  export type InscripcionUncheckedCreateNestedManyWithoutCompetidorInput = {
    create?: XOR<InscripcionCreateWithoutCompetidorInput, InscripcionUncheckedCreateWithoutCompetidorInput> | InscripcionCreateWithoutCompetidorInput[] | InscripcionUncheckedCreateWithoutCompetidorInput[]
    connectOrCreate?: InscripcionCreateOrConnectWithoutCompetidorInput | InscripcionCreateOrConnectWithoutCompetidorInput[]
    createMany?: InscripcionCreateManyCompetidorInputEnvelope
    connect?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[]
  }

  export type ColegioUpdateOneRequiredWithoutCompetidoresNestedInput = {
    create?: XOR<ColegioCreateWithoutCompetidoresInput, ColegioUncheckedCreateWithoutCompetidoresInput>
    connectOrCreate?: ColegioCreateOrConnectWithoutCompetidoresInput
    upsert?: ColegioUpsertWithoutCompetidoresInput
    connect?: ColegioWhereUniqueInput
    update?: XOR<XOR<ColegioUpdateToOneWithWhereWithoutCompetidoresInput, ColegioUpdateWithoutCompetidoresInput>, ColegioUncheckedUpdateWithoutCompetidoresInput>
  }

  export type ProvinciaUpdateOneRequiredWithoutCompetidorNestedInput = {
    create?: XOR<ProvinciaCreateWithoutCompetidorInput, ProvinciaUncheckedCreateWithoutCompetidorInput>
    connectOrCreate?: ProvinciaCreateOrConnectWithoutCompetidorInput
    upsert?: ProvinciaUpsertWithoutCompetidorInput
    connect?: ProvinciaWhereUniqueInput
    update?: XOR<XOR<ProvinciaUpdateToOneWithWhereWithoutCompetidorInput, ProvinciaUpdateWithoutCompetidorInput>, ProvinciaUncheckedUpdateWithoutCompetidorInput>
  }

  export type UsuarioUpdateOneRequiredWithoutCompetidorNestedInput = {
    create?: XOR<UsuarioCreateWithoutCompetidorInput, UsuarioUncheckedCreateWithoutCompetidorInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutCompetidorInput
    upsert?: UsuarioUpsertWithoutCompetidorInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutCompetidorInput, UsuarioUpdateWithoutCompetidorInput>, UsuarioUncheckedUpdateWithoutCompetidorInput>
  }

  export type Inscripcion_tutorUpdateManyWithoutCompetidorNestedInput = {
    create?: XOR<Inscripcion_tutorCreateWithoutCompetidorInput, Inscripcion_tutorUncheckedCreateWithoutCompetidorInput> | Inscripcion_tutorCreateWithoutCompetidorInput[] | Inscripcion_tutorUncheckedCreateWithoutCompetidorInput[]
    connectOrCreate?: Inscripcion_tutorCreateOrConnectWithoutCompetidorInput | Inscripcion_tutorCreateOrConnectWithoutCompetidorInput[]
    upsert?: Inscripcion_tutorUpsertWithWhereUniqueWithoutCompetidorInput | Inscripcion_tutorUpsertWithWhereUniqueWithoutCompetidorInput[]
    createMany?: Inscripcion_tutorCreateManyCompetidorInputEnvelope
    set?: Inscripcion_tutorWhereUniqueInput | Inscripcion_tutorWhereUniqueInput[]
    disconnect?: Inscripcion_tutorWhereUniqueInput | Inscripcion_tutorWhereUniqueInput[]
    delete?: Inscripcion_tutorWhereUniqueInput | Inscripcion_tutorWhereUniqueInput[]
    connect?: Inscripcion_tutorWhereUniqueInput | Inscripcion_tutorWhereUniqueInput[]
    update?: Inscripcion_tutorUpdateWithWhereUniqueWithoutCompetidorInput | Inscripcion_tutorUpdateWithWhereUniqueWithoutCompetidorInput[]
    updateMany?: Inscripcion_tutorUpdateManyWithWhereWithoutCompetidorInput | Inscripcion_tutorUpdateManyWithWhereWithoutCompetidorInput[]
    deleteMany?: Inscripcion_tutorScalarWhereInput | Inscripcion_tutorScalarWhereInput[]
  }

  export type InscripcionUpdateManyWithoutCompetidorNestedInput = {
    create?: XOR<InscripcionCreateWithoutCompetidorInput, InscripcionUncheckedCreateWithoutCompetidorInput> | InscripcionCreateWithoutCompetidorInput[] | InscripcionUncheckedCreateWithoutCompetidorInput[]
    connectOrCreate?: InscripcionCreateOrConnectWithoutCompetidorInput | InscripcionCreateOrConnectWithoutCompetidorInput[]
    upsert?: InscripcionUpsertWithWhereUniqueWithoutCompetidorInput | InscripcionUpsertWithWhereUniqueWithoutCompetidorInput[]
    createMany?: InscripcionCreateManyCompetidorInputEnvelope
    set?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[]
    disconnect?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[]
    delete?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[]
    connect?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[]
    update?: InscripcionUpdateWithWhereUniqueWithoutCompetidorInput | InscripcionUpdateWithWhereUniqueWithoutCompetidorInput[]
    updateMany?: InscripcionUpdateManyWithWhereWithoutCompetidorInput | InscripcionUpdateManyWithWhereWithoutCompetidorInput[]
    deleteMany?: InscripcionScalarWhereInput | InscripcionScalarWhereInput[]
  }

  export type Inscripcion_tutorUncheckedUpdateManyWithoutCompetidorNestedInput = {
    create?: XOR<Inscripcion_tutorCreateWithoutCompetidorInput, Inscripcion_tutorUncheckedCreateWithoutCompetidorInput> | Inscripcion_tutorCreateWithoutCompetidorInput[] | Inscripcion_tutorUncheckedCreateWithoutCompetidorInput[]
    connectOrCreate?: Inscripcion_tutorCreateOrConnectWithoutCompetidorInput | Inscripcion_tutorCreateOrConnectWithoutCompetidorInput[]
    upsert?: Inscripcion_tutorUpsertWithWhereUniqueWithoutCompetidorInput | Inscripcion_tutorUpsertWithWhereUniqueWithoutCompetidorInput[]
    createMany?: Inscripcion_tutorCreateManyCompetidorInputEnvelope
    set?: Inscripcion_tutorWhereUniqueInput | Inscripcion_tutorWhereUniqueInput[]
    disconnect?: Inscripcion_tutorWhereUniqueInput | Inscripcion_tutorWhereUniqueInput[]
    delete?: Inscripcion_tutorWhereUniqueInput | Inscripcion_tutorWhereUniqueInput[]
    connect?: Inscripcion_tutorWhereUniqueInput | Inscripcion_tutorWhereUniqueInput[]
    update?: Inscripcion_tutorUpdateWithWhereUniqueWithoutCompetidorInput | Inscripcion_tutorUpdateWithWhereUniqueWithoutCompetidorInput[]
    updateMany?: Inscripcion_tutorUpdateManyWithWhereWithoutCompetidorInput | Inscripcion_tutorUpdateManyWithWhereWithoutCompetidorInput[]
    deleteMany?: Inscripcion_tutorScalarWhereInput | Inscripcion_tutorScalarWhereInput[]
  }

  export type InscripcionUncheckedUpdateManyWithoutCompetidorNestedInput = {
    create?: XOR<InscripcionCreateWithoutCompetidorInput, InscripcionUncheckedCreateWithoutCompetidorInput> | InscripcionCreateWithoutCompetidorInput[] | InscripcionUncheckedCreateWithoutCompetidorInput[]
    connectOrCreate?: InscripcionCreateOrConnectWithoutCompetidorInput | InscripcionCreateOrConnectWithoutCompetidorInput[]
    upsert?: InscripcionUpsertWithWhereUniqueWithoutCompetidorInput | InscripcionUpsertWithWhereUniqueWithoutCompetidorInput[]
    createMany?: InscripcionCreateManyCompetidorInputEnvelope
    set?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[]
    disconnect?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[]
    delete?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[]
    connect?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[]
    update?: InscripcionUpdateWithWhereUniqueWithoutCompetidorInput | InscripcionUpdateWithWhereUniqueWithoutCompetidorInput[]
    updateMany?: InscripcionUpdateManyWithWhereWithoutCompetidorInput | InscripcionUpdateManyWithWhereWithoutCompetidorInput[]
    deleteMany?: InscripcionScalarWhereInput | InscripcionScalarWhereInput[]
  }

  export type Inscripcion_tutorCreateNestedManyWithoutTutorInput = {
    create?: XOR<Inscripcion_tutorCreateWithoutTutorInput, Inscripcion_tutorUncheckedCreateWithoutTutorInput> | Inscripcion_tutorCreateWithoutTutorInput[] | Inscripcion_tutorUncheckedCreateWithoutTutorInput[]
    connectOrCreate?: Inscripcion_tutorCreateOrConnectWithoutTutorInput | Inscripcion_tutorCreateOrConnectWithoutTutorInput[]
    createMany?: Inscripcion_tutorCreateManyTutorInputEnvelope
    connect?: Inscripcion_tutorWhereUniqueInput | Inscripcion_tutorWhereUniqueInput[]
  }

  export type AreaCreateNestedOneWithoutTutorInput = {
    create?: XOR<AreaCreateWithoutTutorInput, AreaUncheckedCreateWithoutTutorInput>
    connectOrCreate?: AreaCreateOrConnectWithoutTutorInput
    connect?: AreaWhereUniqueInput
  }

  export type UsuarioCreateNestedOneWithoutTutorInput = {
    create?: XOR<UsuarioCreateWithoutTutorInput, UsuarioUncheckedCreateWithoutTutorInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutTutorInput
    connect?: UsuarioWhereUniqueInput
  }

  export type Inscripcion_tutorUncheckedCreateNestedManyWithoutTutorInput = {
    create?: XOR<Inscripcion_tutorCreateWithoutTutorInput, Inscripcion_tutorUncheckedCreateWithoutTutorInput> | Inscripcion_tutorCreateWithoutTutorInput[] | Inscripcion_tutorUncheckedCreateWithoutTutorInput[]
    connectOrCreate?: Inscripcion_tutorCreateOrConnectWithoutTutorInput | Inscripcion_tutorCreateOrConnectWithoutTutorInput[]
    createMany?: Inscripcion_tutorCreateManyTutorInputEnvelope
    connect?: Inscripcion_tutorWhereUniqueInput | Inscripcion_tutorWhereUniqueInput[]
  }

  export type Inscripcion_tutorUpdateManyWithoutTutorNestedInput = {
    create?: XOR<Inscripcion_tutorCreateWithoutTutorInput, Inscripcion_tutorUncheckedCreateWithoutTutorInput> | Inscripcion_tutorCreateWithoutTutorInput[] | Inscripcion_tutorUncheckedCreateWithoutTutorInput[]
    connectOrCreate?: Inscripcion_tutorCreateOrConnectWithoutTutorInput | Inscripcion_tutorCreateOrConnectWithoutTutorInput[]
    upsert?: Inscripcion_tutorUpsertWithWhereUniqueWithoutTutorInput | Inscripcion_tutorUpsertWithWhereUniqueWithoutTutorInput[]
    createMany?: Inscripcion_tutorCreateManyTutorInputEnvelope
    set?: Inscripcion_tutorWhereUniqueInput | Inscripcion_tutorWhereUniqueInput[]
    disconnect?: Inscripcion_tutorWhereUniqueInput | Inscripcion_tutorWhereUniqueInput[]
    delete?: Inscripcion_tutorWhereUniqueInput | Inscripcion_tutorWhereUniqueInput[]
    connect?: Inscripcion_tutorWhereUniqueInput | Inscripcion_tutorWhereUniqueInput[]
    update?: Inscripcion_tutorUpdateWithWhereUniqueWithoutTutorInput | Inscripcion_tutorUpdateWithWhereUniqueWithoutTutorInput[]
    updateMany?: Inscripcion_tutorUpdateManyWithWhereWithoutTutorInput | Inscripcion_tutorUpdateManyWithWhereWithoutTutorInput[]
    deleteMany?: Inscripcion_tutorScalarWhereInput | Inscripcion_tutorScalarWhereInput[]
  }

  export type AreaUpdateOneRequiredWithoutTutorNestedInput = {
    create?: XOR<AreaCreateWithoutTutorInput, AreaUncheckedCreateWithoutTutorInput>
    connectOrCreate?: AreaCreateOrConnectWithoutTutorInput
    upsert?: AreaUpsertWithoutTutorInput
    connect?: AreaWhereUniqueInput
    update?: XOR<XOR<AreaUpdateToOneWithWhereWithoutTutorInput, AreaUpdateWithoutTutorInput>, AreaUncheckedUpdateWithoutTutorInput>
  }

  export type UsuarioUpdateOneRequiredWithoutTutorNestedInput = {
    create?: XOR<UsuarioCreateWithoutTutorInput, UsuarioUncheckedCreateWithoutTutorInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutTutorInput
    upsert?: UsuarioUpsertWithoutTutorInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutTutorInput, UsuarioUpdateWithoutTutorInput>, UsuarioUncheckedUpdateWithoutTutorInput>
  }

  export type Inscripcion_tutorUncheckedUpdateManyWithoutTutorNestedInput = {
    create?: XOR<Inscripcion_tutorCreateWithoutTutorInput, Inscripcion_tutorUncheckedCreateWithoutTutorInput> | Inscripcion_tutorCreateWithoutTutorInput[] | Inscripcion_tutorUncheckedCreateWithoutTutorInput[]
    connectOrCreate?: Inscripcion_tutorCreateOrConnectWithoutTutorInput | Inscripcion_tutorCreateOrConnectWithoutTutorInput[]
    upsert?: Inscripcion_tutorUpsertWithWhereUniqueWithoutTutorInput | Inscripcion_tutorUpsertWithWhereUniqueWithoutTutorInput[]
    createMany?: Inscripcion_tutorCreateManyTutorInputEnvelope
    set?: Inscripcion_tutorWhereUniqueInput | Inscripcion_tutorWhereUniqueInput[]
    disconnect?: Inscripcion_tutorWhereUniqueInput | Inscripcion_tutorWhereUniqueInput[]
    delete?: Inscripcion_tutorWhereUniqueInput | Inscripcion_tutorWhereUniqueInput[]
    connect?: Inscripcion_tutorWhereUniqueInput | Inscripcion_tutorWhereUniqueInput[]
    update?: Inscripcion_tutorUpdateWithWhereUniqueWithoutTutorInput | Inscripcion_tutorUpdateWithWhereUniqueWithoutTutorInput[]
    updateMany?: Inscripcion_tutorUpdateManyWithWhereWithoutTutorInput | Inscripcion_tutorUpdateManyWithWhereWithoutTutorInput[]
    deleteMany?: Inscripcion_tutorScalarWhereInput | Inscripcion_tutorScalarWhereInput[]
  }

  export type ProvinciaCreateNestedManyWithoutDepartamentoInput = {
    create?: XOR<ProvinciaCreateWithoutDepartamentoInput, ProvinciaUncheckedCreateWithoutDepartamentoInput> | ProvinciaCreateWithoutDepartamentoInput[] | ProvinciaUncheckedCreateWithoutDepartamentoInput[]
    connectOrCreate?: ProvinciaCreateOrConnectWithoutDepartamentoInput | ProvinciaCreateOrConnectWithoutDepartamentoInput[]
    createMany?: ProvinciaCreateManyDepartamentoInputEnvelope
    connect?: ProvinciaWhereUniqueInput | ProvinciaWhereUniqueInput[]
  }

  export type ProvinciaUncheckedCreateNestedManyWithoutDepartamentoInput = {
    create?: XOR<ProvinciaCreateWithoutDepartamentoInput, ProvinciaUncheckedCreateWithoutDepartamentoInput> | ProvinciaCreateWithoutDepartamentoInput[] | ProvinciaUncheckedCreateWithoutDepartamentoInput[]
    connectOrCreate?: ProvinciaCreateOrConnectWithoutDepartamentoInput | ProvinciaCreateOrConnectWithoutDepartamentoInput[]
    createMany?: ProvinciaCreateManyDepartamentoInputEnvelope
    connect?: ProvinciaWhereUniqueInput | ProvinciaWhereUniqueInput[]
  }

  export type ProvinciaUpdateManyWithoutDepartamentoNestedInput = {
    create?: XOR<ProvinciaCreateWithoutDepartamentoInput, ProvinciaUncheckedCreateWithoutDepartamentoInput> | ProvinciaCreateWithoutDepartamentoInput[] | ProvinciaUncheckedCreateWithoutDepartamentoInput[]
    connectOrCreate?: ProvinciaCreateOrConnectWithoutDepartamentoInput | ProvinciaCreateOrConnectWithoutDepartamentoInput[]
    upsert?: ProvinciaUpsertWithWhereUniqueWithoutDepartamentoInput | ProvinciaUpsertWithWhereUniqueWithoutDepartamentoInput[]
    createMany?: ProvinciaCreateManyDepartamentoInputEnvelope
    set?: ProvinciaWhereUniqueInput | ProvinciaWhereUniqueInput[]
    disconnect?: ProvinciaWhereUniqueInput | ProvinciaWhereUniqueInput[]
    delete?: ProvinciaWhereUniqueInput | ProvinciaWhereUniqueInput[]
    connect?: ProvinciaWhereUniqueInput | ProvinciaWhereUniqueInput[]
    update?: ProvinciaUpdateWithWhereUniqueWithoutDepartamentoInput | ProvinciaUpdateWithWhereUniqueWithoutDepartamentoInput[]
    updateMany?: ProvinciaUpdateManyWithWhereWithoutDepartamentoInput | ProvinciaUpdateManyWithWhereWithoutDepartamentoInput[]
    deleteMany?: ProvinciaScalarWhereInput | ProvinciaScalarWhereInput[]
  }

  export type ProvinciaUncheckedUpdateManyWithoutDepartamentoNestedInput = {
    create?: XOR<ProvinciaCreateWithoutDepartamentoInput, ProvinciaUncheckedCreateWithoutDepartamentoInput> | ProvinciaCreateWithoutDepartamentoInput[] | ProvinciaUncheckedCreateWithoutDepartamentoInput[]
    connectOrCreate?: ProvinciaCreateOrConnectWithoutDepartamentoInput | ProvinciaCreateOrConnectWithoutDepartamentoInput[]
    upsert?: ProvinciaUpsertWithWhereUniqueWithoutDepartamentoInput | ProvinciaUpsertWithWhereUniqueWithoutDepartamentoInput[]
    createMany?: ProvinciaCreateManyDepartamentoInputEnvelope
    set?: ProvinciaWhereUniqueInput | ProvinciaWhereUniqueInput[]
    disconnect?: ProvinciaWhereUniqueInput | ProvinciaWhereUniqueInput[]
    delete?: ProvinciaWhereUniqueInput | ProvinciaWhereUniqueInput[]
    connect?: ProvinciaWhereUniqueInput | ProvinciaWhereUniqueInput[]
    update?: ProvinciaUpdateWithWhereUniqueWithoutDepartamentoInput | ProvinciaUpdateWithWhereUniqueWithoutDepartamentoInput[]
    updateMany?: ProvinciaUpdateManyWithWhereWithoutDepartamentoInput | ProvinciaUpdateManyWithWhereWithoutDepartamentoInput[]
    deleteMany?: ProvinciaScalarWhereInput | ProvinciaScalarWhereInput[]
  }

  export type ColegioCreateNestedManyWithoutProvinciaInput = {
    create?: XOR<ColegioCreateWithoutProvinciaInput, ColegioUncheckedCreateWithoutProvinciaInput> | ColegioCreateWithoutProvinciaInput[] | ColegioUncheckedCreateWithoutProvinciaInput[]
    connectOrCreate?: ColegioCreateOrConnectWithoutProvinciaInput | ColegioCreateOrConnectWithoutProvinciaInput[]
    createMany?: ColegioCreateManyProvinciaInputEnvelope
    connect?: ColegioWhereUniqueInput | ColegioWhereUniqueInput[]
  }

  export type CompetidorCreateNestedManyWithoutProvinciaInput = {
    create?: XOR<CompetidorCreateWithoutProvinciaInput, CompetidorUncheckedCreateWithoutProvinciaInput> | CompetidorCreateWithoutProvinciaInput[] | CompetidorUncheckedCreateWithoutProvinciaInput[]
    connectOrCreate?: CompetidorCreateOrConnectWithoutProvinciaInput | CompetidorCreateOrConnectWithoutProvinciaInput[]
    createMany?: CompetidorCreateManyProvinciaInputEnvelope
    connect?: CompetidorWhereUniqueInput | CompetidorWhereUniqueInput[]
  }

  export type DepartamentoCreateNestedOneWithoutProvinciaInput = {
    create?: XOR<DepartamentoCreateWithoutProvinciaInput, DepartamentoUncheckedCreateWithoutProvinciaInput>
    connectOrCreate?: DepartamentoCreateOrConnectWithoutProvinciaInput
    connect?: DepartamentoWhereUniqueInput
  }

  export type ColegioUncheckedCreateNestedManyWithoutProvinciaInput = {
    create?: XOR<ColegioCreateWithoutProvinciaInput, ColegioUncheckedCreateWithoutProvinciaInput> | ColegioCreateWithoutProvinciaInput[] | ColegioUncheckedCreateWithoutProvinciaInput[]
    connectOrCreate?: ColegioCreateOrConnectWithoutProvinciaInput | ColegioCreateOrConnectWithoutProvinciaInput[]
    createMany?: ColegioCreateManyProvinciaInputEnvelope
    connect?: ColegioWhereUniqueInput | ColegioWhereUniqueInput[]
  }

  export type CompetidorUncheckedCreateNestedManyWithoutProvinciaInput = {
    create?: XOR<CompetidorCreateWithoutProvinciaInput, CompetidorUncheckedCreateWithoutProvinciaInput> | CompetidorCreateWithoutProvinciaInput[] | CompetidorUncheckedCreateWithoutProvinciaInput[]
    connectOrCreate?: CompetidorCreateOrConnectWithoutProvinciaInput | CompetidorCreateOrConnectWithoutProvinciaInput[]
    createMany?: CompetidorCreateManyProvinciaInputEnvelope
    connect?: CompetidorWhereUniqueInput | CompetidorWhereUniqueInput[]
  }

  export type ColegioUpdateManyWithoutProvinciaNestedInput = {
    create?: XOR<ColegioCreateWithoutProvinciaInput, ColegioUncheckedCreateWithoutProvinciaInput> | ColegioCreateWithoutProvinciaInput[] | ColegioUncheckedCreateWithoutProvinciaInput[]
    connectOrCreate?: ColegioCreateOrConnectWithoutProvinciaInput | ColegioCreateOrConnectWithoutProvinciaInput[]
    upsert?: ColegioUpsertWithWhereUniqueWithoutProvinciaInput | ColegioUpsertWithWhereUniqueWithoutProvinciaInput[]
    createMany?: ColegioCreateManyProvinciaInputEnvelope
    set?: ColegioWhereUniqueInput | ColegioWhereUniqueInput[]
    disconnect?: ColegioWhereUniqueInput | ColegioWhereUniqueInput[]
    delete?: ColegioWhereUniqueInput | ColegioWhereUniqueInput[]
    connect?: ColegioWhereUniqueInput | ColegioWhereUniqueInput[]
    update?: ColegioUpdateWithWhereUniqueWithoutProvinciaInput | ColegioUpdateWithWhereUniqueWithoutProvinciaInput[]
    updateMany?: ColegioUpdateManyWithWhereWithoutProvinciaInput | ColegioUpdateManyWithWhereWithoutProvinciaInput[]
    deleteMany?: ColegioScalarWhereInput | ColegioScalarWhereInput[]
  }

  export type CompetidorUpdateManyWithoutProvinciaNestedInput = {
    create?: XOR<CompetidorCreateWithoutProvinciaInput, CompetidorUncheckedCreateWithoutProvinciaInput> | CompetidorCreateWithoutProvinciaInput[] | CompetidorUncheckedCreateWithoutProvinciaInput[]
    connectOrCreate?: CompetidorCreateOrConnectWithoutProvinciaInput | CompetidorCreateOrConnectWithoutProvinciaInput[]
    upsert?: CompetidorUpsertWithWhereUniqueWithoutProvinciaInput | CompetidorUpsertWithWhereUniqueWithoutProvinciaInput[]
    createMany?: CompetidorCreateManyProvinciaInputEnvelope
    set?: CompetidorWhereUniqueInput | CompetidorWhereUniqueInput[]
    disconnect?: CompetidorWhereUniqueInput | CompetidorWhereUniqueInput[]
    delete?: CompetidorWhereUniqueInput | CompetidorWhereUniqueInput[]
    connect?: CompetidorWhereUniqueInput | CompetidorWhereUniqueInput[]
    update?: CompetidorUpdateWithWhereUniqueWithoutProvinciaInput | CompetidorUpdateWithWhereUniqueWithoutProvinciaInput[]
    updateMany?: CompetidorUpdateManyWithWhereWithoutProvinciaInput | CompetidorUpdateManyWithWhereWithoutProvinciaInput[]
    deleteMany?: CompetidorScalarWhereInput | CompetidorScalarWhereInput[]
  }

  export type DepartamentoUpdateOneRequiredWithoutProvinciaNestedInput = {
    create?: XOR<DepartamentoCreateWithoutProvinciaInput, DepartamentoUncheckedCreateWithoutProvinciaInput>
    connectOrCreate?: DepartamentoCreateOrConnectWithoutProvinciaInput
    upsert?: DepartamentoUpsertWithoutProvinciaInput
    connect?: DepartamentoWhereUniqueInput
    update?: XOR<XOR<DepartamentoUpdateToOneWithWhereWithoutProvinciaInput, DepartamentoUpdateWithoutProvinciaInput>, DepartamentoUncheckedUpdateWithoutProvinciaInput>
  }

  export type ColegioUncheckedUpdateManyWithoutProvinciaNestedInput = {
    create?: XOR<ColegioCreateWithoutProvinciaInput, ColegioUncheckedCreateWithoutProvinciaInput> | ColegioCreateWithoutProvinciaInput[] | ColegioUncheckedCreateWithoutProvinciaInput[]
    connectOrCreate?: ColegioCreateOrConnectWithoutProvinciaInput | ColegioCreateOrConnectWithoutProvinciaInput[]
    upsert?: ColegioUpsertWithWhereUniqueWithoutProvinciaInput | ColegioUpsertWithWhereUniqueWithoutProvinciaInput[]
    createMany?: ColegioCreateManyProvinciaInputEnvelope
    set?: ColegioWhereUniqueInput | ColegioWhereUniqueInput[]
    disconnect?: ColegioWhereUniqueInput | ColegioWhereUniqueInput[]
    delete?: ColegioWhereUniqueInput | ColegioWhereUniqueInput[]
    connect?: ColegioWhereUniqueInput | ColegioWhereUniqueInput[]
    update?: ColegioUpdateWithWhereUniqueWithoutProvinciaInput | ColegioUpdateWithWhereUniqueWithoutProvinciaInput[]
    updateMany?: ColegioUpdateManyWithWhereWithoutProvinciaInput | ColegioUpdateManyWithWhereWithoutProvinciaInput[]
    deleteMany?: ColegioScalarWhereInput | ColegioScalarWhereInput[]
  }

  export type CompetidorUncheckedUpdateManyWithoutProvinciaNestedInput = {
    create?: XOR<CompetidorCreateWithoutProvinciaInput, CompetidorUncheckedCreateWithoutProvinciaInput> | CompetidorCreateWithoutProvinciaInput[] | CompetidorUncheckedCreateWithoutProvinciaInput[]
    connectOrCreate?: CompetidorCreateOrConnectWithoutProvinciaInput | CompetidorCreateOrConnectWithoutProvinciaInput[]
    upsert?: CompetidorUpsertWithWhereUniqueWithoutProvinciaInput | CompetidorUpsertWithWhereUniqueWithoutProvinciaInput[]
    createMany?: CompetidorCreateManyProvinciaInputEnvelope
    set?: CompetidorWhereUniqueInput | CompetidorWhereUniqueInput[]
    disconnect?: CompetidorWhereUniqueInput | CompetidorWhereUniqueInput[]
    delete?: CompetidorWhereUniqueInput | CompetidorWhereUniqueInput[]
    connect?: CompetidorWhereUniqueInput | CompetidorWhereUniqueInput[]
    update?: CompetidorUpdateWithWhereUniqueWithoutProvinciaInput | CompetidorUpdateWithWhereUniqueWithoutProvinciaInput[]
    updateMany?: CompetidorUpdateManyWithWhereWithoutProvinciaInput | CompetidorUpdateManyWithWhereWithoutProvinciaInput[]
    deleteMany?: CompetidorScalarWhereInput | CompetidorScalarWhereInput[]
  }

  export type ProvinciaCreateNestedOneWithoutColegioInput = {
    create?: XOR<ProvinciaCreateWithoutColegioInput, ProvinciaUncheckedCreateWithoutColegioInput>
    connectOrCreate?: ProvinciaCreateOrConnectWithoutColegioInput
    connect?: ProvinciaWhereUniqueInput
  }

  export type CompetidorCreateNestedManyWithoutColegioInput = {
    create?: XOR<CompetidorCreateWithoutColegioInput, CompetidorUncheckedCreateWithoutColegioInput> | CompetidorCreateWithoutColegioInput[] | CompetidorUncheckedCreateWithoutColegioInput[]
    connectOrCreate?: CompetidorCreateOrConnectWithoutColegioInput | CompetidorCreateOrConnectWithoutColegioInput[]
    createMany?: CompetidorCreateManyColegioInputEnvelope
    connect?: CompetidorWhereUniqueInput | CompetidorWhereUniqueInput[]
  }

  export type CompetidorUncheckedCreateNestedManyWithoutColegioInput = {
    create?: XOR<CompetidorCreateWithoutColegioInput, CompetidorUncheckedCreateWithoutColegioInput> | CompetidorCreateWithoutColegioInput[] | CompetidorUncheckedCreateWithoutColegioInput[]
    connectOrCreate?: CompetidorCreateOrConnectWithoutColegioInput | CompetidorCreateOrConnectWithoutColegioInput[]
    createMany?: CompetidorCreateManyColegioInputEnvelope
    connect?: CompetidorWhereUniqueInput | CompetidorWhereUniqueInput[]
  }

  export type ProvinciaUpdateOneRequiredWithoutColegioNestedInput = {
    create?: XOR<ProvinciaCreateWithoutColegioInput, ProvinciaUncheckedCreateWithoutColegioInput>
    connectOrCreate?: ProvinciaCreateOrConnectWithoutColegioInput
    upsert?: ProvinciaUpsertWithoutColegioInput
    connect?: ProvinciaWhereUniqueInput
    update?: XOR<XOR<ProvinciaUpdateToOneWithWhereWithoutColegioInput, ProvinciaUpdateWithoutColegioInput>, ProvinciaUncheckedUpdateWithoutColegioInput>
  }

  export type CompetidorUpdateManyWithoutColegioNestedInput = {
    create?: XOR<CompetidorCreateWithoutColegioInput, CompetidorUncheckedCreateWithoutColegioInput> | CompetidorCreateWithoutColegioInput[] | CompetidorUncheckedCreateWithoutColegioInput[]
    connectOrCreate?: CompetidorCreateOrConnectWithoutColegioInput | CompetidorCreateOrConnectWithoutColegioInput[]
    upsert?: CompetidorUpsertWithWhereUniqueWithoutColegioInput | CompetidorUpsertWithWhereUniqueWithoutColegioInput[]
    createMany?: CompetidorCreateManyColegioInputEnvelope
    set?: CompetidorWhereUniqueInput | CompetidorWhereUniqueInput[]
    disconnect?: CompetidorWhereUniqueInput | CompetidorWhereUniqueInput[]
    delete?: CompetidorWhereUniqueInput | CompetidorWhereUniqueInput[]
    connect?: CompetidorWhereUniqueInput | CompetidorWhereUniqueInput[]
    update?: CompetidorUpdateWithWhereUniqueWithoutColegioInput | CompetidorUpdateWithWhereUniqueWithoutColegioInput[]
    updateMany?: CompetidorUpdateManyWithWhereWithoutColegioInput | CompetidorUpdateManyWithWhereWithoutColegioInput[]
    deleteMany?: CompetidorScalarWhereInput | CompetidorScalarWhereInput[]
  }

  export type CompetidorUncheckedUpdateManyWithoutColegioNestedInput = {
    create?: XOR<CompetidorCreateWithoutColegioInput, CompetidorUncheckedCreateWithoutColegioInput> | CompetidorCreateWithoutColegioInput[] | CompetidorUncheckedCreateWithoutColegioInput[]
    connectOrCreate?: CompetidorCreateOrConnectWithoutColegioInput | CompetidorCreateOrConnectWithoutColegioInput[]
    upsert?: CompetidorUpsertWithWhereUniqueWithoutColegioInput | CompetidorUpsertWithWhereUniqueWithoutColegioInput[]
    createMany?: CompetidorCreateManyColegioInputEnvelope
    set?: CompetidorWhereUniqueInput | CompetidorWhereUniqueInput[]
    disconnect?: CompetidorWhereUniqueInput | CompetidorWhereUniqueInput[]
    delete?: CompetidorWhereUniqueInput | CompetidorWhereUniqueInput[]
    connect?: CompetidorWhereUniqueInput | CompetidorWhereUniqueInput[]
    update?: CompetidorUpdateWithWhereUniqueWithoutColegioInput | CompetidorUpdateWithWhereUniqueWithoutColegioInput[]
    updateMany?: CompetidorUpdateManyWithWhereWithoutColegioInput | CompetidorUpdateManyWithWhereWithoutColegioInput[]
    deleteMany?: CompetidorScalarWhereInput | CompetidorScalarWhereInput[]
  }

  export type Area_convocatoriaCreateNestedManyWithoutConvocatoriaInput = {
    create?: XOR<Area_convocatoriaCreateWithoutConvocatoriaInput, Area_convocatoriaUncheckedCreateWithoutConvocatoriaInput> | Area_convocatoriaCreateWithoutConvocatoriaInput[] | Area_convocatoriaUncheckedCreateWithoutConvocatoriaInput[]
    connectOrCreate?: Area_convocatoriaCreateOrConnectWithoutConvocatoriaInput | Area_convocatoriaCreateOrConnectWithoutConvocatoriaInput[]
    createMany?: Area_convocatoriaCreateManyConvocatoriaInputEnvelope
    connect?: Area_convocatoriaWhereUniqueInput | Area_convocatoriaWhereUniqueInput[]
  }

  export type estado_convocatoriaCreateNestedOneWithoutConvocatoriaInput = {
    create?: XOR<estado_convocatoriaCreateWithoutConvocatoriaInput, estado_convocatoriaUncheckedCreateWithoutConvocatoriaInput>
    connectOrCreate?: estado_convocatoriaCreateOrConnectWithoutConvocatoriaInput
    connect?: estado_convocatoriaWhereUniqueInput
  }

  export type InscripcionCreateNestedManyWithoutConvocatoriaInput = {
    create?: XOR<InscripcionCreateWithoutConvocatoriaInput, InscripcionUncheckedCreateWithoutConvocatoriaInput> | InscripcionCreateWithoutConvocatoriaInput[] | InscripcionUncheckedCreateWithoutConvocatoriaInput[]
    connectOrCreate?: InscripcionCreateOrConnectWithoutConvocatoriaInput | InscripcionCreateOrConnectWithoutConvocatoriaInput[]
    createMany?: InscripcionCreateManyConvocatoriaInputEnvelope
    connect?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[]
  }

  export type Area_convocatoriaUncheckedCreateNestedManyWithoutConvocatoriaInput = {
    create?: XOR<Area_convocatoriaCreateWithoutConvocatoriaInput, Area_convocatoriaUncheckedCreateWithoutConvocatoriaInput> | Area_convocatoriaCreateWithoutConvocatoriaInput[] | Area_convocatoriaUncheckedCreateWithoutConvocatoriaInput[]
    connectOrCreate?: Area_convocatoriaCreateOrConnectWithoutConvocatoriaInput | Area_convocatoriaCreateOrConnectWithoutConvocatoriaInput[]
    createMany?: Area_convocatoriaCreateManyConvocatoriaInputEnvelope
    connect?: Area_convocatoriaWhereUniqueInput | Area_convocatoriaWhereUniqueInput[]
  }

  export type InscripcionUncheckedCreateNestedManyWithoutConvocatoriaInput = {
    create?: XOR<InscripcionCreateWithoutConvocatoriaInput, InscripcionUncheckedCreateWithoutConvocatoriaInput> | InscripcionCreateWithoutConvocatoriaInput[] | InscripcionUncheckedCreateWithoutConvocatoriaInput[]
    connectOrCreate?: InscripcionCreateOrConnectWithoutConvocatoriaInput | InscripcionCreateOrConnectWithoutConvocatoriaInput[]
    createMany?: InscripcionCreateManyConvocatoriaInputEnvelope
    connect?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[]
  }

  export type Area_convocatoriaUpdateManyWithoutConvocatoriaNestedInput = {
    create?: XOR<Area_convocatoriaCreateWithoutConvocatoriaInput, Area_convocatoriaUncheckedCreateWithoutConvocatoriaInput> | Area_convocatoriaCreateWithoutConvocatoriaInput[] | Area_convocatoriaUncheckedCreateWithoutConvocatoriaInput[]
    connectOrCreate?: Area_convocatoriaCreateOrConnectWithoutConvocatoriaInput | Area_convocatoriaCreateOrConnectWithoutConvocatoriaInput[]
    upsert?: Area_convocatoriaUpsertWithWhereUniqueWithoutConvocatoriaInput | Area_convocatoriaUpsertWithWhereUniqueWithoutConvocatoriaInput[]
    createMany?: Area_convocatoriaCreateManyConvocatoriaInputEnvelope
    set?: Area_convocatoriaWhereUniqueInput | Area_convocatoriaWhereUniqueInput[]
    disconnect?: Area_convocatoriaWhereUniqueInput | Area_convocatoriaWhereUniqueInput[]
    delete?: Area_convocatoriaWhereUniqueInput | Area_convocatoriaWhereUniqueInput[]
    connect?: Area_convocatoriaWhereUniqueInput | Area_convocatoriaWhereUniqueInput[]
    update?: Area_convocatoriaUpdateWithWhereUniqueWithoutConvocatoriaInput | Area_convocatoriaUpdateWithWhereUniqueWithoutConvocatoriaInput[]
    updateMany?: Area_convocatoriaUpdateManyWithWhereWithoutConvocatoriaInput | Area_convocatoriaUpdateManyWithWhereWithoutConvocatoriaInput[]
    deleteMany?: Area_convocatoriaScalarWhereInput | Area_convocatoriaScalarWhereInput[]
  }

  export type estado_convocatoriaUpdateOneRequiredWithoutConvocatoriaNestedInput = {
    create?: XOR<estado_convocatoriaCreateWithoutConvocatoriaInput, estado_convocatoriaUncheckedCreateWithoutConvocatoriaInput>
    connectOrCreate?: estado_convocatoriaCreateOrConnectWithoutConvocatoriaInput
    upsert?: estado_convocatoriaUpsertWithoutConvocatoriaInput
    connect?: estado_convocatoriaWhereUniqueInput
    update?: XOR<XOR<estado_convocatoriaUpdateToOneWithWhereWithoutConvocatoriaInput, estado_convocatoriaUpdateWithoutConvocatoriaInput>, estado_convocatoriaUncheckedUpdateWithoutConvocatoriaInput>
  }

  export type InscripcionUpdateManyWithoutConvocatoriaNestedInput = {
    create?: XOR<InscripcionCreateWithoutConvocatoriaInput, InscripcionUncheckedCreateWithoutConvocatoriaInput> | InscripcionCreateWithoutConvocatoriaInput[] | InscripcionUncheckedCreateWithoutConvocatoriaInput[]
    connectOrCreate?: InscripcionCreateOrConnectWithoutConvocatoriaInput | InscripcionCreateOrConnectWithoutConvocatoriaInput[]
    upsert?: InscripcionUpsertWithWhereUniqueWithoutConvocatoriaInput | InscripcionUpsertWithWhereUniqueWithoutConvocatoriaInput[]
    createMany?: InscripcionCreateManyConvocatoriaInputEnvelope
    set?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[]
    disconnect?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[]
    delete?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[]
    connect?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[]
    update?: InscripcionUpdateWithWhereUniqueWithoutConvocatoriaInput | InscripcionUpdateWithWhereUniqueWithoutConvocatoriaInput[]
    updateMany?: InscripcionUpdateManyWithWhereWithoutConvocatoriaInput | InscripcionUpdateManyWithWhereWithoutConvocatoriaInput[]
    deleteMany?: InscripcionScalarWhereInput | InscripcionScalarWhereInput[]
  }

  export type Area_convocatoriaUncheckedUpdateManyWithoutConvocatoriaNestedInput = {
    create?: XOR<Area_convocatoriaCreateWithoutConvocatoriaInput, Area_convocatoriaUncheckedCreateWithoutConvocatoriaInput> | Area_convocatoriaCreateWithoutConvocatoriaInput[] | Area_convocatoriaUncheckedCreateWithoutConvocatoriaInput[]
    connectOrCreate?: Area_convocatoriaCreateOrConnectWithoutConvocatoriaInput | Area_convocatoriaCreateOrConnectWithoutConvocatoriaInput[]
    upsert?: Area_convocatoriaUpsertWithWhereUniqueWithoutConvocatoriaInput | Area_convocatoriaUpsertWithWhereUniqueWithoutConvocatoriaInput[]
    createMany?: Area_convocatoriaCreateManyConvocatoriaInputEnvelope
    set?: Area_convocatoriaWhereUniqueInput | Area_convocatoriaWhereUniqueInput[]
    disconnect?: Area_convocatoriaWhereUniqueInput | Area_convocatoriaWhereUniqueInput[]
    delete?: Area_convocatoriaWhereUniqueInput | Area_convocatoriaWhereUniqueInput[]
    connect?: Area_convocatoriaWhereUniqueInput | Area_convocatoriaWhereUniqueInput[]
    update?: Area_convocatoriaUpdateWithWhereUniqueWithoutConvocatoriaInput | Area_convocatoriaUpdateWithWhereUniqueWithoutConvocatoriaInput[]
    updateMany?: Area_convocatoriaUpdateManyWithWhereWithoutConvocatoriaInput | Area_convocatoriaUpdateManyWithWhereWithoutConvocatoriaInput[]
    deleteMany?: Area_convocatoriaScalarWhereInput | Area_convocatoriaScalarWhereInput[]
  }

  export type InscripcionUncheckedUpdateManyWithoutConvocatoriaNestedInput = {
    create?: XOR<InscripcionCreateWithoutConvocatoriaInput, InscripcionUncheckedCreateWithoutConvocatoriaInput> | InscripcionCreateWithoutConvocatoriaInput[] | InscripcionUncheckedCreateWithoutConvocatoriaInput[]
    connectOrCreate?: InscripcionCreateOrConnectWithoutConvocatoriaInput | InscripcionCreateOrConnectWithoutConvocatoriaInput[]
    upsert?: InscripcionUpsertWithWhereUniqueWithoutConvocatoriaInput | InscripcionUpsertWithWhereUniqueWithoutConvocatoriaInput[]
    createMany?: InscripcionCreateManyConvocatoriaInputEnvelope
    set?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[]
    disconnect?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[]
    delete?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[]
    connect?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[]
    update?: InscripcionUpdateWithWhereUniqueWithoutConvocatoriaInput | InscripcionUpdateWithWhereUniqueWithoutConvocatoriaInput[]
    updateMany?: InscripcionUpdateManyWithWhereWithoutConvocatoriaInput | InscripcionUpdateManyWithWhereWithoutConvocatoriaInput[]
    deleteMany?: InscripcionScalarWhereInput | InscripcionScalarWhereInput[]
  }

  export type Area_convocatoriaCreateNestedManyWithoutAreaInput = {
    create?: XOR<Area_convocatoriaCreateWithoutAreaInput, Area_convocatoriaUncheckedCreateWithoutAreaInput> | Area_convocatoriaCreateWithoutAreaInput[] | Area_convocatoriaUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: Area_convocatoriaCreateOrConnectWithoutAreaInput | Area_convocatoriaCreateOrConnectWithoutAreaInput[]
    createMany?: Area_convocatoriaCreateManyAreaInputEnvelope
    connect?: Area_convocatoriaWhereUniqueInput | Area_convocatoriaWhereUniqueInput[]
  }

  export type Categoria_areaCreateNestedManyWithoutAreaInput = {
    create?: XOR<Categoria_areaCreateWithoutAreaInput, Categoria_areaUncheckedCreateWithoutAreaInput> | Categoria_areaCreateWithoutAreaInput[] | Categoria_areaUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: Categoria_areaCreateOrConnectWithoutAreaInput | Categoria_areaCreateOrConnectWithoutAreaInput[]
    createMany?: Categoria_areaCreateManyAreaInputEnvelope
    connect?: Categoria_areaWhereUniqueInput | Categoria_areaWhereUniqueInput[]
  }

  export type TutorCreateNestedManyWithoutAreaInput = {
    create?: XOR<TutorCreateWithoutAreaInput, TutorUncheckedCreateWithoutAreaInput> | TutorCreateWithoutAreaInput[] | TutorUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: TutorCreateOrConnectWithoutAreaInput | TutorCreateOrConnectWithoutAreaInput[]
    createMany?: TutorCreateManyAreaInputEnvelope
    connect?: TutorWhereUniqueInput | TutorWhereUniqueInput[]
  }

  export type InscripcionCreateNestedManyWithoutAreaInput = {
    create?: XOR<InscripcionCreateWithoutAreaInput, InscripcionUncheckedCreateWithoutAreaInput> | InscripcionCreateWithoutAreaInput[] | InscripcionUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: InscripcionCreateOrConnectWithoutAreaInput | InscripcionCreateOrConnectWithoutAreaInput[]
    createMany?: InscripcionCreateManyAreaInputEnvelope
    connect?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[]
  }

  export type Area_convocatoriaUncheckedCreateNestedManyWithoutAreaInput = {
    create?: XOR<Area_convocatoriaCreateWithoutAreaInput, Area_convocatoriaUncheckedCreateWithoutAreaInput> | Area_convocatoriaCreateWithoutAreaInput[] | Area_convocatoriaUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: Area_convocatoriaCreateOrConnectWithoutAreaInput | Area_convocatoriaCreateOrConnectWithoutAreaInput[]
    createMany?: Area_convocatoriaCreateManyAreaInputEnvelope
    connect?: Area_convocatoriaWhereUniqueInput | Area_convocatoriaWhereUniqueInput[]
  }

  export type Categoria_areaUncheckedCreateNestedManyWithoutAreaInput = {
    create?: XOR<Categoria_areaCreateWithoutAreaInput, Categoria_areaUncheckedCreateWithoutAreaInput> | Categoria_areaCreateWithoutAreaInput[] | Categoria_areaUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: Categoria_areaCreateOrConnectWithoutAreaInput | Categoria_areaCreateOrConnectWithoutAreaInput[]
    createMany?: Categoria_areaCreateManyAreaInputEnvelope
    connect?: Categoria_areaWhereUniqueInput | Categoria_areaWhereUniqueInput[]
  }

  export type TutorUncheckedCreateNestedManyWithoutAreaInput = {
    create?: XOR<TutorCreateWithoutAreaInput, TutorUncheckedCreateWithoutAreaInput> | TutorCreateWithoutAreaInput[] | TutorUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: TutorCreateOrConnectWithoutAreaInput | TutorCreateOrConnectWithoutAreaInput[]
    createMany?: TutorCreateManyAreaInputEnvelope
    connect?: TutorWhereUniqueInput | TutorWhereUniqueInput[]
  }

  export type InscripcionUncheckedCreateNestedManyWithoutAreaInput = {
    create?: XOR<InscripcionCreateWithoutAreaInput, InscripcionUncheckedCreateWithoutAreaInput> | InscripcionCreateWithoutAreaInput[] | InscripcionUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: InscripcionCreateOrConnectWithoutAreaInput | InscripcionCreateOrConnectWithoutAreaInput[]
    createMany?: InscripcionCreateManyAreaInputEnvelope
    connect?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type Area_convocatoriaUpdateManyWithoutAreaNestedInput = {
    create?: XOR<Area_convocatoriaCreateWithoutAreaInput, Area_convocatoriaUncheckedCreateWithoutAreaInput> | Area_convocatoriaCreateWithoutAreaInput[] | Area_convocatoriaUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: Area_convocatoriaCreateOrConnectWithoutAreaInput | Area_convocatoriaCreateOrConnectWithoutAreaInput[]
    upsert?: Area_convocatoriaUpsertWithWhereUniqueWithoutAreaInput | Area_convocatoriaUpsertWithWhereUniqueWithoutAreaInput[]
    createMany?: Area_convocatoriaCreateManyAreaInputEnvelope
    set?: Area_convocatoriaWhereUniqueInput | Area_convocatoriaWhereUniqueInput[]
    disconnect?: Area_convocatoriaWhereUniqueInput | Area_convocatoriaWhereUniqueInput[]
    delete?: Area_convocatoriaWhereUniqueInput | Area_convocatoriaWhereUniqueInput[]
    connect?: Area_convocatoriaWhereUniqueInput | Area_convocatoriaWhereUniqueInput[]
    update?: Area_convocatoriaUpdateWithWhereUniqueWithoutAreaInput | Area_convocatoriaUpdateWithWhereUniqueWithoutAreaInput[]
    updateMany?: Area_convocatoriaUpdateManyWithWhereWithoutAreaInput | Area_convocatoriaUpdateManyWithWhereWithoutAreaInput[]
    deleteMany?: Area_convocatoriaScalarWhereInput | Area_convocatoriaScalarWhereInput[]
  }

  export type Categoria_areaUpdateManyWithoutAreaNestedInput = {
    create?: XOR<Categoria_areaCreateWithoutAreaInput, Categoria_areaUncheckedCreateWithoutAreaInput> | Categoria_areaCreateWithoutAreaInput[] | Categoria_areaUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: Categoria_areaCreateOrConnectWithoutAreaInput | Categoria_areaCreateOrConnectWithoutAreaInput[]
    upsert?: Categoria_areaUpsertWithWhereUniqueWithoutAreaInput | Categoria_areaUpsertWithWhereUniqueWithoutAreaInput[]
    createMany?: Categoria_areaCreateManyAreaInputEnvelope
    set?: Categoria_areaWhereUniqueInput | Categoria_areaWhereUniqueInput[]
    disconnect?: Categoria_areaWhereUniqueInput | Categoria_areaWhereUniqueInput[]
    delete?: Categoria_areaWhereUniqueInput | Categoria_areaWhereUniqueInput[]
    connect?: Categoria_areaWhereUniqueInput | Categoria_areaWhereUniqueInput[]
    update?: Categoria_areaUpdateWithWhereUniqueWithoutAreaInput | Categoria_areaUpdateWithWhereUniqueWithoutAreaInput[]
    updateMany?: Categoria_areaUpdateManyWithWhereWithoutAreaInput | Categoria_areaUpdateManyWithWhereWithoutAreaInput[]
    deleteMany?: Categoria_areaScalarWhereInput | Categoria_areaScalarWhereInput[]
  }

  export type TutorUpdateManyWithoutAreaNestedInput = {
    create?: XOR<TutorCreateWithoutAreaInput, TutorUncheckedCreateWithoutAreaInput> | TutorCreateWithoutAreaInput[] | TutorUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: TutorCreateOrConnectWithoutAreaInput | TutorCreateOrConnectWithoutAreaInput[]
    upsert?: TutorUpsertWithWhereUniqueWithoutAreaInput | TutorUpsertWithWhereUniqueWithoutAreaInput[]
    createMany?: TutorCreateManyAreaInputEnvelope
    set?: TutorWhereUniqueInput | TutorWhereUniqueInput[]
    disconnect?: TutorWhereUniqueInput | TutorWhereUniqueInput[]
    delete?: TutorWhereUniqueInput | TutorWhereUniqueInput[]
    connect?: TutorWhereUniqueInput | TutorWhereUniqueInput[]
    update?: TutorUpdateWithWhereUniqueWithoutAreaInput | TutorUpdateWithWhereUniqueWithoutAreaInput[]
    updateMany?: TutorUpdateManyWithWhereWithoutAreaInput | TutorUpdateManyWithWhereWithoutAreaInput[]
    deleteMany?: TutorScalarWhereInput | TutorScalarWhereInput[]
  }

  export type InscripcionUpdateManyWithoutAreaNestedInput = {
    create?: XOR<InscripcionCreateWithoutAreaInput, InscripcionUncheckedCreateWithoutAreaInput> | InscripcionCreateWithoutAreaInput[] | InscripcionUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: InscripcionCreateOrConnectWithoutAreaInput | InscripcionCreateOrConnectWithoutAreaInput[]
    upsert?: InscripcionUpsertWithWhereUniqueWithoutAreaInput | InscripcionUpsertWithWhereUniqueWithoutAreaInput[]
    createMany?: InscripcionCreateManyAreaInputEnvelope
    set?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[]
    disconnect?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[]
    delete?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[]
    connect?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[]
    update?: InscripcionUpdateWithWhereUniqueWithoutAreaInput | InscripcionUpdateWithWhereUniqueWithoutAreaInput[]
    updateMany?: InscripcionUpdateManyWithWhereWithoutAreaInput | InscripcionUpdateManyWithWhereWithoutAreaInput[]
    deleteMany?: InscripcionScalarWhereInput | InscripcionScalarWhereInput[]
  }

  export type Area_convocatoriaUncheckedUpdateManyWithoutAreaNestedInput = {
    create?: XOR<Area_convocatoriaCreateWithoutAreaInput, Area_convocatoriaUncheckedCreateWithoutAreaInput> | Area_convocatoriaCreateWithoutAreaInput[] | Area_convocatoriaUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: Area_convocatoriaCreateOrConnectWithoutAreaInput | Area_convocatoriaCreateOrConnectWithoutAreaInput[]
    upsert?: Area_convocatoriaUpsertWithWhereUniqueWithoutAreaInput | Area_convocatoriaUpsertWithWhereUniqueWithoutAreaInput[]
    createMany?: Area_convocatoriaCreateManyAreaInputEnvelope
    set?: Area_convocatoriaWhereUniqueInput | Area_convocatoriaWhereUniqueInput[]
    disconnect?: Area_convocatoriaWhereUniqueInput | Area_convocatoriaWhereUniqueInput[]
    delete?: Area_convocatoriaWhereUniqueInput | Area_convocatoriaWhereUniqueInput[]
    connect?: Area_convocatoriaWhereUniqueInput | Area_convocatoriaWhereUniqueInput[]
    update?: Area_convocatoriaUpdateWithWhereUniqueWithoutAreaInput | Area_convocatoriaUpdateWithWhereUniqueWithoutAreaInput[]
    updateMany?: Area_convocatoriaUpdateManyWithWhereWithoutAreaInput | Area_convocatoriaUpdateManyWithWhereWithoutAreaInput[]
    deleteMany?: Area_convocatoriaScalarWhereInput | Area_convocatoriaScalarWhereInput[]
  }

  export type Categoria_areaUncheckedUpdateManyWithoutAreaNestedInput = {
    create?: XOR<Categoria_areaCreateWithoutAreaInput, Categoria_areaUncheckedCreateWithoutAreaInput> | Categoria_areaCreateWithoutAreaInput[] | Categoria_areaUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: Categoria_areaCreateOrConnectWithoutAreaInput | Categoria_areaCreateOrConnectWithoutAreaInput[]
    upsert?: Categoria_areaUpsertWithWhereUniqueWithoutAreaInput | Categoria_areaUpsertWithWhereUniqueWithoutAreaInput[]
    createMany?: Categoria_areaCreateManyAreaInputEnvelope
    set?: Categoria_areaWhereUniqueInput | Categoria_areaWhereUniqueInput[]
    disconnect?: Categoria_areaWhereUniqueInput | Categoria_areaWhereUniqueInput[]
    delete?: Categoria_areaWhereUniqueInput | Categoria_areaWhereUniqueInput[]
    connect?: Categoria_areaWhereUniqueInput | Categoria_areaWhereUniqueInput[]
    update?: Categoria_areaUpdateWithWhereUniqueWithoutAreaInput | Categoria_areaUpdateWithWhereUniqueWithoutAreaInput[]
    updateMany?: Categoria_areaUpdateManyWithWhereWithoutAreaInput | Categoria_areaUpdateManyWithWhereWithoutAreaInput[]
    deleteMany?: Categoria_areaScalarWhereInput | Categoria_areaScalarWhereInput[]
  }

  export type TutorUncheckedUpdateManyWithoutAreaNestedInput = {
    create?: XOR<TutorCreateWithoutAreaInput, TutorUncheckedCreateWithoutAreaInput> | TutorCreateWithoutAreaInput[] | TutorUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: TutorCreateOrConnectWithoutAreaInput | TutorCreateOrConnectWithoutAreaInput[]
    upsert?: TutorUpsertWithWhereUniqueWithoutAreaInput | TutorUpsertWithWhereUniqueWithoutAreaInput[]
    createMany?: TutorCreateManyAreaInputEnvelope
    set?: TutorWhereUniqueInput | TutorWhereUniqueInput[]
    disconnect?: TutorWhereUniqueInput | TutorWhereUniqueInput[]
    delete?: TutorWhereUniqueInput | TutorWhereUniqueInput[]
    connect?: TutorWhereUniqueInput | TutorWhereUniqueInput[]
    update?: TutorUpdateWithWhereUniqueWithoutAreaInput | TutorUpdateWithWhereUniqueWithoutAreaInput[]
    updateMany?: TutorUpdateManyWithWhereWithoutAreaInput | TutorUpdateManyWithWhereWithoutAreaInput[]
    deleteMany?: TutorScalarWhereInput | TutorScalarWhereInput[]
  }

  export type InscripcionUncheckedUpdateManyWithoutAreaNestedInput = {
    create?: XOR<InscripcionCreateWithoutAreaInput, InscripcionUncheckedCreateWithoutAreaInput> | InscripcionCreateWithoutAreaInput[] | InscripcionUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: InscripcionCreateOrConnectWithoutAreaInput | InscripcionCreateOrConnectWithoutAreaInput[]
    upsert?: InscripcionUpsertWithWhereUniqueWithoutAreaInput | InscripcionUpsertWithWhereUniqueWithoutAreaInput[]
    createMany?: InscripcionCreateManyAreaInputEnvelope
    set?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[]
    disconnect?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[]
    delete?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[]
    connect?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[]
    update?: InscripcionUpdateWithWhereUniqueWithoutAreaInput | InscripcionUpdateWithWhereUniqueWithoutAreaInput[]
    updateMany?: InscripcionUpdateManyWithWhereWithoutAreaInput | InscripcionUpdateManyWithWhereWithoutAreaInput[]
    deleteMany?: InscripcionScalarWhereInput | InscripcionScalarWhereInput[]
  }

  export type GradoCreateNestedOneWithoutCategorias_maxInput = {
    create?: XOR<GradoCreateWithoutCategorias_maxInput, GradoUncheckedCreateWithoutCategorias_maxInput>
    connectOrCreate?: GradoCreateOrConnectWithoutCategorias_maxInput
    connect?: GradoWhereUniqueInput
  }

  export type GradoCreateNestedOneWithoutCategorias_minInput = {
    create?: XOR<GradoCreateWithoutCategorias_minInput, GradoUncheckedCreateWithoutCategorias_minInput>
    connectOrCreate?: GradoCreateOrConnectWithoutCategorias_minInput
    connect?: GradoWhereUniqueInput
  }

  export type Categoria_areaCreateNestedManyWithoutCategoriaInput = {
    create?: XOR<Categoria_areaCreateWithoutCategoriaInput, Categoria_areaUncheckedCreateWithoutCategoriaInput> | Categoria_areaCreateWithoutCategoriaInput[] | Categoria_areaUncheckedCreateWithoutCategoriaInput[]
    connectOrCreate?: Categoria_areaCreateOrConnectWithoutCategoriaInput | Categoria_areaCreateOrConnectWithoutCategoriaInput[]
    createMany?: Categoria_areaCreateManyCategoriaInputEnvelope
    connect?: Categoria_areaWhereUniqueInput | Categoria_areaWhereUniqueInput[]
  }

  export type InscripcionCreateNestedManyWithoutCategoriaInput = {
    create?: XOR<InscripcionCreateWithoutCategoriaInput, InscripcionUncheckedCreateWithoutCategoriaInput> | InscripcionCreateWithoutCategoriaInput[] | InscripcionUncheckedCreateWithoutCategoriaInput[]
    connectOrCreate?: InscripcionCreateOrConnectWithoutCategoriaInput | InscripcionCreateOrConnectWithoutCategoriaInput[]
    createMany?: InscripcionCreateManyCategoriaInputEnvelope
    connect?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[]
  }

  export type Categoria_areaUncheckedCreateNestedManyWithoutCategoriaInput = {
    create?: XOR<Categoria_areaCreateWithoutCategoriaInput, Categoria_areaUncheckedCreateWithoutCategoriaInput> | Categoria_areaCreateWithoutCategoriaInput[] | Categoria_areaUncheckedCreateWithoutCategoriaInput[]
    connectOrCreate?: Categoria_areaCreateOrConnectWithoutCategoriaInput | Categoria_areaCreateOrConnectWithoutCategoriaInput[]
    createMany?: Categoria_areaCreateManyCategoriaInputEnvelope
    connect?: Categoria_areaWhereUniqueInput | Categoria_areaWhereUniqueInput[]
  }

  export type InscripcionUncheckedCreateNestedManyWithoutCategoriaInput = {
    create?: XOR<InscripcionCreateWithoutCategoriaInput, InscripcionUncheckedCreateWithoutCategoriaInput> | InscripcionCreateWithoutCategoriaInput[] | InscripcionUncheckedCreateWithoutCategoriaInput[]
    connectOrCreate?: InscripcionCreateOrConnectWithoutCategoriaInput | InscripcionCreateOrConnectWithoutCategoriaInput[]
    createMany?: InscripcionCreateManyCategoriaInputEnvelope
    connect?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[]
  }

  export type GradoUpdateOneRequiredWithoutCategorias_maxNestedInput = {
    create?: XOR<GradoCreateWithoutCategorias_maxInput, GradoUncheckedCreateWithoutCategorias_maxInput>
    connectOrCreate?: GradoCreateOrConnectWithoutCategorias_maxInput
    upsert?: GradoUpsertWithoutCategorias_maxInput
    connect?: GradoWhereUniqueInput
    update?: XOR<XOR<GradoUpdateToOneWithWhereWithoutCategorias_maxInput, GradoUpdateWithoutCategorias_maxInput>, GradoUncheckedUpdateWithoutCategorias_maxInput>
  }

  export type GradoUpdateOneRequiredWithoutCategorias_minNestedInput = {
    create?: XOR<GradoCreateWithoutCategorias_minInput, GradoUncheckedCreateWithoutCategorias_minInput>
    connectOrCreate?: GradoCreateOrConnectWithoutCategorias_minInput
    upsert?: GradoUpsertWithoutCategorias_minInput
    connect?: GradoWhereUniqueInput
    update?: XOR<XOR<GradoUpdateToOneWithWhereWithoutCategorias_minInput, GradoUpdateWithoutCategorias_minInput>, GradoUncheckedUpdateWithoutCategorias_minInput>
  }

  export type Categoria_areaUpdateManyWithoutCategoriaNestedInput = {
    create?: XOR<Categoria_areaCreateWithoutCategoriaInput, Categoria_areaUncheckedCreateWithoutCategoriaInput> | Categoria_areaCreateWithoutCategoriaInput[] | Categoria_areaUncheckedCreateWithoutCategoriaInput[]
    connectOrCreate?: Categoria_areaCreateOrConnectWithoutCategoriaInput | Categoria_areaCreateOrConnectWithoutCategoriaInput[]
    upsert?: Categoria_areaUpsertWithWhereUniqueWithoutCategoriaInput | Categoria_areaUpsertWithWhereUniqueWithoutCategoriaInput[]
    createMany?: Categoria_areaCreateManyCategoriaInputEnvelope
    set?: Categoria_areaWhereUniqueInput | Categoria_areaWhereUniqueInput[]
    disconnect?: Categoria_areaWhereUniqueInput | Categoria_areaWhereUniqueInput[]
    delete?: Categoria_areaWhereUniqueInput | Categoria_areaWhereUniqueInput[]
    connect?: Categoria_areaWhereUniqueInput | Categoria_areaWhereUniqueInput[]
    update?: Categoria_areaUpdateWithWhereUniqueWithoutCategoriaInput | Categoria_areaUpdateWithWhereUniqueWithoutCategoriaInput[]
    updateMany?: Categoria_areaUpdateManyWithWhereWithoutCategoriaInput | Categoria_areaUpdateManyWithWhereWithoutCategoriaInput[]
    deleteMany?: Categoria_areaScalarWhereInput | Categoria_areaScalarWhereInput[]
  }

  export type InscripcionUpdateManyWithoutCategoriaNestedInput = {
    create?: XOR<InscripcionCreateWithoutCategoriaInput, InscripcionUncheckedCreateWithoutCategoriaInput> | InscripcionCreateWithoutCategoriaInput[] | InscripcionUncheckedCreateWithoutCategoriaInput[]
    connectOrCreate?: InscripcionCreateOrConnectWithoutCategoriaInput | InscripcionCreateOrConnectWithoutCategoriaInput[]
    upsert?: InscripcionUpsertWithWhereUniqueWithoutCategoriaInput | InscripcionUpsertWithWhereUniqueWithoutCategoriaInput[]
    createMany?: InscripcionCreateManyCategoriaInputEnvelope
    set?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[]
    disconnect?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[]
    delete?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[]
    connect?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[]
    update?: InscripcionUpdateWithWhereUniqueWithoutCategoriaInput | InscripcionUpdateWithWhereUniqueWithoutCategoriaInput[]
    updateMany?: InscripcionUpdateManyWithWhereWithoutCategoriaInput | InscripcionUpdateManyWithWhereWithoutCategoriaInput[]
    deleteMany?: InscripcionScalarWhereInput | InscripcionScalarWhereInput[]
  }

  export type Categoria_areaUncheckedUpdateManyWithoutCategoriaNestedInput = {
    create?: XOR<Categoria_areaCreateWithoutCategoriaInput, Categoria_areaUncheckedCreateWithoutCategoriaInput> | Categoria_areaCreateWithoutCategoriaInput[] | Categoria_areaUncheckedCreateWithoutCategoriaInput[]
    connectOrCreate?: Categoria_areaCreateOrConnectWithoutCategoriaInput | Categoria_areaCreateOrConnectWithoutCategoriaInput[]
    upsert?: Categoria_areaUpsertWithWhereUniqueWithoutCategoriaInput | Categoria_areaUpsertWithWhereUniqueWithoutCategoriaInput[]
    createMany?: Categoria_areaCreateManyCategoriaInputEnvelope
    set?: Categoria_areaWhereUniqueInput | Categoria_areaWhereUniqueInput[]
    disconnect?: Categoria_areaWhereUniqueInput | Categoria_areaWhereUniqueInput[]
    delete?: Categoria_areaWhereUniqueInput | Categoria_areaWhereUniqueInput[]
    connect?: Categoria_areaWhereUniqueInput | Categoria_areaWhereUniqueInput[]
    update?: Categoria_areaUpdateWithWhereUniqueWithoutCategoriaInput | Categoria_areaUpdateWithWhereUniqueWithoutCategoriaInput[]
    updateMany?: Categoria_areaUpdateManyWithWhereWithoutCategoriaInput | Categoria_areaUpdateManyWithWhereWithoutCategoriaInput[]
    deleteMany?: Categoria_areaScalarWhereInput | Categoria_areaScalarWhereInput[]
  }

  export type InscripcionUncheckedUpdateManyWithoutCategoriaNestedInput = {
    create?: XOR<InscripcionCreateWithoutCategoriaInput, InscripcionUncheckedCreateWithoutCategoriaInput> | InscripcionCreateWithoutCategoriaInput[] | InscripcionUncheckedCreateWithoutCategoriaInput[]
    connectOrCreate?: InscripcionCreateOrConnectWithoutCategoriaInput | InscripcionCreateOrConnectWithoutCategoriaInput[]
    upsert?: InscripcionUpsertWithWhereUniqueWithoutCategoriaInput | InscripcionUpsertWithWhereUniqueWithoutCategoriaInput[]
    createMany?: InscripcionCreateManyCategoriaInputEnvelope
    set?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[]
    disconnect?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[]
    delete?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[]
    connect?: InscripcionWhereUniqueInput | InscripcionWhereUniqueInput[]
    update?: InscripcionUpdateWithWhereUniqueWithoutCategoriaInput | InscripcionUpdateWithWhereUniqueWithoutCategoriaInput[]
    updateMany?: InscripcionUpdateManyWithWhereWithoutCategoriaInput | InscripcionUpdateManyWithWhereWithoutCategoriaInput[]
    deleteMany?: InscripcionScalarWhereInput | InscripcionScalarWhereInput[]
  }

  export type CategoriaCreateNestedManyWithoutGrado_maxInput = {
    create?: XOR<CategoriaCreateWithoutGrado_maxInput, CategoriaUncheckedCreateWithoutGrado_maxInput> | CategoriaCreateWithoutGrado_maxInput[] | CategoriaUncheckedCreateWithoutGrado_maxInput[]
    connectOrCreate?: CategoriaCreateOrConnectWithoutGrado_maxInput | CategoriaCreateOrConnectWithoutGrado_maxInput[]
    createMany?: CategoriaCreateManyGrado_maxInputEnvelope
    connect?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[]
  }

  export type CategoriaCreateNestedManyWithoutGrado_minInput = {
    create?: XOR<CategoriaCreateWithoutGrado_minInput, CategoriaUncheckedCreateWithoutGrado_minInput> | CategoriaCreateWithoutGrado_minInput[] | CategoriaUncheckedCreateWithoutGrado_minInput[]
    connectOrCreate?: CategoriaCreateOrConnectWithoutGrado_minInput | CategoriaCreateOrConnectWithoutGrado_minInput[]
    createMany?: CategoriaCreateManyGrado_minInputEnvelope
    connect?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[]
  }

  export type NivelCreateNestedOneWithoutGradoInput = {
    create?: XOR<NivelCreateWithoutGradoInput, NivelUncheckedCreateWithoutGradoInput>
    connectOrCreate?: NivelCreateOrConnectWithoutGradoInput
    connect?: NivelWhereUniqueInput
  }

  export type CategoriaUncheckedCreateNestedManyWithoutGrado_maxInput = {
    create?: XOR<CategoriaCreateWithoutGrado_maxInput, CategoriaUncheckedCreateWithoutGrado_maxInput> | CategoriaCreateWithoutGrado_maxInput[] | CategoriaUncheckedCreateWithoutGrado_maxInput[]
    connectOrCreate?: CategoriaCreateOrConnectWithoutGrado_maxInput | CategoriaCreateOrConnectWithoutGrado_maxInput[]
    createMany?: CategoriaCreateManyGrado_maxInputEnvelope
    connect?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[]
  }

  export type CategoriaUncheckedCreateNestedManyWithoutGrado_minInput = {
    create?: XOR<CategoriaCreateWithoutGrado_minInput, CategoriaUncheckedCreateWithoutGrado_minInput> | CategoriaCreateWithoutGrado_minInput[] | CategoriaUncheckedCreateWithoutGrado_minInput[]
    connectOrCreate?: CategoriaCreateOrConnectWithoutGrado_minInput | CategoriaCreateOrConnectWithoutGrado_minInput[]
    createMany?: CategoriaCreateManyGrado_minInputEnvelope
    connect?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[]
  }

  export type CategoriaUpdateManyWithoutGrado_maxNestedInput = {
    create?: XOR<CategoriaCreateWithoutGrado_maxInput, CategoriaUncheckedCreateWithoutGrado_maxInput> | CategoriaCreateWithoutGrado_maxInput[] | CategoriaUncheckedCreateWithoutGrado_maxInput[]
    connectOrCreate?: CategoriaCreateOrConnectWithoutGrado_maxInput | CategoriaCreateOrConnectWithoutGrado_maxInput[]
    upsert?: CategoriaUpsertWithWhereUniqueWithoutGrado_maxInput | CategoriaUpsertWithWhereUniqueWithoutGrado_maxInput[]
    createMany?: CategoriaCreateManyGrado_maxInputEnvelope
    set?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[]
    disconnect?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[]
    delete?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[]
    connect?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[]
    update?: CategoriaUpdateWithWhereUniqueWithoutGrado_maxInput | CategoriaUpdateWithWhereUniqueWithoutGrado_maxInput[]
    updateMany?: CategoriaUpdateManyWithWhereWithoutGrado_maxInput | CategoriaUpdateManyWithWhereWithoutGrado_maxInput[]
    deleteMany?: CategoriaScalarWhereInput | CategoriaScalarWhereInput[]
  }

  export type CategoriaUpdateManyWithoutGrado_minNestedInput = {
    create?: XOR<CategoriaCreateWithoutGrado_minInput, CategoriaUncheckedCreateWithoutGrado_minInput> | CategoriaCreateWithoutGrado_minInput[] | CategoriaUncheckedCreateWithoutGrado_minInput[]
    connectOrCreate?: CategoriaCreateOrConnectWithoutGrado_minInput | CategoriaCreateOrConnectWithoutGrado_minInput[]
    upsert?: CategoriaUpsertWithWhereUniqueWithoutGrado_minInput | CategoriaUpsertWithWhereUniqueWithoutGrado_minInput[]
    createMany?: CategoriaCreateManyGrado_minInputEnvelope
    set?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[]
    disconnect?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[]
    delete?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[]
    connect?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[]
    update?: CategoriaUpdateWithWhereUniqueWithoutGrado_minInput | CategoriaUpdateWithWhereUniqueWithoutGrado_minInput[]
    updateMany?: CategoriaUpdateManyWithWhereWithoutGrado_minInput | CategoriaUpdateManyWithWhereWithoutGrado_minInput[]
    deleteMany?: CategoriaScalarWhereInput | CategoriaScalarWhereInput[]
  }

  export type NivelUpdateOneRequiredWithoutGradoNestedInput = {
    create?: XOR<NivelCreateWithoutGradoInput, NivelUncheckedCreateWithoutGradoInput>
    connectOrCreate?: NivelCreateOrConnectWithoutGradoInput
    upsert?: NivelUpsertWithoutGradoInput
    connect?: NivelWhereUniqueInput
    update?: XOR<XOR<NivelUpdateToOneWithWhereWithoutGradoInput, NivelUpdateWithoutGradoInput>, NivelUncheckedUpdateWithoutGradoInput>
  }

  export type CategoriaUncheckedUpdateManyWithoutGrado_maxNestedInput = {
    create?: XOR<CategoriaCreateWithoutGrado_maxInput, CategoriaUncheckedCreateWithoutGrado_maxInput> | CategoriaCreateWithoutGrado_maxInput[] | CategoriaUncheckedCreateWithoutGrado_maxInput[]
    connectOrCreate?: CategoriaCreateOrConnectWithoutGrado_maxInput | CategoriaCreateOrConnectWithoutGrado_maxInput[]
    upsert?: CategoriaUpsertWithWhereUniqueWithoutGrado_maxInput | CategoriaUpsertWithWhereUniqueWithoutGrado_maxInput[]
    createMany?: CategoriaCreateManyGrado_maxInputEnvelope
    set?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[]
    disconnect?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[]
    delete?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[]
    connect?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[]
    update?: CategoriaUpdateWithWhereUniqueWithoutGrado_maxInput | CategoriaUpdateWithWhereUniqueWithoutGrado_maxInput[]
    updateMany?: CategoriaUpdateManyWithWhereWithoutGrado_maxInput | CategoriaUpdateManyWithWhereWithoutGrado_maxInput[]
    deleteMany?: CategoriaScalarWhereInput | CategoriaScalarWhereInput[]
  }

  export type CategoriaUncheckedUpdateManyWithoutGrado_minNestedInput = {
    create?: XOR<CategoriaCreateWithoutGrado_minInput, CategoriaUncheckedCreateWithoutGrado_minInput> | CategoriaCreateWithoutGrado_minInput[] | CategoriaUncheckedCreateWithoutGrado_minInput[]
    connectOrCreate?: CategoriaCreateOrConnectWithoutGrado_minInput | CategoriaCreateOrConnectWithoutGrado_minInput[]
    upsert?: CategoriaUpsertWithWhereUniqueWithoutGrado_minInput | CategoriaUpsertWithWhereUniqueWithoutGrado_minInput[]
    createMany?: CategoriaCreateManyGrado_minInputEnvelope
    set?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[]
    disconnect?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[]
    delete?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[]
    connect?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[]
    update?: CategoriaUpdateWithWhereUniqueWithoutGrado_minInput | CategoriaUpdateWithWhereUniqueWithoutGrado_minInput[]
    updateMany?: CategoriaUpdateManyWithWhereWithoutGrado_minInput | CategoriaUpdateManyWithWhereWithoutGrado_minInput[]
    deleteMany?: CategoriaScalarWhereInput | CategoriaScalarWhereInput[]
  }

  export type InscripcionCreateNestedOneWithoutPagosInput = {
    create?: XOR<InscripcionCreateWithoutPagosInput, InscripcionUncheckedCreateWithoutPagosInput>
    connectOrCreate?: InscripcionCreateOrConnectWithoutPagosInput
    connect?: InscripcionWhereUniqueInput
  }

  export type Metodo_pagoCreateNestedOneWithoutPagoInput = {
    create?: XOR<Metodo_pagoCreateWithoutPagoInput, Metodo_pagoUncheckedCreateWithoutPagoInput>
    connectOrCreate?: Metodo_pagoCreateOrConnectWithoutPagoInput
    connect?: Metodo_pagoWhereUniqueInput
  }

  export type InscripcionUpdateOneRequiredWithoutPagosNestedInput = {
    create?: XOR<InscripcionCreateWithoutPagosInput, InscripcionUncheckedCreateWithoutPagosInput>
    connectOrCreate?: InscripcionCreateOrConnectWithoutPagosInput
    upsert?: InscripcionUpsertWithoutPagosInput
    connect?: InscripcionWhereUniqueInput
    update?: XOR<XOR<InscripcionUpdateToOneWithWhereWithoutPagosInput, InscripcionUpdateWithoutPagosInput>, InscripcionUncheckedUpdateWithoutPagosInput>
  }

  export type Metodo_pagoUpdateOneRequiredWithoutPagoNestedInput = {
    create?: XOR<Metodo_pagoCreateWithoutPagoInput, Metodo_pagoUncheckedCreateWithoutPagoInput>
    connectOrCreate?: Metodo_pagoCreateOrConnectWithoutPagoInput
    upsert?: Metodo_pagoUpsertWithoutPagoInput
    connect?: Metodo_pagoWhereUniqueInput
    update?: XOR<XOR<Metodo_pagoUpdateToOneWithWhereWithoutPagoInput, Metodo_pagoUpdateWithoutPagoInput>, Metodo_pagoUncheckedUpdateWithoutPagoInput>
  }

  export type AreaCreateNestedOneWithoutArea_convocatoriaInput = {
    create?: XOR<AreaCreateWithoutArea_convocatoriaInput, AreaUncheckedCreateWithoutArea_convocatoriaInput>
    connectOrCreate?: AreaCreateOrConnectWithoutArea_convocatoriaInput
    connect?: AreaWhereUniqueInput
  }

  export type ConvocatoriaCreateNestedOneWithoutArea_convocatoriaInput = {
    create?: XOR<ConvocatoriaCreateWithoutArea_convocatoriaInput, ConvocatoriaUncheckedCreateWithoutArea_convocatoriaInput>
    connectOrCreate?: ConvocatoriaCreateOrConnectWithoutArea_convocatoriaInput
    connect?: ConvocatoriaWhereUniqueInput
  }

  export type AreaUpdateOneRequiredWithoutArea_convocatoriaNestedInput = {
    create?: XOR<AreaCreateWithoutArea_convocatoriaInput, AreaUncheckedCreateWithoutArea_convocatoriaInput>
    connectOrCreate?: AreaCreateOrConnectWithoutArea_convocatoriaInput
    upsert?: AreaUpsertWithoutArea_convocatoriaInput
    connect?: AreaWhereUniqueInput
    update?: XOR<XOR<AreaUpdateToOneWithWhereWithoutArea_convocatoriaInput, AreaUpdateWithoutArea_convocatoriaInput>, AreaUncheckedUpdateWithoutArea_convocatoriaInput>
  }

  export type ConvocatoriaUpdateOneRequiredWithoutArea_convocatoriaNestedInput = {
    create?: XOR<ConvocatoriaCreateWithoutArea_convocatoriaInput, ConvocatoriaUncheckedCreateWithoutArea_convocatoriaInput>
    connectOrCreate?: ConvocatoriaCreateOrConnectWithoutArea_convocatoriaInput
    upsert?: ConvocatoriaUpsertWithoutArea_convocatoriaInput
    connect?: ConvocatoriaWhereUniqueInput
    update?: XOR<XOR<ConvocatoriaUpdateToOneWithWhereWithoutArea_convocatoriaInput, ConvocatoriaUpdateWithoutArea_convocatoriaInput>, ConvocatoriaUncheckedUpdateWithoutArea_convocatoriaInput>
  }

  export type AreaCreateNestedOneWithoutArea_categoriaInput = {
    create?: XOR<AreaCreateWithoutArea_categoriaInput, AreaUncheckedCreateWithoutArea_categoriaInput>
    connectOrCreate?: AreaCreateOrConnectWithoutArea_categoriaInput
    connect?: AreaWhereUniqueInput
  }

  export type CategoriaCreateNestedOneWithoutCategoria_convocatoriaInput = {
    create?: XOR<CategoriaCreateWithoutCategoria_convocatoriaInput, CategoriaUncheckedCreateWithoutCategoria_convocatoriaInput>
    connectOrCreate?: CategoriaCreateOrConnectWithoutCategoria_convocatoriaInput
    connect?: CategoriaWhereUniqueInput
  }

  export type AreaUpdateOneRequiredWithoutArea_categoriaNestedInput = {
    create?: XOR<AreaCreateWithoutArea_categoriaInput, AreaUncheckedCreateWithoutArea_categoriaInput>
    connectOrCreate?: AreaCreateOrConnectWithoutArea_categoriaInput
    upsert?: AreaUpsertWithoutArea_categoriaInput
    connect?: AreaWhereUniqueInput
    update?: XOR<XOR<AreaUpdateToOneWithWhereWithoutArea_categoriaInput, AreaUpdateWithoutArea_categoriaInput>, AreaUncheckedUpdateWithoutArea_categoriaInput>
  }

  export type CategoriaUpdateOneRequiredWithoutCategoria_convocatoriaNestedInput = {
    create?: XOR<CategoriaCreateWithoutCategoria_convocatoriaInput, CategoriaUncheckedCreateWithoutCategoria_convocatoriaInput>
    connectOrCreate?: CategoriaCreateOrConnectWithoutCategoria_convocatoriaInput
    upsert?: CategoriaUpsertWithoutCategoria_convocatoriaInput
    connect?: CategoriaWhereUniqueInput
    update?: XOR<XOR<CategoriaUpdateToOneWithWhereWithoutCategoria_convocatoriaInput, CategoriaUpdateWithoutCategoria_convocatoriaInput>, CategoriaUncheckedUpdateWithoutCategoria_convocatoriaInput>
  }

  export type InscripcionCreateNestedOneWithoutTutorInscripcionesInput = {
    create?: XOR<InscripcionCreateWithoutTutorInscripcionesInput, InscripcionUncheckedCreateWithoutTutorInscripcionesInput>
    connectOrCreate?: InscripcionCreateOrConnectWithoutTutorInscripcionesInput
    connect?: InscripcionWhereUniqueInput
  }

  export type TutorCreateNestedOneWithoutInscripciones_tutorInput = {
    create?: XOR<TutorCreateWithoutInscripciones_tutorInput, TutorUncheckedCreateWithoutInscripciones_tutorInput>
    connectOrCreate?: TutorCreateOrConnectWithoutInscripciones_tutorInput
    connect?: TutorWhereUniqueInput
  }

  export type CompetidorCreateNestedOneWithoutInscripcionesInput = {
    create?: XOR<CompetidorCreateWithoutInscripcionesInput, CompetidorUncheckedCreateWithoutInscripcionesInput>
    connectOrCreate?: CompetidorCreateOrConnectWithoutInscripcionesInput
    connect?: CompetidorWhereUniqueInput
  }

  export type Motivo_rechazoCreateNestedOneWithoutInscripcionesTutorInput = {
    create?: XOR<Motivo_rechazoCreateWithoutInscripcionesTutorInput, Motivo_rechazoUncheckedCreateWithoutInscripcionesTutorInput>
    connectOrCreate?: Motivo_rechazoCreateOrConnectWithoutInscripcionesTutorInput
    connect?: Motivo_rechazoWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type InscripcionUpdateOneRequiredWithoutTutorInscripcionesNestedInput = {
    create?: XOR<InscripcionCreateWithoutTutorInscripcionesInput, InscripcionUncheckedCreateWithoutTutorInscripcionesInput>
    connectOrCreate?: InscripcionCreateOrConnectWithoutTutorInscripcionesInput
    upsert?: InscripcionUpsertWithoutTutorInscripcionesInput
    connect?: InscripcionWhereUniqueInput
    update?: XOR<XOR<InscripcionUpdateToOneWithWhereWithoutTutorInscripcionesInput, InscripcionUpdateWithoutTutorInscripcionesInput>, InscripcionUncheckedUpdateWithoutTutorInscripcionesInput>
  }

  export type TutorUpdateOneRequiredWithoutInscripciones_tutorNestedInput = {
    create?: XOR<TutorCreateWithoutInscripciones_tutorInput, TutorUncheckedCreateWithoutInscripciones_tutorInput>
    connectOrCreate?: TutorCreateOrConnectWithoutInscripciones_tutorInput
    upsert?: TutorUpsertWithoutInscripciones_tutorInput
    connect?: TutorWhereUniqueInput
    update?: XOR<XOR<TutorUpdateToOneWithWhereWithoutInscripciones_tutorInput, TutorUpdateWithoutInscripciones_tutorInput>, TutorUncheckedUpdateWithoutInscripciones_tutorInput>
  }

  export type CompetidorUpdateOneWithoutInscripcionesNestedInput = {
    create?: XOR<CompetidorCreateWithoutInscripcionesInput, CompetidorUncheckedCreateWithoutInscripcionesInput>
    connectOrCreate?: CompetidorCreateOrConnectWithoutInscripcionesInput
    upsert?: CompetidorUpsertWithoutInscripcionesInput
    disconnect?: CompetidorWhereInput | boolean
    delete?: CompetidorWhereInput | boolean
    connect?: CompetidorWhereUniqueInput
    update?: XOR<XOR<CompetidorUpdateToOneWithWhereWithoutInscripcionesInput, CompetidorUpdateWithoutInscripcionesInput>, CompetidorUncheckedUpdateWithoutInscripcionesInput>
  }

  export type Motivo_rechazoUpdateOneWithoutInscripcionesTutorNestedInput = {
    create?: XOR<Motivo_rechazoCreateWithoutInscripcionesTutorInput, Motivo_rechazoUncheckedCreateWithoutInscripcionesTutorInput>
    connectOrCreate?: Motivo_rechazoCreateOrConnectWithoutInscripcionesTutorInput
    upsert?: Motivo_rechazoUpsertWithoutInscripcionesTutorInput
    disconnect?: Motivo_rechazoWhereInput | boolean
    delete?: Motivo_rechazoWhereInput | boolean
    connect?: Motivo_rechazoWhereUniqueInput
    update?: XOR<XOR<Motivo_rechazoUpdateToOneWithWhereWithoutInscripcionesTutorInput, Motivo_rechazoUpdateWithoutInscripcionesTutorInput>, Motivo_rechazoUncheckedUpdateWithoutInscripcionesTutorInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PagoCreateNestedManyWithoutMetodo_pagoInput = {
    create?: XOR<PagoCreateWithoutMetodo_pagoInput, PagoUncheckedCreateWithoutMetodo_pagoInput> | PagoCreateWithoutMetodo_pagoInput[] | PagoUncheckedCreateWithoutMetodo_pagoInput[]
    connectOrCreate?: PagoCreateOrConnectWithoutMetodo_pagoInput | PagoCreateOrConnectWithoutMetodo_pagoInput[]
    createMany?: PagoCreateManyMetodo_pagoInputEnvelope
    connect?: PagoWhereUniqueInput | PagoWhereUniqueInput[]
  }

  export type PagoUncheckedCreateNestedManyWithoutMetodo_pagoInput = {
    create?: XOR<PagoCreateWithoutMetodo_pagoInput, PagoUncheckedCreateWithoutMetodo_pagoInput> | PagoCreateWithoutMetodo_pagoInput[] | PagoUncheckedCreateWithoutMetodo_pagoInput[]
    connectOrCreate?: PagoCreateOrConnectWithoutMetodo_pagoInput | PagoCreateOrConnectWithoutMetodo_pagoInput[]
    createMany?: PagoCreateManyMetodo_pagoInputEnvelope
    connect?: PagoWhereUniqueInput | PagoWhereUniqueInput[]
  }

  export type PagoUpdateManyWithoutMetodo_pagoNestedInput = {
    create?: XOR<PagoCreateWithoutMetodo_pagoInput, PagoUncheckedCreateWithoutMetodo_pagoInput> | PagoCreateWithoutMetodo_pagoInput[] | PagoUncheckedCreateWithoutMetodo_pagoInput[]
    connectOrCreate?: PagoCreateOrConnectWithoutMetodo_pagoInput | PagoCreateOrConnectWithoutMetodo_pagoInput[]
    upsert?: PagoUpsertWithWhereUniqueWithoutMetodo_pagoInput | PagoUpsertWithWhereUniqueWithoutMetodo_pagoInput[]
    createMany?: PagoCreateManyMetodo_pagoInputEnvelope
    set?: PagoWhereUniqueInput | PagoWhereUniqueInput[]
    disconnect?: PagoWhereUniqueInput | PagoWhereUniqueInput[]
    delete?: PagoWhereUniqueInput | PagoWhereUniqueInput[]
    connect?: PagoWhereUniqueInput | PagoWhereUniqueInput[]
    update?: PagoUpdateWithWhereUniqueWithoutMetodo_pagoInput | PagoUpdateWithWhereUniqueWithoutMetodo_pagoInput[]
    updateMany?: PagoUpdateManyWithWhereWithoutMetodo_pagoInput | PagoUpdateManyWithWhereWithoutMetodo_pagoInput[]
    deleteMany?: PagoScalarWhereInput | PagoScalarWhereInput[]
  }

  export type PagoUncheckedUpdateManyWithoutMetodo_pagoNestedInput = {
    create?: XOR<PagoCreateWithoutMetodo_pagoInput, PagoUncheckedCreateWithoutMetodo_pagoInput> | PagoCreateWithoutMetodo_pagoInput[] | PagoUncheckedCreateWithoutMetodo_pagoInput[]
    connectOrCreate?: PagoCreateOrConnectWithoutMetodo_pagoInput | PagoCreateOrConnectWithoutMetodo_pagoInput[]
    upsert?: PagoUpsertWithWhereUniqueWithoutMetodo_pagoInput | PagoUpsertWithWhereUniqueWithoutMetodo_pagoInput[]
    createMany?: PagoCreateManyMetodo_pagoInputEnvelope
    set?: PagoWhereUniqueInput | PagoWhereUniqueInput[]
    disconnect?: PagoWhereUniqueInput | PagoWhereUniqueInput[]
    delete?: PagoWhereUniqueInput | PagoWhereUniqueInput[]
    connect?: PagoWhereUniqueInput | PagoWhereUniqueInput[]
    update?: PagoUpdateWithWhereUniqueWithoutMetodo_pagoInput | PagoUpdateWithWhereUniqueWithoutMetodo_pagoInput[]
    updateMany?: PagoUpdateManyWithWhereWithoutMetodo_pagoInput | PagoUpdateManyWithWhereWithoutMetodo_pagoInput[]
    deleteMany?: PagoScalarWhereInput | PagoScalarWhereInput[]
  }

  export type ConvocatoriaCreateNestedManyWithoutEstado_convocatoriaInput = {
    create?: XOR<ConvocatoriaCreateWithoutEstado_convocatoriaInput, ConvocatoriaUncheckedCreateWithoutEstado_convocatoriaInput> | ConvocatoriaCreateWithoutEstado_convocatoriaInput[] | ConvocatoriaUncheckedCreateWithoutEstado_convocatoriaInput[]
    connectOrCreate?: ConvocatoriaCreateOrConnectWithoutEstado_convocatoriaInput | ConvocatoriaCreateOrConnectWithoutEstado_convocatoriaInput[]
    createMany?: ConvocatoriaCreateManyEstado_convocatoriaInputEnvelope
    connect?: ConvocatoriaWhereUniqueInput | ConvocatoriaWhereUniqueInput[]
  }

  export type ConvocatoriaUncheckedCreateNestedManyWithoutEstado_convocatoriaInput = {
    create?: XOR<ConvocatoriaCreateWithoutEstado_convocatoriaInput, ConvocatoriaUncheckedCreateWithoutEstado_convocatoriaInput> | ConvocatoriaCreateWithoutEstado_convocatoriaInput[] | ConvocatoriaUncheckedCreateWithoutEstado_convocatoriaInput[]
    connectOrCreate?: ConvocatoriaCreateOrConnectWithoutEstado_convocatoriaInput | ConvocatoriaCreateOrConnectWithoutEstado_convocatoriaInput[]
    createMany?: ConvocatoriaCreateManyEstado_convocatoriaInputEnvelope
    connect?: ConvocatoriaWhereUniqueInput | ConvocatoriaWhereUniqueInput[]
  }

  export type ConvocatoriaUpdateManyWithoutEstado_convocatoriaNestedInput = {
    create?: XOR<ConvocatoriaCreateWithoutEstado_convocatoriaInput, ConvocatoriaUncheckedCreateWithoutEstado_convocatoriaInput> | ConvocatoriaCreateWithoutEstado_convocatoriaInput[] | ConvocatoriaUncheckedCreateWithoutEstado_convocatoriaInput[]
    connectOrCreate?: ConvocatoriaCreateOrConnectWithoutEstado_convocatoriaInput | ConvocatoriaCreateOrConnectWithoutEstado_convocatoriaInput[]
    upsert?: ConvocatoriaUpsertWithWhereUniqueWithoutEstado_convocatoriaInput | ConvocatoriaUpsertWithWhereUniqueWithoutEstado_convocatoriaInput[]
    createMany?: ConvocatoriaCreateManyEstado_convocatoriaInputEnvelope
    set?: ConvocatoriaWhereUniqueInput | ConvocatoriaWhereUniqueInput[]
    disconnect?: ConvocatoriaWhereUniqueInput | ConvocatoriaWhereUniqueInput[]
    delete?: ConvocatoriaWhereUniqueInput | ConvocatoriaWhereUniqueInput[]
    connect?: ConvocatoriaWhereUniqueInput | ConvocatoriaWhereUniqueInput[]
    update?: ConvocatoriaUpdateWithWhereUniqueWithoutEstado_convocatoriaInput | ConvocatoriaUpdateWithWhereUniqueWithoutEstado_convocatoriaInput[]
    updateMany?: ConvocatoriaUpdateManyWithWhereWithoutEstado_convocatoriaInput | ConvocatoriaUpdateManyWithWhereWithoutEstado_convocatoriaInput[]
    deleteMany?: ConvocatoriaScalarWhereInput | ConvocatoriaScalarWhereInput[]
  }

  export type ConvocatoriaUncheckedUpdateManyWithoutEstado_convocatoriaNestedInput = {
    create?: XOR<ConvocatoriaCreateWithoutEstado_convocatoriaInput, ConvocatoriaUncheckedCreateWithoutEstado_convocatoriaInput> | ConvocatoriaCreateWithoutEstado_convocatoriaInput[] | ConvocatoriaUncheckedCreateWithoutEstado_convocatoriaInput[]
    connectOrCreate?: ConvocatoriaCreateOrConnectWithoutEstado_convocatoriaInput | ConvocatoriaCreateOrConnectWithoutEstado_convocatoriaInput[]
    upsert?: ConvocatoriaUpsertWithWhereUniqueWithoutEstado_convocatoriaInput | ConvocatoriaUpsertWithWhereUniqueWithoutEstado_convocatoriaInput[]
    createMany?: ConvocatoriaCreateManyEstado_convocatoriaInputEnvelope
    set?: ConvocatoriaWhereUniqueInput | ConvocatoriaWhereUniqueInput[]
    disconnect?: ConvocatoriaWhereUniqueInput | ConvocatoriaWhereUniqueInput[]
    delete?: ConvocatoriaWhereUniqueInput | ConvocatoriaWhereUniqueInput[]
    connect?: ConvocatoriaWhereUniqueInput | ConvocatoriaWhereUniqueInput[]
    update?: ConvocatoriaUpdateWithWhereUniqueWithoutEstado_convocatoriaInput | ConvocatoriaUpdateWithWhereUniqueWithoutEstado_convocatoriaInput[]
    updateMany?: ConvocatoriaUpdateManyWithWhereWithoutEstado_convocatoriaInput | ConvocatoriaUpdateManyWithWhereWithoutEstado_convocatoriaInput[]
    deleteMany?: ConvocatoriaScalarWhereInput | ConvocatoriaScalarWhereInput[]
  }

  export type Inscripcion_tutorCreateNestedManyWithoutInscripcionInput = {
    create?: XOR<Inscripcion_tutorCreateWithoutInscripcionInput, Inscripcion_tutorUncheckedCreateWithoutInscripcionInput> | Inscripcion_tutorCreateWithoutInscripcionInput[] | Inscripcion_tutorUncheckedCreateWithoutInscripcionInput[]
    connectOrCreate?: Inscripcion_tutorCreateOrConnectWithoutInscripcionInput | Inscripcion_tutorCreateOrConnectWithoutInscripcionInput[]
    createMany?: Inscripcion_tutorCreateManyInscripcionInputEnvelope
    connect?: Inscripcion_tutorWhereUniqueInput | Inscripcion_tutorWhereUniqueInput[]
  }

  export type PagoCreateNestedManyWithoutInscripcionInput = {
    create?: XOR<PagoCreateWithoutInscripcionInput, PagoUncheckedCreateWithoutInscripcionInput> | PagoCreateWithoutInscripcionInput[] | PagoUncheckedCreateWithoutInscripcionInput[]
    connectOrCreate?: PagoCreateOrConnectWithoutInscripcionInput | PagoCreateOrConnectWithoutInscripcionInput[]
    createMany?: PagoCreateManyInscripcionInputEnvelope
    connect?: PagoWhereUniqueInput | PagoWhereUniqueInput[]
  }

  export type CompetidorCreateNestedOneWithoutInscripcionInput = {
    create?: XOR<CompetidorCreateWithoutInscripcionInput, CompetidorUncheckedCreateWithoutInscripcionInput>
    connectOrCreate?: CompetidorCreateOrConnectWithoutInscripcionInput
    connect?: CompetidorWhereUniqueInput
  }

  export type AreaCreateNestedOneWithoutInscripcionInput = {
    create?: XOR<AreaCreateWithoutInscripcionInput, AreaUncheckedCreateWithoutInscripcionInput>
    connectOrCreate?: AreaCreateOrConnectWithoutInscripcionInput
    connect?: AreaWhereUniqueInput
  }

  export type ConvocatoriaCreateNestedOneWithoutInscripcionInput = {
    create?: XOR<ConvocatoriaCreateWithoutInscripcionInput, ConvocatoriaUncheckedCreateWithoutInscripcionInput>
    connectOrCreate?: ConvocatoriaCreateOrConnectWithoutInscripcionInput
    connect?: ConvocatoriaWhereUniqueInput
  }

  export type CategoriaCreateNestedOneWithoutInscripcionInput = {
    create?: XOR<CategoriaCreateWithoutInscripcionInput, CategoriaUncheckedCreateWithoutInscripcionInput>
    connectOrCreate?: CategoriaCreateOrConnectWithoutInscripcionInput
    connect?: CategoriaWhereUniqueInput
  }

  export type Inscripcion_tutorUncheckedCreateNestedManyWithoutInscripcionInput = {
    create?: XOR<Inscripcion_tutorCreateWithoutInscripcionInput, Inscripcion_tutorUncheckedCreateWithoutInscripcionInput> | Inscripcion_tutorCreateWithoutInscripcionInput[] | Inscripcion_tutorUncheckedCreateWithoutInscripcionInput[]
    connectOrCreate?: Inscripcion_tutorCreateOrConnectWithoutInscripcionInput | Inscripcion_tutorCreateOrConnectWithoutInscripcionInput[]
    createMany?: Inscripcion_tutorCreateManyInscripcionInputEnvelope
    connect?: Inscripcion_tutorWhereUniqueInput | Inscripcion_tutorWhereUniqueInput[]
  }

  export type PagoUncheckedCreateNestedManyWithoutInscripcionInput = {
    create?: XOR<PagoCreateWithoutInscripcionInput, PagoUncheckedCreateWithoutInscripcionInput> | PagoCreateWithoutInscripcionInput[] | PagoUncheckedCreateWithoutInscripcionInput[]
    connectOrCreate?: PagoCreateOrConnectWithoutInscripcionInput | PagoCreateOrConnectWithoutInscripcionInput[]
    createMany?: PagoCreateManyInscripcionInputEnvelope
    connect?: PagoWhereUniqueInput | PagoWhereUniqueInput[]
  }

  export type Inscripcion_tutorUpdateManyWithoutInscripcionNestedInput = {
    create?: XOR<Inscripcion_tutorCreateWithoutInscripcionInput, Inscripcion_tutorUncheckedCreateWithoutInscripcionInput> | Inscripcion_tutorCreateWithoutInscripcionInput[] | Inscripcion_tutorUncheckedCreateWithoutInscripcionInput[]
    connectOrCreate?: Inscripcion_tutorCreateOrConnectWithoutInscripcionInput | Inscripcion_tutorCreateOrConnectWithoutInscripcionInput[]
    upsert?: Inscripcion_tutorUpsertWithWhereUniqueWithoutInscripcionInput | Inscripcion_tutorUpsertWithWhereUniqueWithoutInscripcionInput[]
    createMany?: Inscripcion_tutorCreateManyInscripcionInputEnvelope
    set?: Inscripcion_tutorWhereUniqueInput | Inscripcion_tutorWhereUniqueInput[]
    disconnect?: Inscripcion_tutorWhereUniqueInput | Inscripcion_tutorWhereUniqueInput[]
    delete?: Inscripcion_tutorWhereUniqueInput | Inscripcion_tutorWhereUniqueInput[]
    connect?: Inscripcion_tutorWhereUniqueInput | Inscripcion_tutorWhereUniqueInput[]
    update?: Inscripcion_tutorUpdateWithWhereUniqueWithoutInscripcionInput | Inscripcion_tutorUpdateWithWhereUniqueWithoutInscripcionInput[]
    updateMany?: Inscripcion_tutorUpdateManyWithWhereWithoutInscripcionInput | Inscripcion_tutorUpdateManyWithWhereWithoutInscripcionInput[]
    deleteMany?: Inscripcion_tutorScalarWhereInput | Inscripcion_tutorScalarWhereInput[]
  }

  export type PagoUpdateManyWithoutInscripcionNestedInput = {
    create?: XOR<PagoCreateWithoutInscripcionInput, PagoUncheckedCreateWithoutInscripcionInput> | PagoCreateWithoutInscripcionInput[] | PagoUncheckedCreateWithoutInscripcionInput[]
    connectOrCreate?: PagoCreateOrConnectWithoutInscripcionInput | PagoCreateOrConnectWithoutInscripcionInput[]
    upsert?: PagoUpsertWithWhereUniqueWithoutInscripcionInput | PagoUpsertWithWhereUniqueWithoutInscripcionInput[]
    createMany?: PagoCreateManyInscripcionInputEnvelope
    set?: PagoWhereUniqueInput | PagoWhereUniqueInput[]
    disconnect?: PagoWhereUniqueInput | PagoWhereUniqueInput[]
    delete?: PagoWhereUniqueInput | PagoWhereUniqueInput[]
    connect?: PagoWhereUniqueInput | PagoWhereUniqueInput[]
    update?: PagoUpdateWithWhereUniqueWithoutInscripcionInput | PagoUpdateWithWhereUniqueWithoutInscripcionInput[]
    updateMany?: PagoUpdateManyWithWhereWithoutInscripcionInput | PagoUpdateManyWithWhereWithoutInscripcionInput[]
    deleteMany?: PagoScalarWhereInput | PagoScalarWhereInput[]
  }

  export type CompetidorUpdateOneRequiredWithoutInscripcionNestedInput = {
    create?: XOR<CompetidorCreateWithoutInscripcionInput, CompetidorUncheckedCreateWithoutInscripcionInput>
    connectOrCreate?: CompetidorCreateOrConnectWithoutInscripcionInput
    upsert?: CompetidorUpsertWithoutInscripcionInput
    connect?: CompetidorWhereUniqueInput
    update?: XOR<XOR<CompetidorUpdateToOneWithWhereWithoutInscripcionInput, CompetidorUpdateWithoutInscripcionInput>, CompetidorUncheckedUpdateWithoutInscripcionInput>
  }

  export type AreaUpdateOneRequiredWithoutInscripcionNestedInput = {
    create?: XOR<AreaCreateWithoutInscripcionInput, AreaUncheckedCreateWithoutInscripcionInput>
    connectOrCreate?: AreaCreateOrConnectWithoutInscripcionInput
    upsert?: AreaUpsertWithoutInscripcionInput
    connect?: AreaWhereUniqueInput
    update?: XOR<XOR<AreaUpdateToOneWithWhereWithoutInscripcionInput, AreaUpdateWithoutInscripcionInput>, AreaUncheckedUpdateWithoutInscripcionInput>
  }

  export type ConvocatoriaUpdateOneRequiredWithoutInscripcionNestedInput = {
    create?: XOR<ConvocatoriaCreateWithoutInscripcionInput, ConvocatoriaUncheckedCreateWithoutInscripcionInput>
    connectOrCreate?: ConvocatoriaCreateOrConnectWithoutInscripcionInput
    upsert?: ConvocatoriaUpsertWithoutInscripcionInput
    connect?: ConvocatoriaWhereUniqueInput
    update?: XOR<XOR<ConvocatoriaUpdateToOneWithWhereWithoutInscripcionInput, ConvocatoriaUpdateWithoutInscripcionInput>, ConvocatoriaUncheckedUpdateWithoutInscripcionInput>
  }

  export type CategoriaUpdateOneRequiredWithoutInscripcionNestedInput = {
    create?: XOR<CategoriaCreateWithoutInscripcionInput, CategoriaUncheckedCreateWithoutInscripcionInput>
    connectOrCreate?: CategoriaCreateOrConnectWithoutInscripcionInput
    upsert?: CategoriaUpsertWithoutInscripcionInput
    connect?: CategoriaWhereUniqueInput
    update?: XOR<XOR<CategoriaUpdateToOneWithWhereWithoutInscripcionInput, CategoriaUpdateWithoutInscripcionInput>, CategoriaUncheckedUpdateWithoutInscripcionInput>
  }

  export type Inscripcion_tutorUncheckedUpdateManyWithoutInscripcionNestedInput = {
    create?: XOR<Inscripcion_tutorCreateWithoutInscripcionInput, Inscripcion_tutorUncheckedCreateWithoutInscripcionInput> | Inscripcion_tutorCreateWithoutInscripcionInput[] | Inscripcion_tutorUncheckedCreateWithoutInscripcionInput[]
    connectOrCreate?: Inscripcion_tutorCreateOrConnectWithoutInscripcionInput | Inscripcion_tutorCreateOrConnectWithoutInscripcionInput[]
    upsert?: Inscripcion_tutorUpsertWithWhereUniqueWithoutInscripcionInput | Inscripcion_tutorUpsertWithWhereUniqueWithoutInscripcionInput[]
    createMany?: Inscripcion_tutorCreateManyInscripcionInputEnvelope
    set?: Inscripcion_tutorWhereUniqueInput | Inscripcion_tutorWhereUniqueInput[]
    disconnect?: Inscripcion_tutorWhereUniqueInput | Inscripcion_tutorWhereUniqueInput[]
    delete?: Inscripcion_tutorWhereUniqueInput | Inscripcion_tutorWhereUniqueInput[]
    connect?: Inscripcion_tutorWhereUniqueInput | Inscripcion_tutorWhereUniqueInput[]
    update?: Inscripcion_tutorUpdateWithWhereUniqueWithoutInscripcionInput | Inscripcion_tutorUpdateWithWhereUniqueWithoutInscripcionInput[]
    updateMany?: Inscripcion_tutorUpdateManyWithWhereWithoutInscripcionInput | Inscripcion_tutorUpdateManyWithWhereWithoutInscripcionInput[]
    deleteMany?: Inscripcion_tutorScalarWhereInput | Inscripcion_tutorScalarWhereInput[]
  }

  export type PagoUncheckedUpdateManyWithoutInscripcionNestedInput = {
    create?: XOR<PagoCreateWithoutInscripcionInput, PagoUncheckedCreateWithoutInscripcionInput> | PagoCreateWithoutInscripcionInput[] | PagoUncheckedCreateWithoutInscripcionInput[]
    connectOrCreate?: PagoCreateOrConnectWithoutInscripcionInput | PagoCreateOrConnectWithoutInscripcionInput[]
    upsert?: PagoUpsertWithWhereUniqueWithoutInscripcionInput | PagoUpsertWithWhereUniqueWithoutInscripcionInput[]
    createMany?: PagoCreateManyInscripcionInputEnvelope
    set?: PagoWhereUniqueInput | PagoWhereUniqueInput[]
    disconnect?: PagoWhereUniqueInput | PagoWhereUniqueInput[]
    delete?: PagoWhereUniqueInput | PagoWhereUniqueInput[]
    connect?: PagoWhereUniqueInput | PagoWhereUniqueInput[]
    update?: PagoUpdateWithWhereUniqueWithoutInscripcionInput | PagoUpdateWithWhereUniqueWithoutInscripcionInput[]
    updateMany?: PagoUpdateManyWithWhereWithoutInscripcionInput | PagoUpdateManyWithWhereWithoutInscripcionInput[]
    deleteMany?: PagoScalarWhereInput | PagoScalarWhereInput[]
  }

  export type GradoCreateNestedManyWithoutNivelInput = {
    create?: XOR<GradoCreateWithoutNivelInput, GradoUncheckedCreateWithoutNivelInput> | GradoCreateWithoutNivelInput[] | GradoUncheckedCreateWithoutNivelInput[]
    connectOrCreate?: GradoCreateOrConnectWithoutNivelInput | GradoCreateOrConnectWithoutNivelInput[]
    createMany?: GradoCreateManyNivelInputEnvelope
    connect?: GradoWhereUniqueInput | GradoWhereUniqueInput[]
  }

  export type GradoUncheckedCreateNestedManyWithoutNivelInput = {
    create?: XOR<GradoCreateWithoutNivelInput, GradoUncheckedCreateWithoutNivelInput> | GradoCreateWithoutNivelInput[] | GradoUncheckedCreateWithoutNivelInput[]
    connectOrCreate?: GradoCreateOrConnectWithoutNivelInput | GradoCreateOrConnectWithoutNivelInput[]
    createMany?: GradoCreateManyNivelInputEnvelope
    connect?: GradoWhereUniqueInput | GradoWhereUniqueInput[]
  }

  export type GradoUpdateManyWithoutNivelNestedInput = {
    create?: XOR<GradoCreateWithoutNivelInput, GradoUncheckedCreateWithoutNivelInput> | GradoCreateWithoutNivelInput[] | GradoUncheckedCreateWithoutNivelInput[]
    connectOrCreate?: GradoCreateOrConnectWithoutNivelInput | GradoCreateOrConnectWithoutNivelInput[]
    upsert?: GradoUpsertWithWhereUniqueWithoutNivelInput | GradoUpsertWithWhereUniqueWithoutNivelInput[]
    createMany?: GradoCreateManyNivelInputEnvelope
    set?: GradoWhereUniqueInput | GradoWhereUniqueInput[]
    disconnect?: GradoWhereUniqueInput | GradoWhereUniqueInput[]
    delete?: GradoWhereUniqueInput | GradoWhereUniqueInput[]
    connect?: GradoWhereUniqueInput | GradoWhereUniqueInput[]
    update?: GradoUpdateWithWhereUniqueWithoutNivelInput | GradoUpdateWithWhereUniqueWithoutNivelInput[]
    updateMany?: GradoUpdateManyWithWhereWithoutNivelInput | GradoUpdateManyWithWhereWithoutNivelInput[]
    deleteMany?: GradoScalarWhereInput | GradoScalarWhereInput[]
  }

  export type GradoUncheckedUpdateManyWithoutNivelNestedInput = {
    create?: XOR<GradoCreateWithoutNivelInput, GradoUncheckedCreateWithoutNivelInput> | GradoCreateWithoutNivelInput[] | GradoUncheckedCreateWithoutNivelInput[]
    connectOrCreate?: GradoCreateOrConnectWithoutNivelInput | GradoCreateOrConnectWithoutNivelInput[]
    upsert?: GradoUpsertWithWhereUniqueWithoutNivelInput | GradoUpsertWithWhereUniqueWithoutNivelInput[]
    createMany?: GradoCreateManyNivelInputEnvelope
    set?: GradoWhereUniqueInput | GradoWhereUniqueInput[]
    disconnect?: GradoWhereUniqueInput | GradoWhereUniqueInput[]
    delete?: GradoWhereUniqueInput | GradoWhereUniqueInput[]
    connect?: GradoWhereUniqueInput | GradoWhereUniqueInput[]
    update?: GradoUpdateWithWhereUniqueWithoutNivelInput | GradoUpdateWithWhereUniqueWithoutNivelInput[]
    updateMany?: GradoUpdateManyWithWhereWithoutNivelInput | GradoUpdateManyWithWhereWithoutNivelInput[]
    deleteMany?: GradoScalarWhereInput | GradoScalarWhereInput[]
  }

  export type UsuarioCreateNestedOneWithoutNotificacionInput = {
    create?: XOR<UsuarioCreateWithoutNotificacionInput, UsuarioUncheckedCreateWithoutNotificacionInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutNotificacionInput
    connect?: UsuarioWhereUniqueInput
  }

  export type UsuarioUpdateOneRequiredWithoutNotificacionNestedInput = {
    create?: XOR<UsuarioCreateWithoutNotificacionInput, UsuarioUncheckedCreateWithoutNotificacionInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutNotificacionInput
    upsert?: UsuarioUpsertWithoutNotificacionInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutNotificacionInput, UsuarioUpdateWithoutNotificacionInput>, UsuarioUncheckedUpdateWithoutNotificacionInput>
  }

  export type Inscripcion_tutorCreateNestedManyWithoutMotivoRechazoInput = {
    create?: XOR<Inscripcion_tutorCreateWithoutMotivoRechazoInput, Inscripcion_tutorUncheckedCreateWithoutMotivoRechazoInput> | Inscripcion_tutorCreateWithoutMotivoRechazoInput[] | Inscripcion_tutorUncheckedCreateWithoutMotivoRechazoInput[]
    connectOrCreate?: Inscripcion_tutorCreateOrConnectWithoutMotivoRechazoInput | Inscripcion_tutorCreateOrConnectWithoutMotivoRechazoInput[]
    createMany?: Inscripcion_tutorCreateManyMotivoRechazoInputEnvelope
    connect?: Inscripcion_tutorWhereUniqueInput | Inscripcion_tutorWhereUniqueInput[]
  }

  export type Inscripcion_tutorUncheckedCreateNestedManyWithoutMotivoRechazoInput = {
    create?: XOR<Inscripcion_tutorCreateWithoutMotivoRechazoInput, Inscripcion_tutorUncheckedCreateWithoutMotivoRechazoInput> | Inscripcion_tutorCreateWithoutMotivoRechazoInput[] | Inscripcion_tutorUncheckedCreateWithoutMotivoRechazoInput[]
    connectOrCreate?: Inscripcion_tutorCreateOrConnectWithoutMotivoRechazoInput | Inscripcion_tutorCreateOrConnectWithoutMotivoRechazoInput[]
    createMany?: Inscripcion_tutorCreateManyMotivoRechazoInputEnvelope
    connect?: Inscripcion_tutorWhereUniqueInput | Inscripcion_tutorWhereUniqueInput[]
  }

  export type Inscripcion_tutorUpdateManyWithoutMotivoRechazoNestedInput = {
    create?: XOR<Inscripcion_tutorCreateWithoutMotivoRechazoInput, Inscripcion_tutorUncheckedCreateWithoutMotivoRechazoInput> | Inscripcion_tutorCreateWithoutMotivoRechazoInput[] | Inscripcion_tutorUncheckedCreateWithoutMotivoRechazoInput[]
    connectOrCreate?: Inscripcion_tutorCreateOrConnectWithoutMotivoRechazoInput | Inscripcion_tutorCreateOrConnectWithoutMotivoRechazoInput[]
    upsert?: Inscripcion_tutorUpsertWithWhereUniqueWithoutMotivoRechazoInput | Inscripcion_tutorUpsertWithWhereUniqueWithoutMotivoRechazoInput[]
    createMany?: Inscripcion_tutorCreateManyMotivoRechazoInputEnvelope
    set?: Inscripcion_tutorWhereUniqueInput | Inscripcion_tutorWhereUniqueInput[]
    disconnect?: Inscripcion_tutorWhereUniqueInput | Inscripcion_tutorWhereUniqueInput[]
    delete?: Inscripcion_tutorWhereUniqueInput | Inscripcion_tutorWhereUniqueInput[]
    connect?: Inscripcion_tutorWhereUniqueInput | Inscripcion_tutorWhereUniqueInput[]
    update?: Inscripcion_tutorUpdateWithWhereUniqueWithoutMotivoRechazoInput | Inscripcion_tutorUpdateWithWhereUniqueWithoutMotivoRechazoInput[]
    updateMany?: Inscripcion_tutorUpdateManyWithWhereWithoutMotivoRechazoInput | Inscripcion_tutorUpdateManyWithWhereWithoutMotivoRechazoInput[]
    deleteMany?: Inscripcion_tutorScalarWhereInput | Inscripcion_tutorScalarWhereInput[]
  }

  export type Inscripcion_tutorUncheckedUpdateManyWithoutMotivoRechazoNestedInput = {
    create?: XOR<Inscripcion_tutorCreateWithoutMotivoRechazoInput, Inscripcion_tutorUncheckedCreateWithoutMotivoRechazoInput> | Inscripcion_tutorCreateWithoutMotivoRechazoInput[] | Inscripcion_tutorUncheckedCreateWithoutMotivoRechazoInput[]
    connectOrCreate?: Inscripcion_tutorCreateOrConnectWithoutMotivoRechazoInput | Inscripcion_tutorCreateOrConnectWithoutMotivoRechazoInput[]
    upsert?: Inscripcion_tutorUpsertWithWhereUniqueWithoutMotivoRechazoInput | Inscripcion_tutorUpsertWithWhereUniqueWithoutMotivoRechazoInput[]
    createMany?: Inscripcion_tutorCreateManyMotivoRechazoInputEnvelope
    set?: Inscripcion_tutorWhereUniqueInput | Inscripcion_tutorWhereUniqueInput[]
    disconnect?: Inscripcion_tutorWhereUniqueInput | Inscripcion_tutorWhereUniqueInput[]
    delete?: Inscripcion_tutorWhereUniqueInput | Inscripcion_tutorWhereUniqueInput[]
    connect?: Inscripcion_tutorWhereUniqueInput | Inscripcion_tutorWhereUniqueInput[]
    update?: Inscripcion_tutorUpdateWithWhereUniqueWithoutMotivoRechazoInput | Inscripcion_tutorUpdateWithWhereUniqueWithoutMotivoRechazoInput[]
    updateMany?: Inscripcion_tutorUpdateManyWithWhereWithoutMotivoRechazoInput | Inscripcion_tutorUpdateManyWithWhereWithoutMotivoRechazoInput[]
    deleteMany?: Inscripcion_tutorScalarWhereInput | Inscripcion_tutorScalarWhereInput[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type CompetidorCreateWithoutUsuarioInput = {
    id?: string
    carnet_identidad: string
    fecha_nacimiento: Date | string
    colegio: ColegioCreateNestedOneWithoutCompetidoresInput
    provincia: ProvinciaCreateNestedOneWithoutCompetidorInput
    Inscripciones?: Inscripcion_tutorCreateNestedManyWithoutCompetidorInput
    Inscripcion?: InscripcionCreateNestedManyWithoutCompetidorInput
  }

  export type CompetidorUncheckedCreateWithoutUsuarioInput = {
    id?: string
    colegio_id: number
    provincia_id: number
    carnet_identidad: string
    fecha_nacimiento: Date | string
    Inscripciones?: Inscripcion_tutorUncheckedCreateNestedManyWithoutCompetidorInput
    Inscripcion?: InscripcionUncheckedCreateNestedManyWithoutCompetidorInput
  }

  export type CompetidorCreateOrConnectWithoutUsuarioInput = {
    where: CompetidorWhereUniqueInput
    create: XOR<CompetidorCreateWithoutUsuarioInput, CompetidorUncheckedCreateWithoutUsuarioInput>
  }

  export type TutorCreateWithoutUsuarioInput = {
    id?: string
    carnet_identidad: string
    numero_celular: string
    Inscripciones_tutor?: Inscripcion_tutorCreateNestedManyWithoutTutorInput
    area: AreaCreateNestedOneWithoutTutorInput
  }

  export type TutorUncheckedCreateWithoutUsuarioInput = {
    id?: string
    carnet_identidad: string
    numero_celular: string
    area_id: number
    Inscripciones_tutor?: Inscripcion_tutorUncheckedCreateNestedManyWithoutTutorInput
  }

  export type TutorCreateOrConnectWithoutUsuarioInput = {
    where: TutorWhereUniqueInput
    create: XOR<TutorCreateWithoutUsuarioInput, TutorUncheckedCreateWithoutUsuarioInput>
  }

  export type RolCreateWithoutUsuariosInput = {
    nombre: string
    roles?: Rol_permisoCreateNestedManyWithoutRolInput
  }

  export type RolUncheckedCreateWithoutUsuariosInput = {
    id?: number
    nombre: string
    roles?: Rol_permisoUncheckedCreateNestedManyWithoutRolInput
  }

  export type RolCreateOrConnectWithoutUsuariosInput = {
    where: RolWhereUniqueInput
    create: XOR<RolCreateWithoutUsuariosInput, RolUncheckedCreateWithoutUsuariosInput>
  }

  export type NotificacionCreateWithoutUsuarioInput = {
    tipo: string
    mensaje: string
    leido?: boolean
    createdAt?: Date | string
  }

  export type NotificacionUncheckedCreateWithoutUsuarioInput = {
    id?: number
    tipo: string
    mensaje: string
    leido?: boolean
    createdAt?: Date | string
  }

  export type NotificacionCreateOrConnectWithoutUsuarioInput = {
    where: NotificacionWhereUniqueInput
    create: XOR<NotificacionCreateWithoutUsuarioInput, NotificacionUncheckedCreateWithoutUsuarioInput>
  }

  export type NotificacionCreateManyUsuarioInputEnvelope = {
    data: NotificacionCreateManyUsuarioInput | NotificacionCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type CompetidorUpsertWithoutUsuarioInput = {
    update: XOR<CompetidorUpdateWithoutUsuarioInput, CompetidorUncheckedUpdateWithoutUsuarioInput>
    create: XOR<CompetidorCreateWithoutUsuarioInput, CompetidorUncheckedCreateWithoutUsuarioInput>
    where?: CompetidorWhereInput
  }

  export type CompetidorUpdateToOneWithWhereWithoutUsuarioInput = {
    where?: CompetidorWhereInput
    data: XOR<CompetidorUpdateWithoutUsuarioInput, CompetidorUncheckedUpdateWithoutUsuarioInput>
  }

  export type CompetidorUpdateWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    carnet_identidad?: StringFieldUpdateOperationsInput | string
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    colegio?: ColegioUpdateOneRequiredWithoutCompetidoresNestedInput
    provincia?: ProvinciaUpdateOneRequiredWithoutCompetidorNestedInput
    Inscripciones?: Inscripcion_tutorUpdateManyWithoutCompetidorNestedInput
    Inscripcion?: InscripcionUpdateManyWithoutCompetidorNestedInput
  }

  export type CompetidorUncheckedUpdateWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    colegio_id?: IntFieldUpdateOperationsInput | number
    provincia_id?: IntFieldUpdateOperationsInput | number
    carnet_identidad?: StringFieldUpdateOperationsInput | string
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    Inscripciones?: Inscripcion_tutorUncheckedUpdateManyWithoutCompetidorNestedInput
    Inscripcion?: InscripcionUncheckedUpdateManyWithoutCompetidorNestedInput
  }

  export type TutorUpsertWithoutUsuarioInput = {
    update: XOR<TutorUpdateWithoutUsuarioInput, TutorUncheckedUpdateWithoutUsuarioInput>
    create: XOR<TutorCreateWithoutUsuarioInput, TutorUncheckedCreateWithoutUsuarioInput>
    where?: TutorWhereInput
  }

  export type TutorUpdateToOneWithWhereWithoutUsuarioInput = {
    where?: TutorWhereInput
    data: XOR<TutorUpdateWithoutUsuarioInput, TutorUncheckedUpdateWithoutUsuarioInput>
  }

  export type TutorUpdateWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    carnet_identidad?: StringFieldUpdateOperationsInput | string
    numero_celular?: StringFieldUpdateOperationsInput | string
    Inscripciones_tutor?: Inscripcion_tutorUpdateManyWithoutTutorNestedInput
    area?: AreaUpdateOneRequiredWithoutTutorNestedInput
  }

  export type TutorUncheckedUpdateWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    carnet_identidad?: StringFieldUpdateOperationsInput | string
    numero_celular?: StringFieldUpdateOperationsInput | string
    area_id?: IntFieldUpdateOperationsInput | number
    Inscripciones_tutor?: Inscripcion_tutorUncheckedUpdateManyWithoutTutorNestedInput
  }

  export type RolUpsertWithoutUsuariosInput = {
    update: XOR<RolUpdateWithoutUsuariosInput, RolUncheckedUpdateWithoutUsuariosInput>
    create: XOR<RolCreateWithoutUsuariosInput, RolUncheckedCreateWithoutUsuariosInput>
    where?: RolWhereInput
  }

  export type RolUpdateToOneWithWhereWithoutUsuariosInput = {
    where?: RolWhereInput
    data: XOR<RolUpdateWithoutUsuariosInput, RolUncheckedUpdateWithoutUsuariosInput>
  }

  export type RolUpdateWithoutUsuariosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    roles?: Rol_permisoUpdateManyWithoutRolNestedInput
  }

  export type RolUncheckedUpdateWithoutUsuariosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    roles?: Rol_permisoUncheckedUpdateManyWithoutRolNestedInput
  }

  export type NotificacionUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: NotificacionWhereUniqueInput
    update: XOR<NotificacionUpdateWithoutUsuarioInput, NotificacionUncheckedUpdateWithoutUsuarioInput>
    create: XOR<NotificacionCreateWithoutUsuarioInput, NotificacionUncheckedCreateWithoutUsuarioInput>
  }

  export type NotificacionUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: NotificacionWhereUniqueInput
    data: XOR<NotificacionUpdateWithoutUsuarioInput, NotificacionUncheckedUpdateWithoutUsuarioInput>
  }

  export type NotificacionUpdateManyWithWhereWithoutUsuarioInput = {
    where: NotificacionScalarWhereInput
    data: XOR<NotificacionUpdateManyMutationInput, NotificacionUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type NotificacionScalarWhereInput = {
    AND?: NotificacionScalarWhereInput | NotificacionScalarWhereInput[]
    OR?: NotificacionScalarWhereInput[]
    NOT?: NotificacionScalarWhereInput | NotificacionScalarWhereInput[]
    id?: IntFilter<"Notificacion"> | number
    usuarioId?: StringFilter<"Notificacion"> | string
    tipo?: StringFilter<"Notificacion"> | string
    mensaje?: StringFilter<"Notificacion"> | string
    leido?: BoolFilter<"Notificacion"> | boolean
    createdAt?: DateTimeFilter<"Notificacion"> | Date | string
  }

  export type Rol_permisoCreateWithoutRolInput = {
    permiso: PermisoCreateNestedOneWithoutRolesInput
  }

  export type Rol_permisoUncheckedCreateWithoutRolInput = {
    id?: number
    permiso_id: number
  }

  export type Rol_permisoCreateOrConnectWithoutRolInput = {
    where: Rol_permisoWhereUniqueInput
    create: XOR<Rol_permisoCreateWithoutRolInput, Rol_permisoUncheckedCreateWithoutRolInput>
  }

  export type Rol_permisoCreateManyRolInputEnvelope = {
    data: Rol_permisoCreateManyRolInput | Rol_permisoCreateManyRolInput[]
    skipDuplicates?: boolean
  }

  export type UsuarioCreateWithoutRoleInput = {
    id?: string
    correo_electronico: string
    nombre: string
    apellido: string
    estado?: boolean
    password: string
    createdAt?: Date | string
    competidor?: CompetidorCreateNestedOneWithoutUsuarioInput
    tutor?: TutorCreateNestedOneWithoutUsuarioInput
    Notificacion?: NotificacionCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutRoleInput = {
    id?: string
    correo_electronico: string
    nombre: string
    apellido: string
    estado?: boolean
    password: string
    createdAt?: Date | string
    competidor?: CompetidorUncheckedCreateNestedOneWithoutUsuarioInput
    tutor?: TutorUncheckedCreateNestedOneWithoutUsuarioInput
    Notificacion?: NotificacionUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutRoleInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutRoleInput, UsuarioUncheckedCreateWithoutRoleInput>
  }

  export type UsuarioCreateManyRoleInputEnvelope = {
    data: UsuarioCreateManyRoleInput | UsuarioCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type Rol_permisoUpsertWithWhereUniqueWithoutRolInput = {
    where: Rol_permisoWhereUniqueInput
    update: XOR<Rol_permisoUpdateWithoutRolInput, Rol_permisoUncheckedUpdateWithoutRolInput>
    create: XOR<Rol_permisoCreateWithoutRolInput, Rol_permisoUncheckedCreateWithoutRolInput>
  }

  export type Rol_permisoUpdateWithWhereUniqueWithoutRolInput = {
    where: Rol_permisoWhereUniqueInput
    data: XOR<Rol_permisoUpdateWithoutRolInput, Rol_permisoUncheckedUpdateWithoutRolInput>
  }

  export type Rol_permisoUpdateManyWithWhereWithoutRolInput = {
    where: Rol_permisoScalarWhereInput
    data: XOR<Rol_permisoUpdateManyMutationInput, Rol_permisoUncheckedUpdateManyWithoutRolInput>
  }

  export type Rol_permisoScalarWhereInput = {
    AND?: Rol_permisoScalarWhereInput | Rol_permisoScalarWhereInput[]
    OR?: Rol_permisoScalarWhereInput[]
    NOT?: Rol_permisoScalarWhereInput | Rol_permisoScalarWhereInput[]
    id?: IntFilter<"Rol_permiso"> | number
    rol_id?: IntFilter<"Rol_permiso"> | number
    permiso_id?: IntFilter<"Rol_permiso"> | number
  }

  export type UsuarioUpsertWithWhereUniqueWithoutRoleInput = {
    where: UsuarioWhereUniqueInput
    update: XOR<UsuarioUpdateWithoutRoleInput, UsuarioUncheckedUpdateWithoutRoleInput>
    create: XOR<UsuarioCreateWithoutRoleInput, UsuarioUncheckedCreateWithoutRoleInput>
  }

  export type UsuarioUpdateWithWhereUniqueWithoutRoleInput = {
    where: UsuarioWhereUniqueInput
    data: XOR<UsuarioUpdateWithoutRoleInput, UsuarioUncheckedUpdateWithoutRoleInput>
  }

  export type UsuarioUpdateManyWithWhereWithoutRoleInput = {
    where: UsuarioScalarWhereInput
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyWithoutRoleInput>
  }

  export type UsuarioScalarWhereInput = {
    AND?: UsuarioScalarWhereInput | UsuarioScalarWhereInput[]
    OR?: UsuarioScalarWhereInput[]
    NOT?: UsuarioScalarWhereInput | UsuarioScalarWhereInput[]
    id?: StringFilter<"Usuario"> | string
    correo_electronico?: StringFilter<"Usuario"> | string
    nombre?: StringFilter<"Usuario"> | string
    apellido?: StringFilter<"Usuario"> | string
    estado?: BoolFilter<"Usuario"> | boolean
    password?: StringFilter<"Usuario"> | string
    rol_id?: IntFilter<"Usuario"> | number
    createdAt?: DateTimeFilter<"Usuario"> | Date | string
  }

  export type Rol_permisoCreateWithoutPermisoInput = {
    rol: RolCreateNestedOneWithoutRolesInput
  }

  export type Rol_permisoUncheckedCreateWithoutPermisoInput = {
    id?: number
    rol_id: number
  }

  export type Rol_permisoCreateOrConnectWithoutPermisoInput = {
    where: Rol_permisoWhereUniqueInput
    create: XOR<Rol_permisoCreateWithoutPermisoInput, Rol_permisoUncheckedCreateWithoutPermisoInput>
  }

  export type Rol_permisoCreateManyPermisoInputEnvelope = {
    data: Rol_permisoCreateManyPermisoInput | Rol_permisoCreateManyPermisoInput[]
    skipDuplicates?: boolean
  }

  export type Rol_permisoUpsertWithWhereUniqueWithoutPermisoInput = {
    where: Rol_permisoWhereUniqueInput
    update: XOR<Rol_permisoUpdateWithoutPermisoInput, Rol_permisoUncheckedUpdateWithoutPermisoInput>
    create: XOR<Rol_permisoCreateWithoutPermisoInput, Rol_permisoUncheckedCreateWithoutPermisoInput>
  }

  export type Rol_permisoUpdateWithWhereUniqueWithoutPermisoInput = {
    where: Rol_permisoWhereUniqueInput
    data: XOR<Rol_permisoUpdateWithoutPermisoInput, Rol_permisoUncheckedUpdateWithoutPermisoInput>
  }

  export type Rol_permisoUpdateManyWithWhereWithoutPermisoInput = {
    where: Rol_permisoScalarWhereInput
    data: XOR<Rol_permisoUpdateManyMutationInput, Rol_permisoUncheckedUpdateManyWithoutPermisoInput>
  }

  export type PermisoCreateWithoutRolesInput = {
    nombre: string
    descripcion: string
  }

  export type PermisoUncheckedCreateWithoutRolesInput = {
    id?: number
    nombre: string
    descripcion: string
  }

  export type PermisoCreateOrConnectWithoutRolesInput = {
    where: PermisoWhereUniqueInput
    create: XOR<PermisoCreateWithoutRolesInput, PermisoUncheckedCreateWithoutRolesInput>
  }

  export type RolCreateWithoutRolesInput = {
    nombre: string
    usuarios?: UsuarioCreateNestedManyWithoutRoleInput
  }

  export type RolUncheckedCreateWithoutRolesInput = {
    id?: number
    nombre: string
    usuarios?: UsuarioUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RolCreateOrConnectWithoutRolesInput = {
    where: RolWhereUniqueInput
    create: XOR<RolCreateWithoutRolesInput, RolUncheckedCreateWithoutRolesInput>
  }

  export type PermisoUpsertWithoutRolesInput = {
    update: XOR<PermisoUpdateWithoutRolesInput, PermisoUncheckedUpdateWithoutRolesInput>
    create: XOR<PermisoCreateWithoutRolesInput, PermisoUncheckedCreateWithoutRolesInput>
    where?: PermisoWhereInput
  }

  export type PermisoUpdateToOneWithWhereWithoutRolesInput = {
    where?: PermisoWhereInput
    data: XOR<PermisoUpdateWithoutRolesInput, PermisoUncheckedUpdateWithoutRolesInput>
  }

  export type PermisoUpdateWithoutRolesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type PermisoUncheckedUpdateWithoutRolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type RolUpsertWithoutRolesInput = {
    update: XOR<RolUpdateWithoutRolesInput, RolUncheckedUpdateWithoutRolesInput>
    create: XOR<RolCreateWithoutRolesInput, RolUncheckedCreateWithoutRolesInput>
    where?: RolWhereInput
  }

  export type RolUpdateToOneWithWhereWithoutRolesInput = {
    where?: RolWhereInput
    data: XOR<RolUpdateWithoutRolesInput, RolUncheckedUpdateWithoutRolesInput>
  }

  export type RolUpdateWithoutRolesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    usuarios?: UsuarioUpdateManyWithoutRoleNestedInput
  }

  export type RolUncheckedUpdateWithoutRolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    usuarios?: UsuarioUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type ColegioCreateWithoutCompetidoresInput = {
    nombre_colegio: string
    provincia: ProvinciaCreateNestedOneWithoutColegioInput
  }

  export type ColegioUncheckedCreateWithoutCompetidoresInput = {
    id?: number
    nombre_colegio: string
    provincia_id: number
  }

  export type ColegioCreateOrConnectWithoutCompetidoresInput = {
    where: ColegioWhereUniqueInput
    create: XOR<ColegioCreateWithoutCompetidoresInput, ColegioUncheckedCreateWithoutCompetidoresInput>
  }

  export type ProvinciaCreateWithoutCompetidorInput = {
    nombre_provincia: string
    Colegio?: ColegioCreateNestedManyWithoutProvinciaInput
    departamento: DepartamentoCreateNestedOneWithoutProvinciaInput
  }

  export type ProvinciaUncheckedCreateWithoutCompetidorInput = {
    id?: number
    nombre_provincia: string
    departamento_id: number
    Colegio?: ColegioUncheckedCreateNestedManyWithoutProvinciaInput
  }

  export type ProvinciaCreateOrConnectWithoutCompetidorInput = {
    where: ProvinciaWhereUniqueInput
    create: XOR<ProvinciaCreateWithoutCompetidorInput, ProvinciaUncheckedCreateWithoutCompetidorInput>
  }

  export type UsuarioCreateWithoutCompetidorInput = {
    id?: string
    correo_electronico: string
    nombre: string
    apellido: string
    estado?: boolean
    password: string
    createdAt?: Date | string
    tutor?: TutorCreateNestedOneWithoutUsuarioInput
    role: RolCreateNestedOneWithoutUsuariosInput
    Notificacion?: NotificacionCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutCompetidorInput = {
    id?: string
    correo_electronico: string
    nombre: string
    apellido: string
    estado?: boolean
    password: string
    rol_id: number
    createdAt?: Date | string
    tutor?: TutorUncheckedCreateNestedOneWithoutUsuarioInput
    Notificacion?: NotificacionUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutCompetidorInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutCompetidorInput, UsuarioUncheckedCreateWithoutCompetidorInput>
  }

  export type Inscripcion_tutorCreateWithoutCompetidorInput = {
    aprobado?: boolean
    fecha_aprobacion?: Date | string | null
    descripcion_rechazo?: string | null
    inscripcion: InscripcionCreateNestedOneWithoutTutorInscripcionesInput
    tutor: TutorCreateNestedOneWithoutInscripciones_tutorInput
    MotivoRechazo?: Motivo_rechazoCreateNestedOneWithoutInscripcionesTutorInput
  }

  export type Inscripcion_tutorUncheckedCreateWithoutCompetidorInput = {
    id?: number
    inscripcion_id: number
    tutor_id: string
    aprobado?: boolean
    fecha_aprobacion?: Date | string | null
    motivo_rechazo_id?: number | null
    descripcion_rechazo?: string | null
  }

  export type Inscripcion_tutorCreateOrConnectWithoutCompetidorInput = {
    where: Inscripcion_tutorWhereUniqueInput
    create: XOR<Inscripcion_tutorCreateWithoutCompetidorInput, Inscripcion_tutorUncheckedCreateWithoutCompetidorInput>
  }

  export type Inscripcion_tutorCreateManyCompetidorInputEnvelope = {
    data: Inscripcion_tutorCreateManyCompetidorInput | Inscripcion_tutorCreateManyCompetidorInput[]
    skipDuplicates?: boolean
  }

  export type InscripcionCreateWithoutCompetidorInput = {
    fecha_inscripcion?: Date | string
    estado_inscripcion?: string
    tutorInscripciones?: Inscripcion_tutorCreateNestedManyWithoutInscripcionInput
    pagos?: PagoCreateNestedManyWithoutInscripcionInput
    area: AreaCreateNestedOneWithoutInscripcionInput
    convocatoria: ConvocatoriaCreateNestedOneWithoutInscripcionInput
    categoria: CategoriaCreateNestedOneWithoutInscripcionInput
  }

  export type InscripcionUncheckedCreateWithoutCompetidorInput = {
    id?: number
    area_id: number
    convocatoria_id: number
    categoria_id: number
    fecha_inscripcion?: Date | string
    estado_inscripcion?: string
    tutorInscripciones?: Inscripcion_tutorUncheckedCreateNestedManyWithoutInscripcionInput
    pagos?: PagoUncheckedCreateNestedManyWithoutInscripcionInput
  }

  export type InscripcionCreateOrConnectWithoutCompetidorInput = {
    where: InscripcionWhereUniqueInput
    create: XOR<InscripcionCreateWithoutCompetidorInput, InscripcionUncheckedCreateWithoutCompetidorInput>
  }

  export type InscripcionCreateManyCompetidorInputEnvelope = {
    data: InscripcionCreateManyCompetidorInput | InscripcionCreateManyCompetidorInput[]
    skipDuplicates?: boolean
  }

  export type ColegioUpsertWithoutCompetidoresInput = {
    update: XOR<ColegioUpdateWithoutCompetidoresInput, ColegioUncheckedUpdateWithoutCompetidoresInput>
    create: XOR<ColegioCreateWithoutCompetidoresInput, ColegioUncheckedCreateWithoutCompetidoresInput>
    where?: ColegioWhereInput
  }

  export type ColegioUpdateToOneWithWhereWithoutCompetidoresInput = {
    where?: ColegioWhereInput
    data: XOR<ColegioUpdateWithoutCompetidoresInput, ColegioUncheckedUpdateWithoutCompetidoresInput>
  }

  export type ColegioUpdateWithoutCompetidoresInput = {
    nombre_colegio?: StringFieldUpdateOperationsInput | string
    provincia?: ProvinciaUpdateOneRequiredWithoutColegioNestedInput
  }

  export type ColegioUncheckedUpdateWithoutCompetidoresInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre_colegio?: StringFieldUpdateOperationsInput | string
    provincia_id?: IntFieldUpdateOperationsInput | number
  }

  export type ProvinciaUpsertWithoutCompetidorInput = {
    update: XOR<ProvinciaUpdateWithoutCompetidorInput, ProvinciaUncheckedUpdateWithoutCompetidorInput>
    create: XOR<ProvinciaCreateWithoutCompetidorInput, ProvinciaUncheckedCreateWithoutCompetidorInput>
    where?: ProvinciaWhereInput
  }

  export type ProvinciaUpdateToOneWithWhereWithoutCompetidorInput = {
    where?: ProvinciaWhereInput
    data: XOR<ProvinciaUpdateWithoutCompetidorInput, ProvinciaUncheckedUpdateWithoutCompetidorInput>
  }

  export type ProvinciaUpdateWithoutCompetidorInput = {
    nombre_provincia?: StringFieldUpdateOperationsInput | string
    Colegio?: ColegioUpdateManyWithoutProvinciaNestedInput
    departamento?: DepartamentoUpdateOneRequiredWithoutProvinciaNestedInput
  }

  export type ProvinciaUncheckedUpdateWithoutCompetidorInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre_provincia?: StringFieldUpdateOperationsInput | string
    departamento_id?: IntFieldUpdateOperationsInput | number
    Colegio?: ColegioUncheckedUpdateManyWithoutProvinciaNestedInput
  }

  export type UsuarioUpsertWithoutCompetidorInput = {
    update: XOR<UsuarioUpdateWithoutCompetidorInput, UsuarioUncheckedUpdateWithoutCompetidorInput>
    create: XOR<UsuarioCreateWithoutCompetidorInput, UsuarioUncheckedCreateWithoutCompetidorInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutCompetidorInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutCompetidorInput, UsuarioUncheckedUpdateWithoutCompetidorInput>
  }

  export type UsuarioUpdateWithoutCompetidorInput = {
    id?: StringFieldUpdateOperationsInput | string
    correo_electronico?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tutor?: TutorUpdateOneWithoutUsuarioNestedInput
    role?: RolUpdateOneRequiredWithoutUsuariosNestedInput
    Notificacion?: NotificacionUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutCompetidorInput = {
    id?: StringFieldUpdateOperationsInput | string
    correo_electronico?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    rol_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tutor?: TutorUncheckedUpdateOneWithoutUsuarioNestedInput
    Notificacion?: NotificacionUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type Inscripcion_tutorUpsertWithWhereUniqueWithoutCompetidorInput = {
    where: Inscripcion_tutorWhereUniqueInput
    update: XOR<Inscripcion_tutorUpdateWithoutCompetidorInput, Inscripcion_tutorUncheckedUpdateWithoutCompetidorInput>
    create: XOR<Inscripcion_tutorCreateWithoutCompetidorInput, Inscripcion_tutorUncheckedCreateWithoutCompetidorInput>
  }

  export type Inscripcion_tutorUpdateWithWhereUniqueWithoutCompetidorInput = {
    where: Inscripcion_tutorWhereUniqueInput
    data: XOR<Inscripcion_tutorUpdateWithoutCompetidorInput, Inscripcion_tutorUncheckedUpdateWithoutCompetidorInput>
  }

  export type Inscripcion_tutorUpdateManyWithWhereWithoutCompetidorInput = {
    where: Inscripcion_tutorScalarWhereInput
    data: XOR<Inscripcion_tutorUpdateManyMutationInput, Inscripcion_tutorUncheckedUpdateManyWithoutCompetidorInput>
  }

  export type Inscripcion_tutorScalarWhereInput = {
    AND?: Inscripcion_tutorScalarWhereInput | Inscripcion_tutorScalarWhereInput[]
    OR?: Inscripcion_tutorScalarWhereInput[]
    NOT?: Inscripcion_tutorScalarWhereInput | Inscripcion_tutorScalarWhereInput[]
    id?: IntFilter<"Inscripcion_tutor"> | number
    inscripcion_id?: IntFilter<"Inscripcion_tutor"> | number
    tutor_id?: StringFilter<"Inscripcion_tutor"> | string
    aprobado?: BoolFilter<"Inscripcion_tutor"> | boolean
    fecha_aprobacion?: DateTimeNullableFilter<"Inscripcion_tutor"> | Date | string | null
    motivo_rechazo_id?: IntNullableFilter<"Inscripcion_tutor"> | number | null
    descripcion_rechazo?: StringNullableFilter<"Inscripcion_tutor"> | string | null
    competidorId?: StringNullableFilter<"Inscripcion_tutor"> | string | null
  }

  export type InscripcionUpsertWithWhereUniqueWithoutCompetidorInput = {
    where: InscripcionWhereUniqueInput
    update: XOR<InscripcionUpdateWithoutCompetidorInput, InscripcionUncheckedUpdateWithoutCompetidorInput>
    create: XOR<InscripcionCreateWithoutCompetidorInput, InscripcionUncheckedCreateWithoutCompetidorInput>
  }

  export type InscripcionUpdateWithWhereUniqueWithoutCompetidorInput = {
    where: InscripcionWhereUniqueInput
    data: XOR<InscripcionUpdateWithoutCompetidorInput, InscripcionUncheckedUpdateWithoutCompetidorInput>
  }

  export type InscripcionUpdateManyWithWhereWithoutCompetidorInput = {
    where: InscripcionScalarWhereInput
    data: XOR<InscripcionUpdateManyMutationInput, InscripcionUncheckedUpdateManyWithoutCompetidorInput>
  }

  export type InscripcionScalarWhereInput = {
    AND?: InscripcionScalarWhereInput | InscripcionScalarWhereInput[]
    OR?: InscripcionScalarWhereInput[]
    NOT?: InscripcionScalarWhereInput | InscripcionScalarWhereInput[]
    id?: IntFilter<"Inscripcion"> | number
    competidor_id?: StringFilter<"Inscripcion"> | string
    area_id?: IntFilter<"Inscripcion"> | number
    convocatoria_id?: IntFilter<"Inscripcion"> | number
    categoria_id?: IntFilter<"Inscripcion"> | number
    fecha_inscripcion?: DateTimeFilter<"Inscripcion"> | Date | string
    estado_inscripcion?: StringFilter<"Inscripcion"> | string
  }

  export type Inscripcion_tutorCreateWithoutTutorInput = {
    aprobado?: boolean
    fecha_aprobacion?: Date | string | null
    descripcion_rechazo?: string | null
    inscripcion: InscripcionCreateNestedOneWithoutTutorInscripcionesInput
    Competidor?: CompetidorCreateNestedOneWithoutInscripcionesInput
    MotivoRechazo?: Motivo_rechazoCreateNestedOneWithoutInscripcionesTutorInput
  }

  export type Inscripcion_tutorUncheckedCreateWithoutTutorInput = {
    id?: number
    inscripcion_id: number
    aprobado?: boolean
    fecha_aprobacion?: Date | string | null
    motivo_rechazo_id?: number | null
    descripcion_rechazo?: string | null
    competidorId?: string | null
  }

  export type Inscripcion_tutorCreateOrConnectWithoutTutorInput = {
    where: Inscripcion_tutorWhereUniqueInput
    create: XOR<Inscripcion_tutorCreateWithoutTutorInput, Inscripcion_tutorUncheckedCreateWithoutTutorInput>
  }

  export type Inscripcion_tutorCreateManyTutorInputEnvelope = {
    data: Inscripcion_tutorCreateManyTutorInput | Inscripcion_tutorCreateManyTutorInput[]
    skipDuplicates?: boolean
  }

  export type AreaCreateWithoutTutorInput = {
    nombre_area: string
    descripcion_area: string
    costo: Decimal | DecimalJsLike | number | string
    Area_convocatoria?: Area_convocatoriaCreateNestedManyWithoutAreaInput
    area_categoria?: Categoria_areaCreateNestedManyWithoutAreaInput
    Inscripcion?: InscripcionCreateNestedManyWithoutAreaInput
  }

  export type AreaUncheckedCreateWithoutTutorInput = {
    id?: number
    nombre_area: string
    descripcion_area: string
    costo: Decimal | DecimalJsLike | number | string
    Area_convocatoria?: Area_convocatoriaUncheckedCreateNestedManyWithoutAreaInput
    area_categoria?: Categoria_areaUncheckedCreateNestedManyWithoutAreaInput
    Inscripcion?: InscripcionUncheckedCreateNestedManyWithoutAreaInput
  }

  export type AreaCreateOrConnectWithoutTutorInput = {
    where: AreaWhereUniqueInput
    create: XOR<AreaCreateWithoutTutorInput, AreaUncheckedCreateWithoutTutorInput>
  }

  export type UsuarioCreateWithoutTutorInput = {
    id?: string
    correo_electronico: string
    nombre: string
    apellido: string
    estado?: boolean
    password: string
    createdAt?: Date | string
    competidor?: CompetidorCreateNestedOneWithoutUsuarioInput
    role: RolCreateNestedOneWithoutUsuariosInput
    Notificacion?: NotificacionCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutTutorInput = {
    id?: string
    correo_electronico: string
    nombre: string
    apellido: string
    estado?: boolean
    password: string
    rol_id: number
    createdAt?: Date | string
    competidor?: CompetidorUncheckedCreateNestedOneWithoutUsuarioInput
    Notificacion?: NotificacionUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutTutorInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutTutorInput, UsuarioUncheckedCreateWithoutTutorInput>
  }

  export type Inscripcion_tutorUpsertWithWhereUniqueWithoutTutorInput = {
    where: Inscripcion_tutorWhereUniqueInput
    update: XOR<Inscripcion_tutorUpdateWithoutTutorInput, Inscripcion_tutorUncheckedUpdateWithoutTutorInput>
    create: XOR<Inscripcion_tutorCreateWithoutTutorInput, Inscripcion_tutorUncheckedCreateWithoutTutorInput>
  }

  export type Inscripcion_tutorUpdateWithWhereUniqueWithoutTutorInput = {
    where: Inscripcion_tutorWhereUniqueInput
    data: XOR<Inscripcion_tutorUpdateWithoutTutorInput, Inscripcion_tutorUncheckedUpdateWithoutTutorInput>
  }

  export type Inscripcion_tutorUpdateManyWithWhereWithoutTutorInput = {
    where: Inscripcion_tutorScalarWhereInput
    data: XOR<Inscripcion_tutorUpdateManyMutationInput, Inscripcion_tutorUncheckedUpdateManyWithoutTutorInput>
  }

  export type AreaUpsertWithoutTutorInput = {
    update: XOR<AreaUpdateWithoutTutorInput, AreaUncheckedUpdateWithoutTutorInput>
    create: XOR<AreaCreateWithoutTutorInput, AreaUncheckedCreateWithoutTutorInput>
    where?: AreaWhereInput
  }

  export type AreaUpdateToOneWithWhereWithoutTutorInput = {
    where?: AreaWhereInput
    data: XOR<AreaUpdateWithoutTutorInput, AreaUncheckedUpdateWithoutTutorInput>
  }

  export type AreaUpdateWithoutTutorInput = {
    nombre_area?: StringFieldUpdateOperationsInput | string
    descripcion_area?: StringFieldUpdateOperationsInput | string
    costo?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Area_convocatoria?: Area_convocatoriaUpdateManyWithoutAreaNestedInput
    area_categoria?: Categoria_areaUpdateManyWithoutAreaNestedInput
    Inscripcion?: InscripcionUpdateManyWithoutAreaNestedInput
  }

  export type AreaUncheckedUpdateWithoutTutorInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre_area?: StringFieldUpdateOperationsInput | string
    descripcion_area?: StringFieldUpdateOperationsInput | string
    costo?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Area_convocatoria?: Area_convocatoriaUncheckedUpdateManyWithoutAreaNestedInput
    area_categoria?: Categoria_areaUncheckedUpdateManyWithoutAreaNestedInput
    Inscripcion?: InscripcionUncheckedUpdateManyWithoutAreaNestedInput
  }

  export type UsuarioUpsertWithoutTutorInput = {
    update: XOR<UsuarioUpdateWithoutTutorInput, UsuarioUncheckedUpdateWithoutTutorInput>
    create: XOR<UsuarioCreateWithoutTutorInput, UsuarioUncheckedCreateWithoutTutorInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutTutorInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutTutorInput, UsuarioUncheckedUpdateWithoutTutorInput>
  }

  export type UsuarioUpdateWithoutTutorInput = {
    id?: StringFieldUpdateOperationsInput | string
    correo_electronico?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    competidor?: CompetidorUpdateOneWithoutUsuarioNestedInput
    role?: RolUpdateOneRequiredWithoutUsuariosNestedInput
    Notificacion?: NotificacionUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutTutorInput = {
    id?: StringFieldUpdateOperationsInput | string
    correo_electronico?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    rol_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    competidor?: CompetidorUncheckedUpdateOneWithoutUsuarioNestedInput
    Notificacion?: NotificacionUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type ProvinciaCreateWithoutDepartamentoInput = {
    nombre_provincia: string
    Colegio?: ColegioCreateNestedManyWithoutProvinciaInput
    Competidor?: CompetidorCreateNestedManyWithoutProvinciaInput
  }

  export type ProvinciaUncheckedCreateWithoutDepartamentoInput = {
    id?: number
    nombre_provincia: string
    Colegio?: ColegioUncheckedCreateNestedManyWithoutProvinciaInput
    Competidor?: CompetidorUncheckedCreateNestedManyWithoutProvinciaInput
  }

  export type ProvinciaCreateOrConnectWithoutDepartamentoInput = {
    where: ProvinciaWhereUniqueInput
    create: XOR<ProvinciaCreateWithoutDepartamentoInput, ProvinciaUncheckedCreateWithoutDepartamentoInput>
  }

  export type ProvinciaCreateManyDepartamentoInputEnvelope = {
    data: ProvinciaCreateManyDepartamentoInput | ProvinciaCreateManyDepartamentoInput[]
    skipDuplicates?: boolean
  }

  export type ProvinciaUpsertWithWhereUniqueWithoutDepartamentoInput = {
    where: ProvinciaWhereUniqueInput
    update: XOR<ProvinciaUpdateWithoutDepartamentoInput, ProvinciaUncheckedUpdateWithoutDepartamentoInput>
    create: XOR<ProvinciaCreateWithoutDepartamentoInput, ProvinciaUncheckedCreateWithoutDepartamentoInput>
  }

  export type ProvinciaUpdateWithWhereUniqueWithoutDepartamentoInput = {
    where: ProvinciaWhereUniqueInput
    data: XOR<ProvinciaUpdateWithoutDepartamentoInput, ProvinciaUncheckedUpdateWithoutDepartamentoInput>
  }

  export type ProvinciaUpdateManyWithWhereWithoutDepartamentoInput = {
    where: ProvinciaScalarWhereInput
    data: XOR<ProvinciaUpdateManyMutationInput, ProvinciaUncheckedUpdateManyWithoutDepartamentoInput>
  }

  export type ProvinciaScalarWhereInput = {
    AND?: ProvinciaScalarWhereInput | ProvinciaScalarWhereInput[]
    OR?: ProvinciaScalarWhereInput[]
    NOT?: ProvinciaScalarWhereInput | ProvinciaScalarWhereInput[]
    id?: IntFilter<"Provincia"> | number
    nombre_provincia?: StringFilter<"Provincia"> | string
    departamento_id?: IntFilter<"Provincia"> | number
  }

  export type ColegioCreateWithoutProvinciaInput = {
    nombre_colegio: string
    Competidores?: CompetidorCreateNestedManyWithoutColegioInput
  }

  export type ColegioUncheckedCreateWithoutProvinciaInput = {
    id?: number
    nombre_colegio: string
    Competidores?: CompetidorUncheckedCreateNestedManyWithoutColegioInput
  }

  export type ColegioCreateOrConnectWithoutProvinciaInput = {
    where: ColegioWhereUniqueInput
    create: XOR<ColegioCreateWithoutProvinciaInput, ColegioUncheckedCreateWithoutProvinciaInput>
  }

  export type ColegioCreateManyProvinciaInputEnvelope = {
    data: ColegioCreateManyProvinciaInput | ColegioCreateManyProvinciaInput[]
    skipDuplicates?: boolean
  }

  export type CompetidorCreateWithoutProvinciaInput = {
    id?: string
    carnet_identidad: string
    fecha_nacimiento: Date | string
    colegio: ColegioCreateNestedOneWithoutCompetidoresInput
    usuario: UsuarioCreateNestedOneWithoutCompetidorInput
    Inscripciones?: Inscripcion_tutorCreateNestedManyWithoutCompetidorInput
    Inscripcion?: InscripcionCreateNestedManyWithoutCompetidorInput
  }

  export type CompetidorUncheckedCreateWithoutProvinciaInput = {
    id?: string
    usuario_id: string
    colegio_id: number
    carnet_identidad: string
    fecha_nacimiento: Date | string
    Inscripciones?: Inscripcion_tutorUncheckedCreateNestedManyWithoutCompetidorInput
    Inscripcion?: InscripcionUncheckedCreateNestedManyWithoutCompetidorInput
  }

  export type CompetidorCreateOrConnectWithoutProvinciaInput = {
    where: CompetidorWhereUniqueInput
    create: XOR<CompetidorCreateWithoutProvinciaInput, CompetidorUncheckedCreateWithoutProvinciaInput>
  }

  export type CompetidorCreateManyProvinciaInputEnvelope = {
    data: CompetidorCreateManyProvinciaInput | CompetidorCreateManyProvinciaInput[]
    skipDuplicates?: boolean
  }

  export type DepartamentoCreateWithoutProvinciaInput = {
    nombre_departamento: string
  }

  export type DepartamentoUncheckedCreateWithoutProvinciaInput = {
    id?: number
    nombre_departamento: string
  }

  export type DepartamentoCreateOrConnectWithoutProvinciaInput = {
    where: DepartamentoWhereUniqueInput
    create: XOR<DepartamentoCreateWithoutProvinciaInput, DepartamentoUncheckedCreateWithoutProvinciaInput>
  }

  export type ColegioUpsertWithWhereUniqueWithoutProvinciaInput = {
    where: ColegioWhereUniqueInput
    update: XOR<ColegioUpdateWithoutProvinciaInput, ColegioUncheckedUpdateWithoutProvinciaInput>
    create: XOR<ColegioCreateWithoutProvinciaInput, ColegioUncheckedCreateWithoutProvinciaInput>
  }

  export type ColegioUpdateWithWhereUniqueWithoutProvinciaInput = {
    where: ColegioWhereUniqueInput
    data: XOR<ColegioUpdateWithoutProvinciaInput, ColegioUncheckedUpdateWithoutProvinciaInput>
  }

  export type ColegioUpdateManyWithWhereWithoutProvinciaInput = {
    where: ColegioScalarWhereInput
    data: XOR<ColegioUpdateManyMutationInput, ColegioUncheckedUpdateManyWithoutProvinciaInput>
  }

  export type ColegioScalarWhereInput = {
    AND?: ColegioScalarWhereInput | ColegioScalarWhereInput[]
    OR?: ColegioScalarWhereInput[]
    NOT?: ColegioScalarWhereInput | ColegioScalarWhereInput[]
    id?: IntFilter<"Colegio"> | number
    nombre_colegio?: StringFilter<"Colegio"> | string
    provincia_id?: IntFilter<"Colegio"> | number
  }

  export type CompetidorUpsertWithWhereUniqueWithoutProvinciaInput = {
    where: CompetidorWhereUniqueInput
    update: XOR<CompetidorUpdateWithoutProvinciaInput, CompetidorUncheckedUpdateWithoutProvinciaInput>
    create: XOR<CompetidorCreateWithoutProvinciaInput, CompetidorUncheckedCreateWithoutProvinciaInput>
  }

  export type CompetidorUpdateWithWhereUniqueWithoutProvinciaInput = {
    where: CompetidorWhereUniqueInput
    data: XOR<CompetidorUpdateWithoutProvinciaInput, CompetidorUncheckedUpdateWithoutProvinciaInput>
  }

  export type CompetidorUpdateManyWithWhereWithoutProvinciaInput = {
    where: CompetidorScalarWhereInput
    data: XOR<CompetidorUpdateManyMutationInput, CompetidorUncheckedUpdateManyWithoutProvinciaInput>
  }

  export type CompetidorScalarWhereInput = {
    AND?: CompetidorScalarWhereInput | CompetidorScalarWhereInput[]
    OR?: CompetidorScalarWhereInput[]
    NOT?: CompetidorScalarWhereInput | CompetidorScalarWhereInput[]
    id?: StringFilter<"Competidor"> | string
    usuario_id?: StringFilter<"Competidor"> | string
    colegio_id?: IntFilter<"Competidor"> | number
    provincia_id?: IntFilter<"Competidor"> | number
    carnet_identidad?: StringFilter<"Competidor"> | string
    fecha_nacimiento?: DateTimeFilter<"Competidor"> | Date | string
  }

  export type DepartamentoUpsertWithoutProvinciaInput = {
    update: XOR<DepartamentoUpdateWithoutProvinciaInput, DepartamentoUncheckedUpdateWithoutProvinciaInput>
    create: XOR<DepartamentoCreateWithoutProvinciaInput, DepartamentoUncheckedCreateWithoutProvinciaInput>
    where?: DepartamentoWhereInput
  }

  export type DepartamentoUpdateToOneWithWhereWithoutProvinciaInput = {
    where?: DepartamentoWhereInput
    data: XOR<DepartamentoUpdateWithoutProvinciaInput, DepartamentoUncheckedUpdateWithoutProvinciaInput>
  }

  export type DepartamentoUpdateWithoutProvinciaInput = {
    nombre_departamento?: StringFieldUpdateOperationsInput | string
  }

  export type DepartamentoUncheckedUpdateWithoutProvinciaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre_departamento?: StringFieldUpdateOperationsInput | string
  }

  export type ProvinciaCreateWithoutColegioInput = {
    nombre_provincia: string
    Competidor?: CompetidorCreateNestedManyWithoutProvinciaInput
    departamento: DepartamentoCreateNestedOneWithoutProvinciaInput
  }

  export type ProvinciaUncheckedCreateWithoutColegioInput = {
    id?: number
    nombre_provincia: string
    departamento_id: number
    Competidor?: CompetidorUncheckedCreateNestedManyWithoutProvinciaInput
  }

  export type ProvinciaCreateOrConnectWithoutColegioInput = {
    where: ProvinciaWhereUniqueInput
    create: XOR<ProvinciaCreateWithoutColegioInput, ProvinciaUncheckedCreateWithoutColegioInput>
  }

  export type CompetidorCreateWithoutColegioInput = {
    id?: string
    carnet_identidad: string
    fecha_nacimiento: Date | string
    provincia: ProvinciaCreateNestedOneWithoutCompetidorInput
    usuario: UsuarioCreateNestedOneWithoutCompetidorInput
    Inscripciones?: Inscripcion_tutorCreateNestedManyWithoutCompetidorInput
    Inscripcion?: InscripcionCreateNestedManyWithoutCompetidorInput
  }

  export type CompetidorUncheckedCreateWithoutColegioInput = {
    id?: string
    usuario_id: string
    provincia_id: number
    carnet_identidad: string
    fecha_nacimiento: Date | string
    Inscripciones?: Inscripcion_tutorUncheckedCreateNestedManyWithoutCompetidorInput
    Inscripcion?: InscripcionUncheckedCreateNestedManyWithoutCompetidorInput
  }

  export type CompetidorCreateOrConnectWithoutColegioInput = {
    where: CompetidorWhereUniqueInput
    create: XOR<CompetidorCreateWithoutColegioInput, CompetidorUncheckedCreateWithoutColegioInput>
  }

  export type CompetidorCreateManyColegioInputEnvelope = {
    data: CompetidorCreateManyColegioInput | CompetidorCreateManyColegioInput[]
    skipDuplicates?: boolean
  }

  export type ProvinciaUpsertWithoutColegioInput = {
    update: XOR<ProvinciaUpdateWithoutColegioInput, ProvinciaUncheckedUpdateWithoutColegioInput>
    create: XOR<ProvinciaCreateWithoutColegioInput, ProvinciaUncheckedCreateWithoutColegioInput>
    where?: ProvinciaWhereInput
  }

  export type ProvinciaUpdateToOneWithWhereWithoutColegioInput = {
    where?: ProvinciaWhereInput
    data: XOR<ProvinciaUpdateWithoutColegioInput, ProvinciaUncheckedUpdateWithoutColegioInput>
  }

  export type ProvinciaUpdateWithoutColegioInput = {
    nombre_provincia?: StringFieldUpdateOperationsInput | string
    Competidor?: CompetidorUpdateManyWithoutProvinciaNestedInput
    departamento?: DepartamentoUpdateOneRequiredWithoutProvinciaNestedInput
  }

  export type ProvinciaUncheckedUpdateWithoutColegioInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre_provincia?: StringFieldUpdateOperationsInput | string
    departamento_id?: IntFieldUpdateOperationsInput | number
    Competidor?: CompetidorUncheckedUpdateManyWithoutProvinciaNestedInput
  }

  export type CompetidorUpsertWithWhereUniqueWithoutColegioInput = {
    where: CompetidorWhereUniqueInput
    update: XOR<CompetidorUpdateWithoutColegioInput, CompetidorUncheckedUpdateWithoutColegioInput>
    create: XOR<CompetidorCreateWithoutColegioInput, CompetidorUncheckedCreateWithoutColegioInput>
  }

  export type CompetidorUpdateWithWhereUniqueWithoutColegioInput = {
    where: CompetidorWhereUniqueInput
    data: XOR<CompetidorUpdateWithoutColegioInput, CompetidorUncheckedUpdateWithoutColegioInput>
  }

  export type CompetidorUpdateManyWithWhereWithoutColegioInput = {
    where: CompetidorScalarWhereInput
    data: XOR<CompetidorUpdateManyMutationInput, CompetidorUncheckedUpdateManyWithoutColegioInput>
  }

  export type Area_convocatoriaCreateWithoutConvocatoriaInput = {
    area: AreaCreateNestedOneWithoutArea_convocatoriaInput
  }

  export type Area_convocatoriaUncheckedCreateWithoutConvocatoriaInput = {
    id?: number
    area_id: number
  }

  export type Area_convocatoriaCreateOrConnectWithoutConvocatoriaInput = {
    where: Area_convocatoriaWhereUniqueInput
    create: XOR<Area_convocatoriaCreateWithoutConvocatoriaInput, Area_convocatoriaUncheckedCreateWithoutConvocatoriaInput>
  }

  export type Area_convocatoriaCreateManyConvocatoriaInputEnvelope = {
    data: Area_convocatoriaCreateManyConvocatoriaInput | Area_convocatoriaCreateManyConvocatoriaInput[]
    skipDuplicates?: boolean
  }

  export type estado_convocatoriaCreateWithoutConvocatoriaInput = {
    nombre: string
  }

  export type estado_convocatoriaUncheckedCreateWithoutConvocatoriaInput = {
    id?: number
    nombre: string
  }

  export type estado_convocatoriaCreateOrConnectWithoutConvocatoriaInput = {
    where: estado_convocatoriaWhereUniqueInput
    create: XOR<estado_convocatoriaCreateWithoutConvocatoriaInput, estado_convocatoriaUncheckedCreateWithoutConvocatoriaInput>
  }

  export type InscripcionCreateWithoutConvocatoriaInput = {
    fecha_inscripcion?: Date | string
    estado_inscripcion?: string
    tutorInscripciones?: Inscripcion_tutorCreateNestedManyWithoutInscripcionInput
    pagos?: PagoCreateNestedManyWithoutInscripcionInput
    competidor: CompetidorCreateNestedOneWithoutInscripcionInput
    area: AreaCreateNestedOneWithoutInscripcionInput
    categoria: CategoriaCreateNestedOneWithoutInscripcionInput
  }

  export type InscripcionUncheckedCreateWithoutConvocatoriaInput = {
    id?: number
    competidor_id: string
    area_id: number
    categoria_id: number
    fecha_inscripcion?: Date | string
    estado_inscripcion?: string
    tutorInscripciones?: Inscripcion_tutorUncheckedCreateNestedManyWithoutInscripcionInput
    pagos?: PagoUncheckedCreateNestedManyWithoutInscripcionInput
  }

  export type InscripcionCreateOrConnectWithoutConvocatoriaInput = {
    where: InscripcionWhereUniqueInput
    create: XOR<InscripcionCreateWithoutConvocatoriaInput, InscripcionUncheckedCreateWithoutConvocatoriaInput>
  }

  export type InscripcionCreateManyConvocatoriaInputEnvelope = {
    data: InscripcionCreateManyConvocatoriaInput | InscripcionCreateManyConvocatoriaInput[]
    skipDuplicates?: boolean
  }

  export type Area_convocatoriaUpsertWithWhereUniqueWithoutConvocatoriaInput = {
    where: Area_convocatoriaWhereUniqueInput
    update: XOR<Area_convocatoriaUpdateWithoutConvocatoriaInput, Area_convocatoriaUncheckedUpdateWithoutConvocatoriaInput>
    create: XOR<Area_convocatoriaCreateWithoutConvocatoriaInput, Area_convocatoriaUncheckedCreateWithoutConvocatoriaInput>
  }

  export type Area_convocatoriaUpdateWithWhereUniqueWithoutConvocatoriaInput = {
    where: Area_convocatoriaWhereUniqueInput
    data: XOR<Area_convocatoriaUpdateWithoutConvocatoriaInput, Area_convocatoriaUncheckedUpdateWithoutConvocatoriaInput>
  }

  export type Area_convocatoriaUpdateManyWithWhereWithoutConvocatoriaInput = {
    where: Area_convocatoriaScalarWhereInput
    data: XOR<Area_convocatoriaUpdateManyMutationInput, Area_convocatoriaUncheckedUpdateManyWithoutConvocatoriaInput>
  }

  export type Area_convocatoriaScalarWhereInput = {
    AND?: Area_convocatoriaScalarWhereInput | Area_convocatoriaScalarWhereInput[]
    OR?: Area_convocatoriaScalarWhereInput[]
    NOT?: Area_convocatoriaScalarWhereInput | Area_convocatoriaScalarWhereInput[]
    id?: IntFilter<"Area_convocatoria"> | number
    area_id?: IntFilter<"Area_convocatoria"> | number
    convocatoria_id?: IntFilter<"Area_convocatoria"> | number
  }

  export type estado_convocatoriaUpsertWithoutConvocatoriaInput = {
    update: XOR<estado_convocatoriaUpdateWithoutConvocatoriaInput, estado_convocatoriaUncheckedUpdateWithoutConvocatoriaInput>
    create: XOR<estado_convocatoriaCreateWithoutConvocatoriaInput, estado_convocatoriaUncheckedCreateWithoutConvocatoriaInput>
    where?: estado_convocatoriaWhereInput
  }

  export type estado_convocatoriaUpdateToOneWithWhereWithoutConvocatoriaInput = {
    where?: estado_convocatoriaWhereInput
    data: XOR<estado_convocatoriaUpdateWithoutConvocatoriaInput, estado_convocatoriaUncheckedUpdateWithoutConvocatoriaInput>
  }

  export type estado_convocatoriaUpdateWithoutConvocatoriaInput = {
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type estado_convocatoriaUncheckedUpdateWithoutConvocatoriaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type InscripcionUpsertWithWhereUniqueWithoutConvocatoriaInput = {
    where: InscripcionWhereUniqueInput
    update: XOR<InscripcionUpdateWithoutConvocatoriaInput, InscripcionUncheckedUpdateWithoutConvocatoriaInput>
    create: XOR<InscripcionCreateWithoutConvocatoriaInput, InscripcionUncheckedCreateWithoutConvocatoriaInput>
  }

  export type InscripcionUpdateWithWhereUniqueWithoutConvocatoriaInput = {
    where: InscripcionWhereUniqueInput
    data: XOR<InscripcionUpdateWithoutConvocatoriaInput, InscripcionUncheckedUpdateWithoutConvocatoriaInput>
  }

  export type InscripcionUpdateManyWithWhereWithoutConvocatoriaInput = {
    where: InscripcionScalarWhereInput
    data: XOR<InscripcionUpdateManyMutationInput, InscripcionUncheckedUpdateManyWithoutConvocatoriaInput>
  }

  export type Area_convocatoriaCreateWithoutAreaInput = {
    convocatoria: ConvocatoriaCreateNestedOneWithoutArea_convocatoriaInput
  }

  export type Area_convocatoriaUncheckedCreateWithoutAreaInput = {
    id?: number
    convocatoria_id: number
  }

  export type Area_convocatoriaCreateOrConnectWithoutAreaInput = {
    where: Area_convocatoriaWhereUniqueInput
    create: XOR<Area_convocatoriaCreateWithoutAreaInput, Area_convocatoriaUncheckedCreateWithoutAreaInput>
  }

  export type Area_convocatoriaCreateManyAreaInputEnvelope = {
    data: Area_convocatoriaCreateManyAreaInput | Area_convocatoriaCreateManyAreaInput[]
    skipDuplicates?: boolean
  }

  export type Categoria_areaCreateWithoutAreaInput = {
    categoria: CategoriaCreateNestedOneWithoutCategoria_convocatoriaInput
  }

  export type Categoria_areaUncheckedCreateWithoutAreaInput = {
    id?: number
    categoria_id: number
  }

  export type Categoria_areaCreateOrConnectWithoutAreaInput = {
    where: Categoria_areaWhereUniqueInput
    create: XOR<Categoria_areaCreateWithoutAreaInput, Categoria_areaUncheckedCreateWithoutAreaInput>
  }

  export type Categoria_areaCreateManyAreaInputEnvelope = {
    data: Categoria_areaCreateManyAreaInput | Categoria_areaCreateManyAreaInput[]
    skipDuplicates?: boolean
  }

  export type TutorCreateWithoutAreaInput = {
    id?: string
    carnet_identidad: string
    numero_celular: string
    Inscripciones_tutor?: Inscripcion_tutorCreateNestedManyWithoutTutorInput
    usuario: UsuarioCreateNestedOneWithoutTutorInput
  }

  export type TutorUncheckedCreateWithoutAreaInput = {
    id?: string
    usuario_id: string
    carnet_identidad: string
    numero_celular: string
    Inscripciones_tutor?: Inscripcion_tutorUncheckedCreateNestedManyWithoutTutorInput
  }

  export type TutorCreateOrConnectWithoutAreaInput = {
    where: TutorWhereUniqueInput
    create: XOR<TutorCreateWithoutAreaInput, TutorUncheckedCreateWithoutAreaInput>
  }

  export type TutorCreateManyAreaInputEnvelope = {
    data: TutorCreateManyAreaInput | TutorCreateManyAreaInput[]
    skipDuplicates?: boolean
  }

  export type InscripcionCreateWithoutAreaInput = {
    fecha_inscripcion?: Date | string
    estado_inscripcion?: string
    tutorInscripciones?: Inscripcion_tutorCreateNestedManyWithoutInscripcionInput
    pagos?: PagoCreateNestedManyWithoutInscripcionInput
    competidor: CompetidorCreateNestedOneWithoutInscripcionInput
    convocatoria: ConvocatoriaCreateNestedOneWithoutInscripcionInput
    categoria: CategoriaCreateNestedOneWithoutInscripcionInput
  }

  export type InscripcionUncheckedCreateWithoutAreaInput = {
    id?: number
    competidor_id: string
    convocatoria_id: number
    categoria_id: number
    fecha_inscripcion?: Date | string
    estado_inscripcion?: string
    tutorInscripciones?: Inscripcion_tutorUncheckedCreateNestedManyWithoutInscripcionInput
    pagos?: PagoUncheckedCreateNestedManyWithoutInscripcionInput
  }

  export type InscripcionCreateOrConnectWithoutAreaInput = {
    where: InscripcionWhereUniqueInput
    create: XOR<InscripcionCreateWithoutAreaInput, InscripcionUncheckedCreateWithoutAreaInput>
  }

  export type InscripcionCreateManyAreaInputEnvelope = {
    data: InscripcionCreateManyAreaInput | InscripcionCreateManyAreaInput[]
    skipDuplicates?: boolean
  }

  export type Area_convocatoriaUpsertWithWhereUniqueWithoutAreaInput = {
    where: Area_convocatoriaWhereUniqueInput
    update: XOR<Area_convocatoriaUpdateWithoutAreaInput, Area_convocatoriaUncheckedUpdateWithoutAreaInput>
    create: XOR<Area_convocatoriaCreateWithoutAreaInput, Area_convocatoriaUncheckedCreateWithoutAreaInput>
  }

  export type Area_convocatoriaUpdateWithWhereUniqueWithoutAreaInput = {
    where: Area_convocatoriaWhereUniqueInput
    data: XOR<Area_convocatoriaUpdateWithoutAreaInput, Area_convocatoriaUncheckedUpdateWithoutAreaInput>
  }

  export type Area_convocatoriaUpdateManyWithWhereWithoutAreaInput = {
    where: Area_convocatoriaScalarWhereInput
    data: XOR<Area_convocatoriaUpdateManyMutationInput, Area_convocatoriaUncheckedUpdateManyWithoutAreaInput>
  }

  export type Categoria_areaUpsertWithWhereUniqueWithoutAreaInput = {
    where: Categoria_areaWhereUniqueInput
    update: XOR<Categoria_areaUpdateWithoutAreaInput, Categoria_areaUncheckedUpdateWithoutAreaInput>
    create: XOR<Categoria_areaCreateWithoutAreaInput, Categoria_areaUncheckedCreateWithoutAreaInput>
  }

  export type Categoria_areaUpdateWithWhereUniqueWithoutAreaInput = {
    where: Categoria_areaWhereUniqueInput
    data: XOR<Categoria_areaUpdateWithoutAreaInput, Categoria_areaUncheckedUpdateWithoutAreaInput>
  }

  export type Categoria_areaUpdateManyWithWhereWithoutAreaInput = {
    where: Categoria_areaScalarWhereInput
    data: XOR<Categoria_areaUpdateManyMutationInput, Categoria_areaUncheckedUpdateManyWithoutAreaInput>
  }

  export type Categoria_areaScalarWhereInput = {
    AND?: Categoria_areaScalarWhereInput | Categoria_areaScalarWhereInput[]
    OR?: Categoria_areaScalarWhereInput[]
    NOT?: Categoria_areaScalarWhereInput | Categoria_areaScalarWhereInput[]
    id?: IntFilter<"Categoria_area"> | number
    categoria_id?: IntFilter<"Categoria_area"> | number
    area_id?: IntFilter<"Categoria_area"> | number
  }

  export type TutorUpsertWithWhereUniqueWithoutAreaInput = {
    where: TutorWhereUniqueInput
    update: XOR<TutorUpdateWithoutAreaInput, TutorUncheckedUpdateWithoutAreaInput>
    create: XOR<TutorCreateWithoutAreaInput, TutorUncheckedCreateWithoutAreaInput>
  }

  export type TutorUpdateWithWhereUniqueWithoutAreaInput = {
    where: TutorWhereUniqueInput
    data: XOR<TutorUpdateWithoutAreaInput, TutorUncheckedUpdateWithoutAreaInput>
  }

  export type TutorUpdateManyWithWhereWithoutAreaInput = {
    where: TutorScalarWhereInput
    data: XOR<TutorUpdateManyMutationInput, TutorUncheckedUpdateManyWithoutAreaInput>
  }

  export type TutorScalarWhereInput = {
    AND?: TutorScalarWhereInput | TutorScalarWhereInput[]
    OR?: TutorScalarWhereInput[]
    NOT?: TutorScalarWhereInput | TutorScalarWhereInput[]
    id?: StringFilter<"Tutor"> | string
    usuario_id?: StringFilter<"Tutor"> | string
    carnet_identidad?: StringFilter<"Tutor"> | string
    numero_celular?: StringFilter<"Tutor"> | string
    area_id?: IntFilter<"Tutor"> | number
  }

  export type InscripcionUpsertWithWhereUniqueWithoutAreaInput = {
    where: InscripcionWhereUniqueInput
    update: XOR<InscripcionUpdateWithoutAreaInput, InscripcionUncheckedUpdateWithoutAreaInput>
    create: XOR<InscripcionCreateWithoutAreaInput, InscripcionUncheckedCreateWithoutAreaInput>
  }

  export type InscripcionUpdateWithWhereUniqueWithoutAreaInput = {
    where: InscripcionWhereUniqueInput
    data: XOR<InscripcionUpdateWithoutAreaInput, InscripcionUncheckedUpdateWithoutAreaInput>
  }

  export type InscripcionUpdateManyWithWhereWithoutAreaInput = {
    where: InscripcionScalarWhereInput
    data: XOR<InscripcionUpdateManyMutationInput, InscripcionUncheckedUpdateManyWithoutAreaInput>
  }

  export type GradoCreateWithoutCategorias_maxInput = {
    nombre_grado: string
    categorias_min?: CategoriaCreateNestedManyWithoutGrado_minInput
    nivel: NivelCreateNestedOneWithoutGradoInput
  }

  export type GradoUncheckedCreateWithoutCategorias_maxInput = {
    id?: number
    nombre_grado: string
    id_nivel: number
    categorias_min?: CategoriaUncheckedCreateNestedManyWithoutGrado_minInput
  }

  export type GradoCreateOrConnectWithoutCategorias_maxInput = {
    where: GradoWhereUniqueInput
    create: XOR<GradoCreateWithoutCategorias_maxInput, GradoUncheckedCreateWithoutCategorias_maxInput>
  }

  export type GradoCreateWithoutCategorias_minInput = {
    nombre_grado: string
    categorias_max?: CategoriaCreateNestedManyWithoutGrado_maxInput
    nivel: NivelCreateNestedOneWithoutGradoInput
  }

  export type GradoUncheckedCreateWithoutCategorias_minInput = {
    id?: number
    nombre_grado: string
    id_nivel: number
    categorias_max?: CategoriaUncheckedCreateNestedManyWithoutGrado_maxInput
  }

  export type GradoCreateOrConnectWithoutCategorias_minInput = {
    where: GradoWhereUniqueInput
    create: XOR<GradoCreateWithoutCategorias_minInput, GradoUncheckedCreateWithoutCategorias_minInput>
  }

  export type Categoria_areaCreateWithoutCategoriaInput = {
    area: AreaCreateNestedOneWithoutArea_categoriaInput
  }

  export type Categoria_areaUncheckedCreateWithoutCategoriaInput = {
    id?: number
    area_id: number
  }

  export type Categoria_areaCreateOrConnectWithoutCategoriaInput = {
    where: Categoria_areaWhereUniqueInput
    create: XOR<Categoria_areaCreateWithoutCategoriaInput, Categoria_areaUncheckedCreateWithoutCategoriaInput>
  }

  export type Categoria_areaCreateManyCategoriaInputEnvelope = {
    data: Categoria_areaCreateManyCategoriaInput | Categoria_areaCreateManyCategoriaInput[]
    skipDuplicates?: boolean
  }

  export type InscripcionCreateWithoutCategoriaInput = {
    fecha_inscripcion?: Date | string
    estado_inscripcion?: string
    tutorInscripciones?: Inscripcion_tutorCreateNestedManyWithoutInscripcionInput
    pagos?: PagoCreateNestedManyWithoutInscripcionInput
    competidor: CompetidorCreateNestedOneWithoutInscripcionInput
    area: AreaCreateNestedOneWithoutInscripcionInput
    convocatoria: ConvocatoriaCreateNestedOneWithoutInscripcionInput
  }

  export type InscripcionUncheckedCreateWithoutCategoriaInput = {
    id?: number
    competidor_id: string
    area_id: number
    convocatoria_id: number
    fecha_inscripcion?: Date | string
    estado_inscripcion?: string
    tutorInscripciones?: Inscripcion_tutorUncheckedCreateNestedManyWithoutInscripcionInput
    pagos?: PagoUncheckedCreateNestedManyWithoutInscripcionInput
  }

  export type InscripcionCreateOrConnectWithoutCategoriaInput = {
    where: InscripcionWhereUniqueInput
    create: XOR<InscripcionCreateWithoutCategoriaInput, InscripcionUncheckedCreateWithoutCategoriaInput>
  }

  export type InscripcionCreateManyCategoriaInputEnvelope = {
    data: InscripcionCreateManyCategoriaInput | InscripcionCreateManyCategoriaInput[]
    skipDuplicates?: boolean
  }

  export type GradoUpsertWithoutCategorias_maxInput = {
    update: XOR<GradoUpdateWithoutCategorias_maxInput, GradoUncheckedUpdateWithoutCategorias_maxInput>
    create: XOR<GradoCreateWithoutCategorias_maxInput, GradoUncheckedCreateWithoutCategorias_maxInput>
    where?: GradoWhereInput
  }

  export type GradoUpdateToOneWithWhereWithoutCategorias_maxInput = {
    where?: GradoWhereInput
    data: XOR<GradoUpdateWithoutCategorias_maxInput, GradoUncheckedUpdateWithoutCategorias_maxInput>
  }

  export type GradoUpdateWithoutCategorias_maxInput = {
    nombre_grado?: StringFieldUpdateOperationsInput | string
    categorias_min?: CategoriaUpdateManyWithoutGrado_minNestedInput
    nivel?: NivelUpdateOneRequiredWithoutGradoNestedInput
  }

  export type GradoUncheckedUpdateWithoutCategorias_maxInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre_grado?: StringFieldUpdateOperationsInput | string
    id_nivel?: IntFieldUpdateOperationsInput | number
    categorias_min?: CategoriaUncheckedUpdateManyWithoutGrado_minNestedInput
  }

  export type GradoUpsertWithoutCategorias_minInput = {
    update: XOR<GradoUpdateWithoutCategorias_minInput, GradoUncheckedUpdateWithoutCategorias_minInput>
    create: XOR<GradoCreateWithoutCategorias_minInput, GradoUncheckedCreateWithoutCategorias_minInput>
    where?: GradoWhereInput
  }

  export type GradoUpdateToOneWithWhereWithoutCategorias_minInput = {
    where?: GradoWhereInput
    data: XOR<GradoUpdateWithoutCategorias_minInput, GradoUncheckedUpdateWithoutCategorias_minInput>
  }

  export type GradoUpdateWithoutCategorias_minInput = {
    nombre_grado?: StringFieldUpdateOperationsInput | string
    categorias_max?: CategoriaUpdateManyWithoutGrado_maxNestedInput
    nivel?: NivelUpdateOneRequiredWithoutGradoNestedInput
  }

  export type GradoUncheckedUpdateWithoutCategorias_minInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre_grado?: StringFieldUpdateOperationsInput | string
    id_nivel?: IntFieldUpdateOperationsInput | number
    categorias_max?: CategoriaUncheckedUpdateManyWithoutGrado_maxNestedInput
  }

  export type Categoria_areaUpsertWithWhereUniqueWithoutCategoriaInput = {
    where: Categoria_areaWhereUniqueInput
    update: XOR<Categoria_areaUpdateWithoutCategoriaInput, Categoria_areaUncheckedUpdateWithoutCategoriaInput>
    create: XOR<Categoria_areaCreateWithoutCategoriaInput, Categoria_areaUncheckedCreateWithoutCategoriaInput>
  }

  export type Categoria_areaUpdateWithWhereUniqueWithoutCategoriaInput = {
    where: Categoria_areaWhereUniqueInput
    data: XOR<Categoria_areaUpdateWithoutCategoriaInput, Categoria_areaUncheckedUpdateWithoutCategoriaInput>
  }

  export type Categoria_areaUpdateManyWithWhereWithoutCategoriaInput = {
    where: Categoria_areaScalarWhereInput
    data: XOR<Categoria_areaUpdateManyMutationInput, Categoria_areaUncheckedUpdateManyWithoutCategoriaInput>
  }

  export type InscripcionUpsertWithWhereUniqueWithoutCategoriaInput = {
    where: InscripcionWhereUniqueInput
    update: XOR<InscripcionUpdateWithoutCategoriaInput, InscripcionUncheckedUpdateWithoutCategoriaInput>
    create: XOR<InscripcionCreateWithoutCategoriaInput, InscripcionUncheckedCreateWithoutCategoriaInput>
  }

  export type InscripcionUpdateWithWhereUniqueWithoutCategoriaInput = {
    where: InscripcionWhereUniqueInput
    data: XOR<InscripcionUpdateWithoutCategoriaInput, InscripcionUncheckedUpdateWithoutCategoriaInput>
  }

  export type InscripcionUpdateManyWithWhereWithoutCategoriaInput = {
    where: InscripcionScalarWhereInput
    data: XOR<InscripcionUpdateManyMutationInput, InscripcionUncheckedUpdateManyWithoutCategoriaInput>
  }

  export type CategoriaCreateWithoutGrado_maxInput = {
    nombre_categoria: string
    descripcion_cat: string
    grado_min: GradoCreateNestedOneWithoutCategorias_minInput
    Categoria_convocatoria?: Categoria_areaCreateNestedManyWithoutCategoriaInput
    Inscripcion?: InscripcionCreateNestedManyWithoutCategoriaInput
  }

  export type CategoriaUncheckedCreateWithoutGrado_maxInput = {
    id?: number
    nombre_categoria: string
    grado_min_id: number
    descripcion_cat: string
    Categoria_convocatoria?: Categoria_areaUncheckedCreateNestedManyWithoutCategoriaInput
    Inscripcion?: InscripcionUncheckedCreateNestedManyWithoutCategoriaInput
  }

  export type CategoriaCreateOrConnectWithoutGrado_maxInput = {
    where: CategoriaWhereUniqueInput
    create: XOR<CategoriaCreateWithoutGrado_maxInput, CategoriaUncheckedCreateWithoutGrado_maxInput>
  }

  export type CategoriaCreateManyGrado_maxInputEnvelope = {
    data: CategoriaCreateManyGrado_maxInput | CategoriaCreateManyGrado_maxInput[]
    skipDuplicates?: boolean
  }

  export type CategoriaCreateWithoutGrado_minInput = {
    nombre_categoria: string
    descripcion_cat: string
    grado_max: GradoCreateNestedOneWithoutCategorias_maxInput
    Categoria_convocatoria?: Categoria_areaCreateNestedManyWithoutCategoriaInput
    Inscripcion?: InscripcionCreateNestedManyWithoutCategoriaInput
  }

  export type CategoriaUncheckedCreateWithoutGrado_minInput = {
    id?: number
    nombre_categoria: string
    grado_max_id: number
    descripcion_cat: string
    Categoria_convocatoria?: Categoria_areaUncheckedCreateNestedManyWithoutCategoriaInput
    Inscripcion?: InscripcionUncheckedCreateNestedManyWithoutCategoriaInput
  }

  export type CategoriaCreateOrConnectWithoutGrado_minInput = {
    where: CategoriaWhereUniqueInput
    create: XOR<CategoriaCreateWithoutGrado_minInput, CategoriaUncheckedCreateWithoutGrado_minInput>
  }

  export type CategoriaCreateManyGrado_minInputEnvelope = {
    data: CategoriaCreateManyGrado_minInput | CategoriaCreateManyGrado_minInput[]
    skipDuplicates?: boolean
  }

  export type NivelCreateWithoutGradoInput = {
    nombre_nivel: string
  }

  export type NivelUncheckedCreateWithoutGradoInput = {
    id?: number
    nombre_nivel: string
  }

  export type NivelCreateOrConnectWithoutGradoInput = {
    where: NivelWhereUniqueInput
    create: XOR<NivelCreateWithoutGradoInput, NivelUncheckedCreateWithoutGradoInput>
  }

  export type CategoriaUpsertWithWhereUniqueWithoutGrado_maxInput = {
    where: CategoriaWhereUniqueInput
    update: XOR<CategoriaUpdateWithoutGrado_maxInput, CategoriaUncheckedUpdateWithoutGrado_maxInput>
    create: XOR<CategoriaCreateWithoutGrado_maxInput, CategoriaUncheckedCreateWithoutGrado_maxInput>
  }

  export type CategoriaUpdateWithWhereUniqueWithoutGrado_maxInput = {
    where: CategoriaWhereUniqueInput
    data: XOR<CategoriaUpdateWithoutGrado_maxInput, CategoriaUncheckedUpdateWithoutGrado_maxInput>
  }

  export type CategoriaUpdateManyWithWhereWithoutGrado_maxInput = {
    where: CategoriaScalarWhereInput
    data: XOR<CategoriaUpdateManyMutationInput, CategoriaUncheckedUpdateManyWithoutGrado_maxInput>
  }

  export type CategoriaScalarWhereInput = {
    AND?: CategoriaScalarWhereInput | CategoriaScalarWhereInput[]
    OR?: CategoriaScalarWhereInput[]
    NOT?: CategoriaScalarWhereInput | CategoriaScalarWhereInput[]
    id?: IntFilter<"Categoria"> | number
    nombre_categoria?: StringFilter<"Categoria"> | string
    grado_min_id?: IntFilter<"Categoria"> | number
    grado_max_id?: IntFilter<"Categoria"> | number
    descripcion_cat?: StringFilter<"Categoria"> | string
  }

  export type CategoriaUpsertWithWhereUniqueWithoutGrado_minInput = {
    where: CategoriaWhereUniqueInput
    update: XOR<CategoriaUpdateWithoutGrado_minInput, CategoriaUncheckedUpdateWithoutGrado_minInput>
    create: XOR<CategoriaCreateWithoutGrado_minInput, CategoriaUncheckedCreateWithoutGrado_minInput>
  }

  export type CategoriaUpdateWithWhereUniqueWithoutGrado_minInput = {
    where: CategoriaWhereUniqueInput
    data: XOR<CategoriaUpdateWithoutGrado_minInput, CategoriaUncheckedUpdateWithoutGrado_minInput>
  }

  export type CategoriaUpdateManyWithWhereWithoutGrado_minInput = {
    where: CategoriaScalarWhereInput
    data: XOR<CategoriaUpdateManyMutationInput, CategoriaUncheckedUpdateManyWithoutGrado_minInput>
  }

  export type NivelUpsertWithoutGradoInput = {
    update: XOR<NivelUpdateWithoutGradoInput, NivelUncheckedUpdateWithoutGradoInput>
    create: XOR<NivelCreateWithoutGradoInput, NivelUncheckedCreateWithoutGradoInput>
    where?: NivelWhereInput
  }

  export type NivelUpdateToOneWithWhereWithoutGradoInput = {
    where?: NivelWhereInput
    data: XOR<NivelUpdateWithoutGradoInput, NivelUncheckedUpdateWithoutGradoInput>
  }

  export type NivelUpdateWithoutGradoInput = {
    nombre_nivel?: StringFieldUpdateOperationsInput | string
  }

  export type NivelUncheckedUpdateWithoutGradoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre_nivel?: StringFieldUpdateOperationsInput | string
  }

  export type InscripcionCreateWithoutPagosInput = {
    fecha_inscripcion?: Date | string
    estado_inscripcion?: string
    tutorInscripciones?: Inscripcion_tutorCreateNestedManyWithoutInscripcionInput
    competidor: CompetidorCreateNestedOneWithoutInscripcionInput
    area: AreaCreateNestedOneWithoutInscripcionInput
    convocatoria: ConvocatoriaCreateNestedOneWithoutInscripcionInput
    categoria: CategoriaCreateNestedOneWithoutInscripcionInput
  }

  export type InscripcionUncheckedCreateWithoutPagosInput = {
    id?: number
    competidor_id: string
    area_id: number
    convocatoria_id: number
    categoria_id: number
    fecha_inscripcion?: Date | string
    estado_inscripcion?: string
    tutorInscripciones?: Inscripcion_tutorUncheckedCreateNestedManyWithoutInscripcionInput
  }

  export type InscripcionCreateOrConnectWithoutPagosInput = {
    where: InscripcionWhereUniqueInput
    create: XOR<InscripcionCreateWithoutPagosInput, InscripcionUncheckedCreateWithoutPagosInput>
  }

  export type Metodo_pagoCreateWithoutPagoInput = {
    nombre: string
  }

  export type Metodo_pagoUncheckedCreateWithoutPagoInput = {
    id?: number
    nombre: string
  }

  export type Metodo_pagoCreateOrConnectWithoutPagoInput = {
    where: Metodo_pagoWhereUniqueInput
    create: XOR<Metodo_pagoCreateWithoutPagoInput, Metodo_pagoUncheckedCreateWithoutPagoInput>
  }

  export type InscripcionUpsertWithoutPagosInput = {
    update: XOR<InscripcionUpdateWithoutPagosInput, InscripcionUncheckedUpdateWithoutPagosInput>
    create: XOR<InscripcionCreateWithoutPagosInput, InscripcionUncheckedCreateWithoutPagosInput>
    where?: InscripcionWhereInput
  }

  export type InscripcionUpdateToOneWithWhereWithoutPagosInput = {
    where?: InscripcionWhereInput
    data: XOR<InscripcionUpdateWithoutPagosInput, InscripcionUncheckedUpdateWithoutPagosInput>
  }

  export type InscripcionUpdateWithoutPagosInput = {
    fecha_inscripcion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado_inscripcion?: StringFieldUpdateOperationsInput | string
    tutorInscripciones?: Inscripcion_tutorUpdateManyWithoutInscripcionNestedInput
    competidor?: CompetidorUpdateOneRequiredWithoutInscripcionNestedInput
    area?: AreaUpdateOneRequiredWithoutInscripcionNestedInput
    convocatoria?: ConvocatoriaUpdateOneRequiredWithoutInscripcionNestedInput
    categoria?: CategoriaUpdateOneRequiredWithoutInscripcionNestedInput
  }

  export type InscripcionUncheckedUpdateWithoutPagosInput = {
    id?: IntFieldUpdateOperationsInput | number
    competidor_id?: StringFieldUpdateOperationsInput | string
    area_id?: IntFieldUpdateOperationsInput | number
    convocatoria_id?: IntFieldUpdateOperationsInput | number
    categoria_id?: IntFieldUpdateOperationsInput | number
    fecha_inscripcion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado_inscripcion?: StringFieldUpdateOperationsInput | string
    tutorInscripciones?: Inscripcion_tutorUncheckedUpdateManyWithoutInscripcionNestedInput
  }

  export type Metodo_pagoUpsertWithoutPagoInput = {
    update: XOR<Metodo_pagoUpdateWithoutPagoInput, Metodo_pagoUncheckedUpdateWithoutPagoInput>
    create: XOR<Metodo_pagoCreateWithoutPagoInput, Metodo_pagoUncheckedCreateWithoutPagoInput>
    where?: Metodo_pagoWhereInput
  }

  export type Metodo_pagoUpdateToOneWithWhereWithoutPagoInput = {
    where?: Metodo_pagoWhereInput
    data: XOR<Metodo_pagoUpdateWithoutPagoInput, Metodo_pagoUncheckedUpdateWithoutPagoInput>
  }

  export type Metodo_pagoUpdateWithoutPagoInput = {
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type Metodo_pagoUncheckedUpdateWithoutPagoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type AreaCreateWithoutArea_convocatoriaInput = {
    nombre_area: string
    descripcion_area: string
    costo: Decimal | DecimalJsLike | number | string
    area_categoria?: Categoria_areaCreateNestedManyWithoutAreaInput
    Tutor?: TutorCreateNestedManyWithoutAreaInput
    Inscripcion?: InscripcionCreateNestedManyWithoutAreaInput
  }

  export type AreaUncheckedCreateWithoutArea_convocatoriaInput = {
    id?: number
    nombre_area: string
    descripcion_area: string
    costo: Decimal | DecimalJsLike | number | string
    area_categoria?: Categoria_areaUncheckedCreateNestedManyWithoutAreaInput
    Tutor?: TutorUncheckedCreateNestedManyWithoutAreaInput
    Inscripcion?: InscripcionUncheckedCreateNestedManyWithoutAreaInput
  }

  export type AreaCreateOrConnectWithoutArea_convocatoriaInput = {
    where: AreaWhereUniqueInput
    create: XOR<AreaCreateWithoutArea_convocatoriaInput, AreaUncheckedCreateWithoutArea_convocatoriaInput>
  }

  export type ConvocatoriaCreateWithoutArea_convocatoriaInput = {
    nombre_convocatoria: string
    fecha_inicio: Date | string
    fecha_fin: Date | string
    pago_fin: Date | string
    pago_inicio: Date | string
    competicion_inicio: Date | string
    competicion_fin: Date | string
    descripcion_convocatoria: string
    estado_convocatoria: estado_convocatoriaCreateNestedOneWithoutConvocatoriaInput
    Inscripcion?: InscripcionCreateNestedManyWithoutConvocatoriaInput
  }

  export type ConvocatoriaUncheckedCreateWithoutArea_convocatoriaInput = {
    id?: number
    nombre_convocatoria: string
    id_estado_convocatoria: number
    fecha_inicio: Date | string
    fecha_fin: Date | string
    pago_fin: Date | string
    pago_inicio: Date | string
    competicion_inicio: Date | string
    competicion_fin: Date | string
    descripcion_convocatoria: string
    Inscripcion?: InscripcionUncheckedCreateNestedManyWithoutConvocatoriaInput
  }

  export type ConvocatoriaCreateOrConnectWithoutArea_convocatoriaInput = {
    where: ConvocatoriaWhereUniqueInput
    create: XOR<ConvocatoriaCreateWithoutArea_convocatoriaInput, ConvocatoriaUncheckedCreateWithoutArea_convocatoriaInput>
  }

  export type AreaUpsertWithoutArea_convocatoriaInput = {
    update: XOR<AreaUpdateWithoutArea_convocatoriaInput, AreaUncheckedUpdateWithoutArea_convocatoriaInput>
    create: XOR<AreaCreateWithoutArea_convocatoriaInput, AreaUncheckedCreateWithoutArea_convocatoriaInput>
    where?: AreaWhereInput
  }

  export type AreaUpdateToOneWithWhereWithoutArea_convocatoriaInput = {
    where?: AreaWhereInput
    data: XOR<AreaUpdateWithoutArea_convocatoriaInput, AreaUncheckedUpdateWithoutArea_convocatoriaInput>
  }

  export type AreaUpdateWithoutArea_convocatoriaInput = {
    nombre_area?: StringFieldUpdateOperationsInput | string
    descripcion_area?: StringFieldUpdateOperationsInput | string
    costo?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    area_categoria?: Categoria_areaUpdateManyWithoutAreaNestedInput
    Tutor?: TutorUpdateManyWithoutAreaNestedInput
    Inscripcion?: InscripcionUpdateManyWithoutAreaNestedInput
  }

  export type AreaUncheckedUpdateWithoutArea_convocatoriaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre_area?: StringFieldUpdateOperationsInput | string
    descripcion_area?: StringFieldUpdateOperationsInput | string
    costo?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    area_categoria?: Categoria_areaUncheckedUpdateManyWithoutAreaNestedInput
    Tutor?: TutorUncheckedUpdateManyWithoutAreaNestedInput
    Inscripcion?: InscripcionUncheckedUpdateManyWithoutAreaNestedInput
  }

  export type ConvocatoriaUpsertWithoutArea_convocatoriaInput = {
    update: XOR<ConvocatoriaUpdateWithoutArea_convocatoriaInput, ConvocatoriaUncheckedUpdateWithoutArea_convocatoriaInput>
    create: XOR<ConvocatoriaCreateWithoutArea_convocatoriaInput, ConvocatoriaUncheckedCreateWithoutArea_convocatoriaInput>
    where?: ConvocatoriaWhereInput
  }

  export type ConvocatoriaUpdateToOneWithWhereWithoutArea_convocatoriaInput = {
    where?: ConvocatoriaWhereInput
    data: XOR<ConvocatoriaUpdateWithoutArea_convocatoriaInput, ConvocatoriaUncheckedUpdateWithoutArea_convocatoriaInput>
  }

  export type ConvocatoriaUpdateWithoutArea_convocatoriaInput = {
    nombre_convocatoria?: StringFieldUpdateOperationsInput | string
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    pago_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    pago_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    competicion_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    competicion_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    descripcion_convocatoria?: StringFieldUpdateOperationsInput | string
    estado_convocatoria?: estado_convocatoriaUpdateOneRequiredWithoutConvocatoriaNestedInput
    Inscripcion?: InscripcionUpdateManyWithoutConvocatoriaNestedInput
  }

  export type ConvocatoriaUncheckedUpdateWithoutArea_convocatoriaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre_convocatoria?: StringFieldUpdateOperationsInput | string
    id_estado_convocatoria?: IntFieldUpdateOperationsInput | number
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    pago_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    pago_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    competicion_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    competicion_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    descripcion_convocatoria?: StringFieldUpdateOperationsInput | string
    Inscripcion?: InscripcionUncheckedUpdateManyWithoutConvocatoriaNestedInput
  }

  export type AreaCreateWithoutArea_categoriaInput = {
    nombre_area: string
    descripcion_area: string
    costo: Decimal | DecimalJsLike | number | string
    Area_convocatoria?: Area_convocatoriaCreateNestedManyWithoutAreaInput
    Tutor?: TutorCreateNestedManyWithoutAreaInput
    Inscripcion?: InscripcionCreateNestedManyWithoutAreaInput
  }

  export type AreaUncheckedCreateWithoutArea_categoriaInput = {
    id?: number
    nombre_area: string
    descripcion_area: string
    costo: Decimal | DecimalJsLike | number | string
    Area_convocatoria?: Area_convocatoriaUncheckedCreateNestedManyWithoutAreaInput
    Tutor?: TutorUncheckedCreateNestedManyWithoutAreaInput
    Inscripcion?: InscripcionUncheckedCreateNestedManyWithoutAreaInput
  }

  export type AreaCreateOrConnectWithoutArea_categoriaInput = {
    where: AreaWhereUniqueInput
    create: XOR<AreaCreateWithoutArea_categoriaInput, AreaUncheckedCreateWithoutArea_categoriaInput>
  }

  export type CategoriaCreateWithoutCategoria_convocatoriaInput = {
    nombre_categoria: string
    descripcion_cat: string
    grado_max: GradoCreateNestedOneWithoutCategorias_maxInput
    grado_min: GradoCreateNestedOneWithoutCategorias_minInput
    Inscripcion?: InscripcionCreateNestedManyWithoutCategoriaInput
  }

  export type CategoriaUncheckedCreateWithoutCategoria_convocatoriaInput = {
    id?: number
    nombre_categoria: string
    grado_min_id: number
    grado_max_id: number
    descripcion_cat: string
    Inscripcion?: InscripcionUncheckedCreateNestedManyWithoutCategoriaInput
  }

  export type CategoriaCreateOrConnectWithoutCategoria_convocatoriaInput = {
    where: CategoriaWhereUniqueInput
    create: XOR<CategoriaCreateWithoutCategoria_convocatoriaInput, CategoriaUncheckedCreateWithoutCategoria_convocatoriaInput>
  }

  export type AreaUpsertWithoutArea_categoriaInput = {
    update: XOR<AreaUpdateWithoutArea_categoriaInput, AreaUncheckedUpdateWithoutArea_categoriaInput>
    create: XOR<AreaCreateWithoutArea_categoriaInput, AreaUncheckedCreateWithoutArea_categoriaInput>
    where?: AreaWhereInput
  }

  export type AreaUpdateToOneWithWhereWithoutArea_categoriaInput = {
    where?: AreaWhereInput
    data: XOR<AreaUpdateWithoutArea_categoriaInput, AreaUncheckedUpdateWithoutArea_categoriaInput>
  }

  export type AreaUpdateWithoutArea_categoriaInput = {
    nombre_area?: StringFieldUpdateOperationsInput | string
    descripcion_area?: StringFieldUpdateOperationsInput | string
    costo?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Area_convocatoria?: Area_convocatoriaUpdateManyWithoutAreaNestedInput
    Tutor?: TutorUpdateManyWithoutAreaNestedInput
    Inscripcion?: InscripcionUpdateManyWithoutAreaNestedInput
  }

  export type AreaUncheckedUpdateWithoutArea_categoriaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre_area?: StringFieldUpdateOperationsInput | string
    descripcion_area?: StringFieldUpdateOperationsInput | string
    costo?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Area_convocatoria?: Area_convocatoriaUncheckedUpdateManyWithoutAreaNestedInput
    Tutor?: TutorUncheckedUpdateManyWithoutAreaNestedInput
    Inscripcion?: InscripcionUncheckedUpdateManyWithoutAreaNestedInput
  }

  export type CategoriaUpsertWithoutCategoria_convocatoriaInput = {
    update: XOR<CategoriaUpdateWithoutCategoria_convocatoriaInput, CategoriaUncheckedUpdateWithoutCategoria_convocatoriaInput>
    create: XOR<CategoriaCreateWithoutCategoria_convocatoriaInput, CategoriaUncheckedCreateWithoutCategoria_convocatoriaInput>
    where?: CategoriaWhereInput
  }

  export type CategoriaUpdateToOneWithWhereWithoutCategoria_convocatoriaInput = {
    where?: CategoriaWhereInput
    data: XOR<CategoriaUpdateWithoutCategoria_convocatoriaInput, CategoriaUncheckedUpdateWithoutCategoria_convocatoriaInput>
  }

  export type CategoriaUpdateWithoutCategoria_convocatoriaInput = {
    nombre_categoria?: StringFieldUpdateOperationsInput | string
    descripcion_cat?: StringFieldUpdateOperationsInput | string
    grado_max?: GradoUpdateOneRequiredWithoutCategorias_maxNestedInput
    grado_min?: GradoUpdateOneRequiredWithoutCategorias_minNestedInput
    Inscripcion?: InscripcionUpdateManyWithoutCategoriaNestedInput
  }

  export type CategoriaUncheckedUpdateWithoutCategoria_convocatoriaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre_categoria?: StringFieldUpdateOperationsInput | string
    grado_min_id?: IntFieldUpdateOperationsInput | number
    grado_max_id?: IntFieldUpdateOperationsInput | number
    descripcion_cat?: StringFieldUpdateOperationsInput | string
    Inscripcion?: InscripcionUncheckedUpdateManyWithoutCategoriaNestedInput
  }

  export type InscripcionCreateWithoutTutorInscripcionesInput = {
    fecha_inscripcion?: Date | string
    estado_inscripcion?: string
    pagos?: PagoCreateNestedManyWithoutInscripcionInput
    competidor: CompetidorCreateNestedOneWithoutInscripcionInput
    area: AreaCreateNestedOneWithoutInscripcionInput
    convocatoria: ConvocatoriaCreateNestedOneWithoutInscripcionInput
    categoria: CategoriaCreateNestedOneWithoutInscripcionInput
  }

  export type InscripcionUncheckedCreateWithoutTutorInscripcionesInput = {
    id?: number
    competidor_id: string
    area_id: number
    convocatoria_id: number
    categoria_id: number
    fecha_inscripcion?: Date | string
    estado_inscripcion?: string
    pagos?: PagoUncheckedCreateNestedManyWithoutInscripcionInput
  }

  export type InscripcionCreateOrConnectWithoutTutorInscripcionesInput = {
    where: InscripcionWhereUniqueInput
    create: XOR<InscripcionCreateWithoutTutorInscripcionesInput, InscripcionUncheckedCreateWithoutTutorInscripcionesInput>
  }

  export type TutorCreateWithoutInscripciones_tutorInput = {
    id?: string
    carnet_identidad: string
    numero_celular: string
    area: AreaCreateNestedOneWithoutTutorInput
    usuario: UsuarioCreateNestedOneWithoutTutorInput
  }

  export type TutorUncheckedCreateWithoutInscripciones_tutorInput = {
    id?: string
    usuario_id: string
    carnet_identidad: string
    numero_celular: string
    area_id: number
  }

  export type TutorCreateOrConnectWithoutInscripciones_tutorInput = {
    where: TutorWhereUniqueInput
    create: XOR<TutorCreateWithoutInscripciones_tutorInput, TutorUncheckedCreateWithoutInscripciones_tutorInput>
  }

  export type CompetidorCreateWithoutInscripcionesInput = {
    id?: string
    carnet_identidad: string
    fecha_nacimiento: Date | string
    colegio: ColegioCreateNestedOneWithoutCompetidoresInput
    provincia: ProvinciaCreateNestedOneWithoutCompetidorInput
    usuario: UsuarioCreateNestedOneWithoutCompetidorInput
    Inscripcion?: InscripcionCreateNestedManyWithoutCompetidorInput
  }

  export type CompetidorUncheckedCreateWithoutInscripcionesInput = {
    id?: string
    usuario_id: string
    colegio_id: number
    provincia_id: number
    carnet_identidad: string
    fecha_nacimiento: Date | string
    Inscripcion?: InscripcionUncheckedCreateNestedManyWithoutCompetidorInput
  }

  export type CompetidorCreateOrConnectWithoutInscripcionesInput = {
    where: CompetidorWhereUniqueInput
    create: XOR<CompetidorCreateWithoutInscripcionesInput, CompetidorUncheckedCreateWithoutInscripcionesInput>
  }

  export type Motivo_rechazoCreateWithoutInscripcionesTutorInput = {
    mensaje: string
  }

  export type Motivo_rechazoUncheckedCreateWithoutInscripcionesTutorInput = {
    id?: number
    mensaje: string
  }

  export type Motivo_rechazoCreateOrConnectWithoutInscripcionesTutorInput = {
    where: Motivo_rechazoWhereUniqueInput
    create: XOR<Motivo_rechazoCreateWithoutInscripcionesTutorInput, Motivo_rechazoUncheckedCreateWithoutInscripcionesTutorInput>
  }

  export type InscripcionUpsertWithoutTutorInscripcionesInput = {
    update: XOR<InscripcionUpdateWithoutTutorInscripcionesInput, InscripcionUncheckedUpdateWithoutTutorInscripcionesInput>
    create: XOR<InscripcionCreateWithoutTutorInscripcionesInput, InscripcionUncheckedCreateWithoutTutorInscripcionesInput>
    where?: InscripcionWhereInput
  }

  export type InscripcionUpdateToOneWithWhereWithoutTutorInscripcionesInput = {
    where?: InscripcionWhereInput
    data: XOR<InscripcionUpdateWithoutTutorInscripcionesInput, InscripcionUncheckedUpdateWithoutTutorInscripcionesInput>
  }

  export type InscripcionUpdateWithoutTutorInscripcionesInput = {
    fecha_inscripcion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado_inscripcion?: StringFieldUpdateOperationsInput | string
    pagos?: PagoUpdateManyWithoutInscripcionNestedInput
    competidor?: CompetidorUpdateOneRequiredWithoutInscripcionNestedInput
    area?: AreaUpdateOneRequiredWithoutInscripcionNestedInput
    convocatoria?: ConvocatoriaUpdateOneRequiredWithoutInscripcionNestedInput
    categoria?: CategoriaUpdateOneRequiredWithoutInscripcionNestedInput
  }

  export type InscripcionUncheckedUpdateWithoutTutorInscripcionesInput = {
    id?: IntFieldUpdateOperationsInput | number
    competidor_id?: StringFieldUpdateOperationsInput | string
    area_id?: IntFieldUpdateOperationsInput | number
    convocatoria_id?: IntFieldUpdateOperationsInput | number
    categoria_id?: IntFieldUpdateOperationsInput | number
    fecha_inscripcion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado_inscripcion?: StringFieldUpdateOperationsInput | string
    pagos?: PagoUncheckedUpdateManyWithoutInscripcionNestedInput
  }

  export type TutorUpsertWithoutInscripciones_tutorInput = {
    update: XOR<TutorUpdateWithoutInscripciones_tutorInput, TutorUncheckedUpdateWithoutInscripciones_tutorInput>
    create: XOR<TutorCreateWithoutInscripciones_tutorInput, TutorUncheckedCreateWithoutInscripciones_tutorInput>
    where?: TutorWhereInput
  }

  export type TutorUpdateToOneWithWhereWithoutInscripciones_tutorInput = {
    where?: TutorWhereInput
    data: XOR<TutorUpdateWithoutInscripciones_tutorInput, TutorUncheckedUpdateWithoutInscripciones_tutorInput>
  }

  export type TutorUpdateWithoutInscripciones_tutorInput = {
    id?: StringFieldUpdateOperationsInput | string
    carnet_identidad?: StringFieldUpdateOperationsInput | string
    numero_celular?: StringFieldUpdateOperationsInput | string
    area?: AreaUpdateOneRequiredWithoutTutorNestedInput
    usuario?: UsuarioUpdateOneRequiredWithoutTutorNestedInput
  }

  export type TutorUncheckedUpdateWithoutInscripciones_tutorInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuario_id?: StringFieldUpdateOperationsInput | string
    carnet_identidad?: StringFieldUpdateOperationsInput | string
    numero_celular?: StringFieldUpdateOperationsInput | string
    area_id?: IntFieldUpdateOperationsInput | number
  }

  export type CompetidorUpsertWithoutInscripcionesInput = {
    update: XOR<CompetidorUpdateWithoutInscripcionesInput, CompetidorUncheckedUpdateWithoutInscripcionesInput>
    create: XOR<CompetidorCreateWithoutInscripcionesInput, CompetidorUncheckedCreateWithoutInscripcionesInput>
    where?: CompetidorWhereInput
  }

  export type CompetidorUpdateToOneWithWhereWithoutInscripcionesInput = {
    where?: CompetidorWhereInput
    data: XOR<CompetidorUpdateWithoutInscripcionesInput, CompetidorUncheckedUpdateWithoutInscripcionesInput>
  }

  export type CompetidorUpdateWithoutInscripcionesInput = {
    id?: StringFieldUpdateOperationsInput | string
    carnet_identidad?: StringFieldUpdateOperationsInput | string
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    colegio?: ColegioUpdateOneRequiredWithoutCompetidoresNestedInput
    provincia?: ProvinciaUpdateOneRequiredWithoutCompetidorNestedInput
    usuario?: UsuarioUpdateOneRequiredWithoutCompetidorNestedInput
    Inscripcion?: InscripcionUpdateManyWithoutCompetidorNestedInput
  }

  export type CompetidorUncheckedUpdateWithoutInscripcionesInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuario_id?: StringFieldUpdateOperationsInput | string
    colegio_id?: IntFieldUpdateOperationsInput | number
    provincia_id?: IntFieldUpdateOperationsInput | number
    carnet_identidad?: StringFieldUpdateOperationsInput | string
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    Inscripcion?: InscripcionUncheckedUpdateManyWithoutCompetidorNestedInput
  }

  export type Motivo_rechazoUpsertWithoutInscripcionesTutorInput = {
    update: XOR<Motivo_rechazoUpdateWithoutInscripcionesTutorInput, Motivo_rechazoUncheckedUpdateWithoutInscripcionesTutorInput>
    create: XOR<Motivo_rechazoCreateWithoutInscripcionesTutorInput, Motivo_rechazoUncheckedCreateWithoutInscripcionesTutorInput>
    where?: Motivo_rechazoWhereInput
  }

  export type Motivo_rechazoUpdateToOneWithWhereWithoutInscripcionesTutorInput = {
    where?: Motivo_rechazoWhereInput
    data: XOR<Motivo_rechazoUpdateWithoutInscripcionesTutorInput, Motivo_rechazoUncheckedUpdateWithoutInscripcionesTutorInput>
  }

  export type Motivo_rechazoUpdateWithoutInscripcionesTutorInput = {
    mensaje?: StringFieldUpdateOperationsInput | string
  }

  export type Motivo_rechazoUncheckedUpdateWithoutInscripcionesTutorInput = {
    id?: IntFieldUpdateOperationsInput | number
    mensaje?: StringFieldUpdateOperationsInput | string
  }

  export type PagoCreateWithoutMetodo_pagoInput = {
    monto: Decimal | DecimalJsLike | number | string
    estado?: string
    codigo_pago: string
    fecha_pago?: Date | string
    inscripcion: InscripcionCreateNestedOneWithoutPagosInput
  }

  export type PagoUncheckedCreateWithoutMetodo_pagoInput = {
    id?: number
    inscripcion_id: number
    monto: Decimal | DecimalJsLike | number | string
    estado?: string
    codigo_pago: string
    fecha_pago?: Date | string
  }

  export type PagoCreateOrConnectWithoutMetodo_pagoInput = {
    where: PagoWhereUniqueInput
    create: XOR<PagoCreateWithoutMetodo_pagoInput, PagoUncheckedCreateWithoutMetodo_pagoInput>
  }

  export type PagoCreateManyMetodo_pagoInputEnvelope = {
    data: PagoCreateManyMetodo_pagoInput | PagoCreateManyMetodo_pagoInput[]
    skipDuplicates?: boolean
  }

  export type PagoUpsertWithWhereUniqueWithoutMetodo_pagoInput = {
    where: PagoWhereUniqueInput
    update: XOR<PagoUpdateWithoutMetodo_pagoInput, PagoUncheckedUpdateWithoutMetodo_pagoInput>
    create: XOR<PagoCreateWithoutMetodo_pagoInput, PagoUncheckedCreateWithoutMetodo_pagoInput>
  }

  export type PagoUpdateWithWhereUniqueWithoutMetodo_pagoInput = {
    where: PagoWhereUniqueInput
    data: XOR<PagoUpdateWithoutMetodo_pagoInput, PagoUncheckedUpdateWithoutMetodo_pagoInput>
  }

  export type PagoUpdateManyWithWhereWithoutMetodo_pagoInput = {
    where: PagoScalarWhereInput
    data: XOR<PagoUpdateManyMutationInput, PagoUncheckedUpdateManyWithoutMetodo_pagoInput>
  }

  export type PagoScalarWhereInput = {
    AND?: PagoScalarWhereInput | PagoScalarWhereInput[]
    OR?: PagoScalarWhereInput[]
    NOT?: PagoScalarWhereInput | PagoScalarWhereInput[]
    id?: IntFilter<"Pago"> | number
    inscripcion_id?: IntFilter<"Pago"> | number
    monto?: DecimalFilter<"Pago"> | Decimal | DecimalJsLike | number | string
    estado?: StringFilter<"Pago"> | string
    codigo_pago?: StringFilter<"Pago"> | string
    fecha_pago?: DateTimeFilter<"Pago"> | Date | string
    metodo_pago_id?: IntFilter<"Pago"> | number
  }

  export type ConvocatoriaCreateWithoutEstado_convocatoriaInput = {
    nombre_convocatoria: string
    fecha_inicio: Date | string
    fecha_fin: Date | string
    pago_fin: Date | string
    pago_inicio: Date | string
    competicion_inicio: Date | string
    competicion_fin: Date | string
    descripcion_convocatoria: string
    Area_convocatoria?: Area_convocatoriaCreateNestedManyWithoutConvocatoriaInput
    Inscripcion?: InscripcionCreateNestedManyWithoutConvocatoriaInput
  }

  export type ConvocatoriaUncheckedCreateWithoutEstado_convocatoriaInput = {
    id?: number
    nombre_convocatoria: string
    fecha_inicio: Date | string
    fecha_fin: Date | string
    pago_fin: Date | string
    pago_inicio: Date | string
    competicion_inicio: Date | string
    competicion_fin: Date | string
    descripcion_convocatoria: string
    Area_convocatoria?: Area_convocatoriaUncheckedCreateNestedManyWithoutConvocatoriaInput
    Inscripcion?: InscripcionUncheckedCreateNestedManyWithoutConvocatoriaInput
  }

  export type ConvocatoriaCreateOrConnectWithoutEstado_convocatoriaInput = {
    where: ConvocatoriaWhereUniqueInput
    create: XOR<ConvocatoriaCreateWithoutEstado_convocatoriaInput, ConvocatoriaUncheckedCreateWithoutEstado_convocatoriaInput>
  }

  export type ConvocatoriaCreateManyEstado_convocatoriaInputEnvelope = {
    data: ConvocatoriaCreateManyEstado_convocatoriaInput | ConvocatoriaCreateManyEstado_convocatoriaInput[]
    skipDuplicates?: boolean
  }

  export type ConvocatoriaUpsertWithWhereUniqueWithoutEstado_convocatoriaInput = {
    where: ConvocatoriaWhereUniqueInput
    update: XOR<ConvocatoriaUpdateWithoutEstado_convocatoriaInput, ConvocatoriaUncheckedUpdateWithoutEstado_convocatoriaInput>
    create: XOR<ConvocatoriaCreateWithoutEstado_convocatoriaInput, ConvocatoriaUncheckedCreateWithoutEstado_convocatoriaInput>
  }

  export type ConvocatoriaUpdateWithWhereUniqueWithoutEstado_convocatoriaInput = {
    where: ConvocatoriaWhereUniqueInput
    data: XOR<ConvocatoriaUpdateWithoutEstado_convocatoriaInput, ConvocatoriaUncheckedUpdateWithoutEstado_convocatoriaInput>
  }

  export type ConvocatoriaUpdateManyWithWhereWithoutEstado_convocatoriaInput = {
    where: ConvocatoriaScalarWhereInput
    data: XOR<ConvocatoriaUpdateManyMutationInput, ConvocatoriaUncheckedUpdateManyWithoutEstado_convocatoriaInput>
  }

  export type ConvocatoriaScalarWhereInput = {
    AND?: ConvocatoriaScalarWhereInput | ConvocatoriaScalarWhereInput[]
    OR?: ConvocatoriaScalarWhereInput[]
    NOT?: ConvocatoriaScalarWhereInput | ConvocatoriaScalarWhereInput[]
    id?: IntFilter<"Convocatoria"> | number
    nombre_convocatoria?: StringFilter<"Convocatoria"> | string
    id_estado_convocatoria?: IntFilter<"Convocatoria"> | number
    fecha_inicio?: DateTimeFilter<"Convocatoria"> | Date | string
    fecha_fin?: DateTimeFilter<"Convocatoria"> | Date | string
    pago_fin?: DateTimeFilter<"Convocatoria"> | Date | string
    pago_inicio?: DateTimeFilter<"Convocatoria"> | Date | string
    competicion_inicio?: DateTimeFilter<"Convocatoria"> | Date | string
    competicion_fin?: DateTimeFilter<"Convocatoria"> | Date | string
    descripcion_convocatoria?: StringFilter<"Convocatoria"> | string
  }

  export type Inscripcion_tutorCreateWithoutInscripcionInput = {
    aprobado?: boolean
    fecha_aprobacion?: Date | string | null
    descripcion_rechazo?: string | null
    tutor: TutorCreateNestedOneWithoutInscripciones_tutorInput
    Competidor?: CompetidorCreateNestedOneWithoutInscripcionesInput
    MotivoRechazo?: Motivo_rechazoCreateNestedOneWithoutInscripcionesTutorInput
  }

  export type Inscripcion_tutorUncheckedCreateWithoutInscripcionInput = {
    id?: number
    tutor_id: string
    aprobado?: boolean
    fecha_aprobacion?: Date | string | null
    motivo_rechazo_id?: number | null
    descripcion_rechazo?: string | null
    competidorId?: string | null
  }

  export type Inscripcion_tutorCreateOrConnectWithoutInscripcionInput = {
    where: Inscripcion_tutorWhereUniqueInput
    create: XOR<Inscripcion_tutorCreateWithoutInscripcionInput, Inscripcion_tutorUncheckedCreateWithoutInscripcionInput>
  }

  export type Inscripcion_tutorCreateManyInscripcionInputEnvelope = {
    data: Inscripcion_tutorCreateManyInscripcionInput | Inscripcion_tutorCreateManyInscripcionInput[]
    skipDuplicates?: boolean
  }

  export type PagoCreateWithoutInscripcionInput = {
    monto: Decimal | DecimalJsLike | number | string
    estado?: string
    codigo_pago: string
    fecha_pago?: Date | string
    metodo_pago: Metodo_pagoCreateNestedOneWithoutPagoInput
  }

  export type PagoUncheckedCreateWithoutInscripcionInput = {
    id?: number
    monto: Decimal | DecimalJsLike | number | string
    estado?: string
    codigo_pago: string
    fecha_pago?: Date | string
    metodo_pago_id: number
  }

  export type PagoCreateOrConnectWithoutInscripcionInput = {
    where: PagoWhereUniqueInput
    create: XOR<PagoCreateWithoutInscripcionInput, PagoUncheckedCreateWithoutInscripcionInput>
  }

  export type PagoCreateManyInscripcionInputEnvelope = {
    data: PagoCreateManyInscripcionInput | PagoCreateManyInscripcionInput[]
    skipDuplicates?: boolean
  }

  export type CompetidorCreateWithoutInscripcionInput = {
    id?: string
    carnet_identidad: string
    fecha_nacimiento: Date | string
    colegio: ColegioCreateNestedOneWithoutCompetidoresInput
    provincia: ProvinciaCreateNestedOneWithoutCompetidorInput
    usuario: UsuarioCreateNestedOneWithoutCompetidorInput
    Inscripciones?: Inscripcion_tutorCreateNestedManyWithoutCompetidorInput
  }

  export type CompetidorUncheckedCreateWithoutInscripcionInput = {
    id?: string
    usuario_id: string
    colegio_id: number
    provincia_id: number
    carnet_identidad: string
    fecha_nacimiento: Date | string
    Inscripciones?: Inscripcion_tutorUncheckedCreateNestedManyWithoutCompetidorInput
  }

  export type CompetidorCreateOrConnectWithoutInscripcionInput = {
    where: CompetidorWhereUniqueInput
    create: XOR<CompetidorCreateWithoutInscripcionInput, CompetidorUncheckedCreateWithoutInscripcionInput>
  }

  export type AreaCreateWithoutInscripcionInput = {
    nombre_area: string
    descripcion_area: string
    costo: Decimal | DecimalJsLike | number | string
    Area_convocatoria?: Area_convocatoriaCreateNestedManyWithoutAreaInput
    area_categoria?: Categoria_areaCreateNestedManyWithoutAreaInput
    Tutor?: TutorCreateNestedManyWithoutAreaInput
  }

  export type AreaUncheckedCreateWithoutInscripcionInput = {
    id?: number
    nombre_area: string
    descripcion_area: string
    costo: Decimal | DecimalJsLike | number | string
    Area_convocatoria?: Area_convocatoriaUncheckedCreateNestedManyWithoutAreaInput
    area_categoria?: Categoria_areaUncheckedCreateNestedManyWithoutAreaInput
    Tutor?: TutorUncheckedCreateNestedManyWithoutAreaInput
  }

  export type AreaCreateOrConnectWithoutInscripcionInput = {
    where: AreaWhereUniqueInput
    create: XOR<AreaCreateWithoutInscripcionInput, AreaUncheckedCreateWithoutInscripcionInput>
  }

  export type ConvocatoriaCreateWithoutInscripcionInput = {
    nombre_convocatoria: string
    fecha_inicio: Date | string
    fecha_fin: Date | string
    pago_fin: Date | string
    pago_inicio: Date | string
    competicion_inicio: Date | string
    competicion_fin: Date | string
    descripcion_convocatoria: string
    Area_convocatoria?: Area_convocatoriaCreateNestedManyWithoutConvocatoriaInput
    estado_convocatoria: estado_convocatoriaCreateNestedOneWithoutConvocatoriaInput
  }

  export type ConvocatoriaUncheckedCreateWithoutInscripcionInput = {
    id?: number
    nombre_convocatoria: string
    id_estado_convocatoria: number
    fecha_inicio: Date | string
    fecha_fin: Date | string
    pago_fin: Date | string
    pago_inicio: Date | string
    competicion_inicio: Date | string
    competicion_fin: Date | string
    descripcion_convocatoria: string
    Area_convocatoria?: Area_convocatoriaUncheckedCreateNestedManyWithoutConvocatoriaInput
  }

  export type ConvocatoriaCreateOrConnectWithoutInscripcionInput = {
    where: ConvocatoriaWhereUniqueInput
    create: XOR<ConvocatoriaCreateWithoutInscripcionInput, ConvocatoriaUncheckedCreateWithoutInscripcionInput>
  }

  export type CategoriaCreateWithoutInscripcionInput = {
    nombre_categoria: string
    descripcion_cat: string
    grado_max: GradoCreateNestedOneWithoutCategorias_maxInput
    grado_min: GradoCreateNestedOneWithoutCategorias_minInput
    Categoria_convocatoria?: Categoria_areaCreateNestedManyWithoutCategoriaInput
  }

  export type CategoriaUncheckedCreateWithoutInscripcionInput = {
    id?: number
    nombre_categoria: string
    grado_min_id: number
    grado_max_id: number
    descripcion_cat: string
    Categoria_convocatoria?: Categoria_areaUncheckedCreateNestedManyWithoutCategoriaInput
  }

  export type CategoriaCreateOrConnectWithoutInscripcionInput = {
    where: CategoriaWhereUniqueInput
    create: XOR<CategoriaCreateWithoutInscripcionInput, CategoriaUncheckedCreateWithoutInscripcionInput>
  }

  export type Inscripcion_tutorUpsertWithWhereUniqueWithoutInscripcionInput = {
    where: Inscripcion_tutorWhereUniqueInput
    update: XOR<Inscripcion_tutorUpdateWithoutInscripcionInput, Inscripcion_tutorUncheckedUpdateWithoutInscripcionInput>
    create: XOR<Inscripcion_tutorCreateWithoutInscripcionInput, Inscripcion_tutorUncheckedCreateWithoutInscripcionInput>
  }

  export type Inscripcion_tutorUpdateWithWhereUniqueWithoutInscripcionInput = {
    where: Inscripcion_tutorWhereUniqueInput
    data: XOR<Inscripcion_tutorUpdateWithoutInscripcionInput, Inscripcion_tutorUncheckedUpdateWithoutInscripcionInput>
  }

  export type Inscripcion_tutorUpdateManyWithWhereWithoutInscripcionInput = {
    where: Inscripcion_tutorScalarWhereInput
    data: XOR<Inscripcion_tutorUpdateManyMutationInput, Inscripcion_tutorUncheckedUpdateManyWithoutInscripcionInput>
  }

  export type PagoUpsertWithWhereUniqueWithoutInscripcionInput = {
    where: PagoWhereUniqueInput
    update: XOR<PagoUpdateWithoutInscripcionInput, PagoUncheckedUpdateWithoutInscripcionInput>
    create: XOR<PagoCreateWithoutInscripcionInput, PagoUncheckedCreateWithoutInscripcionInput>
  }

  export type PagoUpdateWithWhereUniqueWithoutInscripcionInput = {
    where: PagoWhereUniqueInput
    data: XOR<PagoUpdateWithoutInscripcionInput, PagoUncheckedUpdateWithoutInscripcionInput>
  }

  export type PagoUpdateManyWithWhereWithoutInscripcionInput = {
    where: PagoScalarWhereInput
    data: XOR<PagoUpdateManyMutationInput, PagoUncheckedUpdateManyWithoutInscripcionInput>
  }

  export type CompetidorUpsertWithoutInscripcionInput = {
    update: XOR<CompetidorUpdateWithoutInscripcionInput, CompetidorUncheckedUpdateWithoutInscripcionInput>
    create: XOR<CompetidorCreateWithoutInscripcionInput, CompetidorUncheckedCreateWithoutInscripcionInput>
    where?: CompetidorWhereInput
  }

  export type CompetidorUpdateToOneWithWhereWithoutInscripcionInput = {
    where?: CompetidorWhereInput
    data: XOR<CompetidorUpdateWithoutInscripcionInput, CompetidorUncheckedUpdateWithoutInscripcionInput>
  }

  export type CompetidorUpdateWithoutInscripcionInput = {
    id?: StringFieldUpdateOperationsInput | string
    carnet_identidad?: StringFieldUpdateOperationsInput | string
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    colegio?: ColegioUpdateOneRequiredWithoutCompetidoresNestedInput
    provincia?: ProvinciaUpdateOneRequiredWithoutCompetidorNestedInput
    usuario?: UsuarioUpdateOneRequiredWithoutCompetidorNestedInput
    Inscripciones?: Inscripcion_tutorUpdateManyWithoutCompetidorNestedInput
  }

  export type CompetidorUncheckedUpdateWithoutInscripcionInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuario_id?: StringFieldUpdateOperationsInput | string
    colegio_id?: IntFieldUpdateOperationsInput | number
    provincia_id?: IntFieldUpdateOperationsInput | number
    carnet_identidad?: StringFieldUpdateOperationsInput | string
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    Inscripciones?: Inscripcion_tutorUncheckedUpdateManyWithoutCompetidorNestedInput
  }

  export type AreaUpsertWithoutInscripcionInput = {
    update: XOR<AreaUpdateWithoutInscripcionInput, AreaUncheckedUpdateWithoutInscripcionInput>
    create: XOR<AreaCreateWithoutInscripcionInput, AreaUncheckedCreateWithoutInscripcionInput>
    where?: AreaWhereInput
  }

  export type AreaUpdateToOneWithWhereWithoutInscripcionInput = {
    where?: AreaWhereInput
    data: XOR<AreaUpdateWithoutInscripcionInput, AreaUncheckedUpdateWithoutInscripcionInput>
  }

  export type AreaUpdateWithoutInscripcionInput = {
    nombre_area?: StringFieldUpdateOperationsInput | string
    descripcion_area?: StringFieldUpdateOperationsInput | string
    costo?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Area_convocatoria?: Area_convocatoriaUpdateManyWithoutAreaNestedInput
    area_categoria?: Categoria_areaUpdateManyWithoutAreaNestedInput
    Tutor?: TutorUpdateManyWithoutAreaNestedInput
  }

  export type AreaUncheckedUpdateWithoutInscripcionInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre_area?: StringFieldUpdateOperationsInput | string
    descripcion_area?: StringFieldUpdateOperationsInput | string
    costo?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Area_convocatoria?: Area_convocatoriaUncheckedUpdateManyWithoutAreaNestedInput
    area_categoria?: Categoria_areaUncheckedUpdateManyWithoutAreaNestedInput
    Tutor?: TutorUncheckedUpdateManyWithoutAreaNestedInput
  }

  export type ConvocatoriaUpsertWithoutInscripcionInput = {
    update: XOR<ConvocatoriaUpdateWithoutInscripcionInput, ConvocatoriaUncheckedUpdateWithoutInscripcionInput>
    create: XOR<ConvocatoriaCreateWithoutInscripcionInput, ConvocatoriaUncheckedCreateWithoutInscripcionInput>
    where?: ConvocatoriaWhereInput
  }

  export type ConvocatoriaUpdateToOneWithWhereWithoutInscripcionInput = {
    where?: ConvocatoriaWhereInput
    data: XOR<ConvocatoriaUpdateWithoutInscripcionInput, ConvocatoriaUncheckedUpdateWithoutInscripcionInput>
  }

  export type ConvocatoriaUpdateWithoutInscripcionInput = {
    nombre_convocatoria?: StringFieldUpdateOperationsInput | string
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    pago_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    pago_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    competicion_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    competicion_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    descripcion_convocatoria?: StringFieldUpdateOperationsInput | string
    Area_convocatoria?: Area_convocatoriaUpdateManyWithoutConvocatoriaNestedInput
    estado_convocatoria?: estado_convocatoriaUpdateOneRequiredWithoutConvocatoriaNestedInput
  }

  export type ConvocatoriaUncheckedUpdateWithoutInscripcionInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre_convocatoria?: StringFieldUpdateOperationsInput | string
    id_estado_convocatoria?: IntFieldUpdateOperationsInput | number
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    pago_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    pago_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    competicion_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    competicion_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    descripcion_convocatoria?: StringFieldUpdateOperationsInput | string
    Area_convocatoria?: Area_convocatoriaUncheckedUpdateManyWithoutConvocatoriaNestedInput
  }

  export type CategoriaUpsertWithoutInscripcionInput = {
    update: XOR<CategoriaUpdateWithoutInscripcionInput, CategoriaUncheckedUpdateWithoutInscripcionInput>
    create: XOR<CategoriaCreateWithoutInscripcionInput, CategoriaUncheckedCreateWithoutInscripcionInput>
    where?: CategoriaWhereInput
  }

  export type CategoriaUpdateToOneWithWhereWithoutInscripcionInput = {
    where?: CategoriaWhereInput
    data: XOR<CategoriaUpdateWithoutInscripcionInput, CategoriaUncheckedUpdateWithoutInscripcionInput>
  }

  export type CategoriaUpdateWithoutInscripcionInput = {
    nombre_categoria?: StringFieldUpdateOperationsInput | string
    descripcion_cat?: StringFieldUpdateOperationsInput | string
    grado_max?: GradoUpdateOneRequiredWithoutCategorias_maxNestedInput
    grado_min?: GradoUpdateOneRequiredWithoutCategorias_minNestedInput
    Categoria_convocatoria?: Categoria_areaUpdateManyWithoutCategoriaNestedInput
  }

  export type CategoriaUncheckedUpdateWithoutInscripcionInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre_categoria?: StringFieldUpdateOperationsInput | string
    grado_min_id?: IntFieldUpdateOperationsInput | number
    grado_max_id?: IntFieldUpdateOperationsInput | number
    descripcion_cat?: StringFieldUpdateOperationsInput | string
    Categoria_convocatoria?: Categoria_areaUncheckedUpdateManyWithoutCategoriaNestedInput
  }

  export type GradoCreateWithoutNivelInput = {
    nombre_grado: string
    categorias_max?: CategoriaCreateNestedManyWithoutGrado_maxInput
    categorias_min?: CategoriaCreateNestedManyWithoutGrado_minInput
  }

  export type GradoUncheckedCreateWithoutNivelInput = {
    id?: number
    nombre_grado: string
    categorias_max?: CategoriaUncheckedCreateNestedManyWithoutGrado_maxInput
    categorias_min?: CategoriaUncheckedCreateNestedManyWithoutGrado_minInput
  }

  export type GradoCreateOrConnectWithoutNivelInput = {
    where: GradoWhereUniqueInput
    create: XOR<GradoCreateWithoutNivelInput, GradoUncheckedCreateWithoutNivelInput>
  }

  export type GradoCreateManyNivelInputEnvelope = {
    data: GradoCreateManyNivelInput | GradoCreateManyNivelInput[]
    skipDuplicates?: boolean
  }

  export type GradoUpsertWithWhereUniqueWithoutNivelInput = {
    where: GradoWhereUniqueInput
    update: XOR<GradoUpdateWithoutNivelInput, GradoUncheckedUpdateWithoutNivelInput>
    create: XOR<GradoCreateWithoutNivelInput, GradoUncheckedCreateWithoutNivelInput>
  }

  export type GradoUpdateWithWhereUniqueWithoutNivelInput = {
    where: GradoWhereUniqueInput
    data: XOR<GradoUpdateWithoutNivelInput, GradoUncheckedUpdateWithoutNivelInput>
  }

  export type GradoUpdateManyWithWhereWithoutNivelInput = {
    where: GradoScalarWhereInput
    data: XOR<GradoUpdateManyMutationInput, GradoUncheckedUpdateManyWithoutNivelInput>
  }

  export type GradoScalarWhereInput = {
    AND?: GradoScalarWhereInput | GradoScalarWhereInput[]
    OR?: GradoScalarWhereInput[]
    NOT?: GradoScalarWhereInput | GradoScalarWhereInput[]
    id?: IntFilter<"Grado"> | number
    nombre_grado?: StringFilter<"Grado"> | string
    id_nivel?: IntFilter<"Grado"> | number
  }

  export type UsuarioCreateWithoutNotificacionInput = {
    id?: string
    correo_electronico: string
    nombre: string
    apellido: string
    estado?: boolean
    password: string
    createdAt?: Date | string
    competidor?: CompetidorCreateNestedOneWithoutUsuarioInput
    tutor?: TutorCreateNestedOneWithoutUsuarioInput
    role: RolCreateNestedOneWithoutUsuariosInput
  }

  export type UsuarioUncheckedCreateWithoutNotificacionInput = {
    id?: string
    correo_electronico: string
    nombre: string
    apellido: string
    estado?: boolean
    password: string
    rol_id: number
    createdAt?: Date | string
    competidor?: CompetidorUncheckedCreateNestedOneWithoutUsuarioInput
    tutor?: TutorUncheckedCreateNestedOneWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutNotificacionInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutNotificacionInput, UsuarioUncheckedCreateWithoutNotificacionInput>
  }

  export type UsuarioUpsertWithoutNotificacionInput = {
    update: XOR<UsuarioUpdateWithoutNotificacionInput, UsuarioUncheckedUpdateWithoutNotificacionInput>
    create: XOR<UsuarioCreateWithoutNotificacionInput, UsuarioUncheckedCreateWithoutNotificacionInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutNotificacionInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutNotificacionInput, UsuarioUncheckedUpdateWithoutNotificacionInput>
  }

  export type UsuarioUpdateWithoutNotificacionInput = {
    id?: StringFieldUpdateOperationsInput | string
    correo_electronico?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    competidor?: CompetidorUpdateOneWithoutUsuarioNestedInput
    tutor?: TutorUpdateOneWithoutUsuarioNestedInput
    role?: RolUpdateOneRequiredWithoutUsuariosNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutNotificacionInput = {
    id?: StringFieldUpdateOperationsInput | string
    correo_electronico?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    rol_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    competidor?: CompetidorUncheckedUpdateOneWithoutUsuarioNestedInput
    tutor?: TutorUncheckedUpdateOneWithoutUsuarioNestedInput
  }

  export type Inscripcion_tutorCreateWithoutMotivoRechazoInput = {
    aprobado?: boolean
    fecha_aprobacion?: Date | string | null
    descripcion_rechazo?: string | null
    inscripcion: InscripcionCreateNestedOneWithoutTutorInscripcionesInput
    tutor: TutorCreateNestedOneWithoutInscripciones_tutorInput
    Competidor?: CompetidorCreateNestedOneWithoutInscripcionesInput
  }

  export type Inscripcion_tutorUncheckedCreateWithoutMotivoRechazoInput = {
    id?: number
    inscripcion_id: number
    tutor_id: string
    aprobado?: boolean
    fecha_aprobacion?: Date | string | null
    descripcion_rechazo?: string | null
    competidorId?: string | null
  }

  export type Inscripcion_tutorCreateOrConnectWithoutMotivoRechazoInput = {
    where: Inscripcion_tutorWhereUniqueInput
    create: XOR<Inscripcion_tutorCreateWithoutMotivoRechazoInput, Inscripcion_tutorUncheckedCreateWithoutMotivoRechazoInput>
  }

  export type Inscripcion_tutorCreateManyMotivoRechazoInputEnvelope = {
    data: Inscripcion_tutorCreateManyMotivoRechazoInput | Inscripcion_tutorCreateManyMotivoRechazoInput[]
    skipDuplicates?: boolean
  }

  export type Inscripcion_tutorUpsertWithWhereUniqueWithoutMotivoRechazoInput = {
    where: Inscripcion_tutorWhereUniqueInput
    update: XOR<Inscripcion_tutorUpdateWithoutMotivoRechazoInput, Inscripcion_tutorUncheckedUpdateWithoutMotivoRechazoInput>
    create: XOR<Inscripcion_tutorCreateWithoutMotivoRechazoInput, Inscripcion_tutorUncheckedCreateWithoutMotivoRechazoInput>
  }

  export type Inscripcion_tutorUpdateWithWhereUniqueWithoutMotivoRechazoInput = {
    where: Inscripcion_tutorWhereUniqueInput
    data: XOR<Inscripcion_tutorUpdateWithoutMotivoRechazoInput, Inscripcion_tutorUncheckedUpdateWithoutMotivoRechazoInput>
  }

  export type Inscripcion_tutorUpdateManyWithWhereWithoutMotivoRechazoInput = {
    where: Inscripcion_tutorScalarWhereInput
    data: XOR<Inscripcion_tutorUpdateManyMutationInput, Inscripcion_tutorUncheckedUpdateManyWithoutMotivoRechazoInput>
  }

  export type NotificacionCreateManyUsuarioInput = {
    id?: number
    tipo: string
    mensaje: string
    leido?: boolean
    createdAt?: Date | string
  }

  export type NotificacionUpdateWithoutUsuarioInput = {
    tipo?: StringFieldUpdateOperationsInput | string
    mensaje?: StringFieldUpdateOperationsInput | string
    leido?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificacionUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipo?: StringFieldUpdateOperationsInput | string
    mensaje?: StringFieldUpdateOperationsInput | string
    leido?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificacionUncheckedUpdateManyWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipo?: StringFieldUpdateOperationsInput | string
    mensaje?: StringFieldUpdateOperationsInput | string
    leido?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Rol_permisoCreateManyRolInput = {
    id?: number
    permiso_id: number
  }

  export type UsuarioCreateManyRoleInput = {
    id?: string
    correo_electronico: string
    nombre: string
    apellido: string
    estado?: boolean
    password: string
    createdAt?: Date | string
  }

  export type Rol_permisoUpdateWithoutRolInput = {
    permiso?: PermisoUpdateOneRequiredWithoutRolesNestedInput
  }

  export type Rol_permisoUncheckedUpdateWithoutRolInput = {
    id?: IntFieldUpdateOperationsInput | number
    permiso_id?: IntFieldUpdateOperationsInput | number
  }

  export type Rol_permisoUncheckedUpdateManyWithoutRolInput = {
    id?: IntFieldUpdateOperationsInput | number
    permiso_id?: IntFieldUpdateOperationsInput | number
  }

  export type UsuarioUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    correo_electronico?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    competidor?: CompetidorUpdateOneWithoutUsuarioNestedInput
    tutor?: TutorUpdateOneWithoutUsuarioNestedInput
    Notificacion?: NotificacionUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    correo_electronico?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    competidor?: CompetidorUncheckedUpdateOneWithoutUsuarioNestedInput
    tutor?: TutorUncheckedUpdateOneWithoutUsuarioNestedInput
    Notificacion?: NotificacionUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateManyWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    correo_electronico?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Rol_permisoCreateManyPermisoInput = {
    id?: number
    rol_id: number
  }

  export type Rol_permisoUpdateWithoutPermisoInput = {
    rol?: RolUpdateOneRequiredWithoutRolesNestedInput
  }

  export type Rol_permisoUncheckedUpdateWithoutPermisoInput = {
    id?: IntFieldUpdateOperationsInput | number
    rol_id?: IntFieldUpdateOperationsInput | number
  }

  export type Rol_permisoUncheckedUpdateManyWithoutPermisoInput = {
    id?: IntFieldUpdateOperationsInput | number
    rol_id?: IntFieldUpdateOperationsInput | number
  }

  export type Inscripcion_tutorCreateManyCompetidorInput = {
    id?: number
    inscripcion_id: number
    tutor_id: string
    aprobado?: boolean
    fecha_aprobacion?: Date | string | null
    motivo_rechazo_id?: number | null
    descripcion_rechazo?: string | null
  }

  export type InscripcionCreateManyCompetidorInput = {
    id?: number
    area_id: number
    convocatoria_id: number
    categoria_id: number
    fecha_inscripcion?: Date | string
    estado_inscripcion?: string
  }

  export type Inscripcion_tutorUpdateWithoutCompetidorInput = {
    aprobado?: BoolFieldUpdateOperationsInput | boolean
    fecha_aprobacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    descripcion_rechazo?: NullableStringFieldUpdateOperationsInput | string | null
    inscripcion?: InscripcionUpdateOneRequiredWithoutTutorInscripcionesNestedInput
    tutor?: TutorUpdateOneRequiredWithoutInscripciones_tutorNestedInput
    MotivoRechazo?: Motivo_rechazoUpdateOneWithoutInscripcionesTutorNestedInput
  }

  export type Inscripcion_tutorUncheckedUpdateWithoutCompetidorInput = {
    id?: IntFieldUpdateOperationsInput | number
    inscripcion_id?: IntFieldUpdateOperationsInput | number
    tutor_id?: StringFieldUpdateOperationsInput | string
    aprobado?: BoolFieldUpdateOperationsInput | boolean
    fecha_aprobacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivo_rechazo_id?: NullableIntFieldUpdateOperationsInput | number | null
    descripcion_rechazo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Inscripcion_tutorUncheckedUpdateManyWithoutCompetidorInput = {
    id?: IntFieldUpdateOperationsInput | number
    inscripcion_id?: IntFieldUpdateOperationsInput | number
    tutor_id?: StringFieldUpdateOperationsInput | string
    aprobado?: BoolFieldUpdateOperationsInput | boolean
    fecha_aprobacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivo_rechazo_id?: NullableIntFieldUpdateOperationsInput | number | null
    descripcion_rechazo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InscripcionUpdateWithoutCompetidorInput = {
    fecha_inscripcion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado_inscripcion?: StringFieldUpdateOperationsInput | string
    tutorInscripciones?: Inscripcion_tutorUpdateManyWithoutInscripcionNestedInput
    pagos?: PagoUpdateManyWithoutInscripcionNestedInput
    area?: AreaUpdateOneRequiredWithoutInscripcionNestedInput
    convocatoria?: ConvocatoriaUpdateOneRequiredWithoutInscripcionNestedInput
    categoria?: CategoriaUpdateOneRequiredWithoutInscripcionNestedInput
  }

  export type InscripcionUncheckedUpdateWithoutCompetidorInput = {
    id?: IntFieldUpdateOperationsInput | number
    area_id?: IntFieldUpdateOperationsInput | number
    convocatoria_id?: IntFieldUpdateOperationsInput | number
    categoria_id?: IntFieldUpdateOperationsInput | number
    fecha_inscripcion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado_inscripcion?: StringFieldUpdateOperationsInput | string
    tutorInscripciones?: Inscripcion_tutorUncheckedUpdateManyWithoutInscripcionNestedInput
    pagos?: PagoUncheckedUpdateManyWithoutInscripcionNestedInput
  }

  export type InscripcionUncheckedUpdateManyWithoutCompetidorInput = {
    id?: IntFieldUpdateOperationsInput | number
    area_id?: IntFieldUpdateOperationsInput | number
    convocatoria_id?: IntFieldUpdateOperationsInput | number
    categoria_id?: IntFieldUpdateOperationsInput | number
    fecha_inscripcion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado_inscripcion?: StringFieldUpdateOperationsInput | string
  }

  export type Inscripcion_tutorCreateManyTutorInput = {
    id?: number
    inscripcion_id: number
    aprobado?: boolean
    fecha_aprobacion?: Date | string | null
    motivo_rechazo_id?: number | null
    descripcion_rechazo?: string | null
    competidorId?: string | null
  }

  export type Inscripcion_tutorUpdateWithoutTutorInput = {
    aprobado?: BoolFieldUpdateOperationsInput | boolean
    fecha_aprobacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    descripcion_rechazo?: NullableStringFieldUpdateOperationsInput | string | null
    inscripcion?: InscripcionUpdateOneRequiredWithoutTutorInscripcionesNestedInput
    Competidor?: CompetidorUpdateOneWithoutInscripcionesNestedInput
    MotivoRechazo?: Motivo_rechazoUpdateOneWithoutInscripcionesTutorNestedInput
  }

  export type Inscripcion_tutorUncheckedUpdateWithoutTutorInput = {
    id?: IntFieldUpdateOperationsInput | number
    inscripcion_id?: IntFieldUpdateOperationsInput | number
    aprobado?: BoolFieldUpdateOperationsInput | boolean
    fecha_aprobacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivo_rechazo_id?: NullableIntFieldUpdateOperationsInput | number | null
    descripcion_rechazo?: NullableStringFieldUpdateOperationsInput | string | null
    competidorId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Inscripcion_tutorUncheckedUpdateManyWithoutTutorInput = {
    id?: IntFieldUpdateOperationsInput | number
    inscripcion_id?: IntFieldUpdateOperationsInput | number
    aprobado?: BoolFieldUpdateOperationsInput | boolean
    fecha_aprobacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivo_rechazo_id?: NullableIntFieldUpdateOperationsInput | number | null
    descripcion_rechazo?: NullableStringFieldUpdateOperationsInput | string | null
    competidorId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProvinciaCreateManyDepartamentoInput = {
    id?: number
    nombre_provincia: string
  }

  export type ProvinciaUpdateWithoutDepartamentoInput = {
    nombre_provincia?: StringFieldUpdateOperationsInput | string
    Colegio?: ColegioUpdateManyWithoutProvinciaNestedInput
    Competidor?: CompetidorUpdateManyWithoutProvinciaNestedInput
  }

  export type ProvinciaUncheckedUpdateWithoutDepartamentoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre_provincia?: StringFieldUpdateOperationsInput | string
    Colegio?: ColegioUncheckedUpdateManyWithoutProvinciaNestedInput
    Competidor?: CompetidorUncheckedUpdateManyWithoutProvinciaNestedInput
  }

  export type ProvinciaUncheckedUpdateManyWithoutDepartamentoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre_provincia?: StringFieldUpdateOperationsInput | string
  }

  export type ColegioCreateManyProvinciaInput = {
    id?: number
    nombre_colegio: string
  }

  export type CompetidorCreateManyProvinciaInput = {
    id?: string
    usuario_id: string
    colegio_id: number
    carnet_identidad: string
    fecha_nacimiento: Date | string
  }

  export type ColegioUpdateWithoutProvinciaInput = {
    nombre_colegio?: StringFieldUpdateOperationsInput | string
    Competidores?: CompetidorUpdateManyWithoutColegioNestedInput
  }

  export type ColegioUncheckedUpdateWithoutProvinciaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre_colegio?: StringFieldUpdateOperationsInput | string
    Competidores?: CompetidorUncheckedUpdateManyWithoutColegioNestedInput
  }

  export type ColegioUncheckedUpdateManyWithoutProvinciaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre_colegio?: StringFieldUpdateOperationsInput | string
  }

  export type CompetidorUpdateWithoutProvinciaInput = {
    id?: StringFieldUpdateOperationsInput | string
    carnet_identidad?: StringFieldUpdateOperationsInput | string
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    colegio?: ColegioUpdateOneRequiredWithoutCompetidoresNestedInput
    usuario?: UsuarioUpdateOneRequiredWithoutCompetidorNestedInput
    Inscripciones?: Inscripcion_tutorUpdateManyWithoutCompetidorNestedInput
    Inscripcion?: InscripcionUpdateManyWithoutCompetidorNestedInput
  }

  export type CompetidorUncheckedUpdateWithoutProvinciaInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuario_id?: StringFieldUpdateOperationsInput | string
    colegio_id?: IntFieldUpdateOperationsInput | number
    carnet_identidad?: StringFieldUpdateOperationsInput | string
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    Inscripciones?: Inscripcion_tutorUncheckedUpdateManyWithoutCompetidorNestedInput
    Inscripcion?: InscripcionUncheckedUpdateManyWithoutCompetidorNestedInput
  }

  export type CompetidorUncheckedUpdateManyWithoutProvinciaInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuario_id?: StringFieldUpdateOperationsInput | string
    colegio_id?: IntFieldUpdateOperationsInput | number
    carnet_identidad?: StringFieldUpdateOperationsInput | string
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompetidorCreateManyColegioInput = {
    id?: string
    usuario_id: string
    provincia_id: number
    carnet_identidad: string
    fecha_nacimiento: Date | string
  }

  export type CompetidorUpdateWithoutColegioInput = {
    id?: StringFieldUpdateOperationsInput | string
    carnet_identidad?: StringFieldUpdateOperationsInput | string
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    provincia?: ProvinciaUpdateOneRequiredWithoutCompetidorNestedInput
    usuario?: UsuarioUpdateOneRequiredWithoutCompetidorNestedInput
    Inscripciones?: Inscripcion_tutorUpdateManyWithoutCompetidorNestedInput
    Inscripcion?: InscripcionUpdateManyWithoutCompetidorNestedInput
  }

  export type CompetidorUncheckedUpdateWithoutColegioInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuario_id?: StringFieldUpdateOperationsInput | string
    provincia_id?: IntFieldUpdateOperationsInput | number
    carnet_identidad?: StringFieldUpdateOperationsInput | string
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    Inscripciones?: Inscripcion_tutorUncheckedUpdateManyWithoutCompetidorNestedInput
    Inscripcion?: InscripcionUncheckedUpdateManyWithoutCompetidorNestedInput
  }

  export type CompetidorUncheckedUpdateManyWithoutColegioInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuario_id?: StringFieldUpdateOperationsInput | string
    provincia_id?: IntFieldUpdateOperationsInput | number
    carnet_identidad?: StringFieldUpdateOperationsInput | string
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Area_convocatoriaCreateManyConvocatoriaInput = {
    id?: number
    area_id: number
  }

  export type InscripcionCreateManyConvocatoriaInput = {
    id?: number
    competidor_id: string
    area_id: number
    categoria_id: number
    fecha_inscripcion?: Date | string
    estado_inscripcion?: string
  }

  export type Area_convocatoriaUpdateWithoutConvocatoriaInput = {
    area?: AreaUpdateOneRequiredWithoutArea_convocatoriaNestedInput
  }

  export type Area_convocatoriaUncheckedUpdateWithoutConvocatoriaInput = {
    id?: IntFieldUpdateOperationsInput | number
    area_id?: IntFieldUpdateOperationsInput | number
  }

  export type Area_convocatoriaUncheckedUpdateManyWithoutConvocatoriaInput = {
    id?: IntFieldUpdateOperationsInput | number
    area_id?: IntFieldUpdateOperationsInput | number
  }

  export type InscripcionUpdateWithoutConvocatoriaInput = {
    fecha_inscripcion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado_inscripcion?: StringFieldUpdateOperationsInput | string
    tutorInscripciones?: Inscripcion_tutorUpdateManyWithoutInscripcionNestedInput
    pagos?: PagoUpdateManyWithoutInscripcionNestedInput
    competidor?: CompetidorUpdateOneRequiredWithoutInscripcionNestedInput
    area?: AreaUpdateOneRequiredWithoutInscripcionNestedInput
    categoria?: CategoriaUpdateOneRequiredWithoutInscripcionNestedInput
  }

  export type InscripcionUncheckedUpdateWithoutConvocatoriaInput = {
    id?: IntFieldUpdateOperationsInput | number
    competidor_id?: StringFieldUpdateOperationsInput | string
    area_id?: IntFieldUpdateOperationsInput | number
    categoria_id?: IntFieldUpdateOperationsInput | number
    fecha_inscripcion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado_inscripcion?: StringFieldUpdateOperationsInput | string
    tutorInscripciones?: Inscripcion_tutorUncheckedUpdateManyWithoutInscripcionNestedInput
    pagos?: PagoUncheckedUpdateManyWithoutInscripcionNestedInput
  }

  export type InscripcionUncheckedUpdateManyWithoutConvocatoriaInput = {
    id?: IntFieldUpdateOperationsInput | number
    competidor_id?: StringFieldUpdateOperationsInput | string
    area_id?: IntFieldUpdateOperationsInput | number
    categoria_id?: IntFieldUpdateOperationsInput | number
    fecha_inscripcion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado_inscripcion?: StringFieldUpdateOperationsInput | string
  }

  export type Area_convocatoriaCreateManyAreaInput = {
    id?: number
    convocatoria_id: number
  }

  export type Categoria_areaCreateManyAreaInput = {
    id?: number
    categoria_id: number
  }

  export type TutorCreateManyAreaInput = {
    id?: string
    usuario_id: string
    carnet_identidad: string
    numero_celular: string
  }

  export type InscripcionCreateManyAreaInput = {
    id?: number
    competidor_id: string
    convocatoria_id: number
    categoria_id: number
    fecha_inscripcion?: Date | string
    estado_inscripcion?: string
  }

  export type Area_convocatoriaUpdateWithoutAreaInput = {
    convocatoria?: ConvocatoriaUpdateOneRequiredWithoutArea_convocatoriaNestedInput
  }

  export type Area_convocatoriaUncheckedUpdateWithoutAreaInput = {
    id?: IntFieldUpdateOperationsInput | number
    convocatoria_id?: IntFieldUpdateOperationsInput | number
  }

  export type Area_convocatoriaUncheckedUpdateManyWithoutAreaInput = {
    id?: IntFieldUpdateOperationsInput | number
    convocatoria_id?: IntFieldUpdateOperationsInput | number
  }

  export type Categoria_areaUpdateWithoutAreaInput = {
    categoria?: CategoriaUpdateOneRequiredWithoutCategoria_convocatoriaNestedInput
  }

  export type Categoria_areaUncheckedUpdateWithoutAreaInput = {
    id?: IntFieldUpdateOperationsInput | number
    categoria_id?: IntFieldUpdateOperationsInput | number
  }

  export type Categoria_areaUncheckedUpdateManyWithoutAreaInput = {
    id?: IntFieldUpdateOperationsInput | number
    categoria_id?: IntFieldUpdateOperationsInput | number
  }

  export type TutorUpdateWithoutAreaInput = {
    id?: StringFieldUpdateOperationsInput | string
    carnet_identidad?: StringFieldUpdateOperationsInput | string
    numero_celular?: StringFieldUpdateOperationsInput | string
    Inscripciones_tutor?: Inscripcion_tutorUpdateManyWithoutTutorNestedInput
    usuario?: UsuarioUpdateOneRequiredWithoutTutorNestedInput
  }

  export type TutorUncheckedUpdateWithoutAreaInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuario_id?: StringFieldUpdateOperationsInput | string
    carnet_identidad?: StringFieldUpdateOperationsInput | string
    numero_celular?: StringFieldUpdateOperationsInput | string
    Inscripciones_tutor?: Inscripcion_tutorUncheckedUpdateManyWithoutTutorNestedInput
  }

  export type TutorUncheckedUpdateManyWithoutAreaInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuario_id?: StringFieldUpdateOperationsInput | string
    carnet_identidad?: StringFieldUpdateOperationsInput | string
    numero_celular?: StringFieldUpdateOperationsInput | string
  }

  export type InscripcionUpdateWithoutAreaInput = {
    fecha_inscripcion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado_inscripcion?: StringFieldUpdateOperationsInput | string
    tutorInscripciones?: Inscripcion_tutorUpdateManyWithoutInscripcionNestedInput
    pagos?: PagoUpdateManyWithoutInscripcionNestedInput
    competidor?: CompetidorUpdateOneRequiredWithoutInscripcionNestedInput
    convocatoria?: ConvocatoriaUpdateOneRequiredWithoutInscripcionNestedInput
    categoria?: CategoriaUpdateOneRequiredWithoutInscripcionNestedInput
  }

  export type InscripcionUncheckedUpdateWithoutAreaInput = {
    id?: IntFieldUpdateOperationsInput | number
    competidor_id?: StringFieldUpdateOperationsInput | string
    convocatoria_id?: IntFieldUpdateOperationsInput | number
    categoria_id?: IntFieldUpdateOperationsInput | number
    fecha_inscripcion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado_inscripcion?: StringFieldUpdateOperationsInput | string
    tutorInscripciones?: Inscripcion_tutorUncheckedUpdateManyWithoutInscripcionNestedInput
    pagos?: PagoUncheckedUpdateManyWithoutInscripcionNestedInput
  }

  export type InscripcionUncheckedUpdateManyWithoutAreaInput = {
    id?: IntFieldUpdateOperationsInput | number
    competidor_id?: StringFieldUpdateOperationsInput | string
    convocatoria_id?: IntFieldUpdateOperationsInput | number
    categoria_id?: IntFieldUpdateOperationsInput | number
    fecha_inscripcion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado_inscripcion?: StringFieldUpdateOperationsInput | string
  }

  export type Categoria_areaCreateManyCategoriaInput = {
    id?: number
    area_id: number
  }

  export type InscripcionCreateManyCategoriaInput = {
    id?: number
    competidor_id: string
    area_id: number
    convocatoria_id: number
    fecha_inscripcion?: Date | string
    estado_inscripcion?: string
  }

  export type Categoria_areaUpdateWithoutCategoriaInput = {
    area?: AreaUpdateOneRequiredWithoutArea_categoriaNestedInput
  }

  export type Categoria_areaUncheckedUpdateWithoutCategoriaInput = {
    id?: IntFieldUpdateOperationsInput | number
    area_id?: IntFieldUpdateOperationsInput | number
  }

  export type Categoria_areaUncheckedUpdateManyWithoutCategoriaInput = {
    id?: IntFieldUpdateOperationsInput | number
    area_id?: IntFieldUpdateOperationsInput | number
  }

  export type InscripcionUpdateWithoutCategoriaInput = {
    fecha_inscripcion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado_inscripcion?: StringFieldUpdateOperationsInput | string
    tutorInscripciones?: Inscripcion_tutorUpdateManyWithoutInscripcionNestedInput
    pagos?: PagoUpdateManyWithoutInscripcionNestedInput
    competidor?: CompetidorUpdateOneRequiredWithoutInscripcionNestedInput
    area?: AreaUpdateOneRequiredWithoutInscripcionNestedInput
    convocatoria?: ConvocatoriaUpdateOneRequiredWithoutInscripcionNestedInput
  }

  export type InscripcionUncheckedUpdateWithoutCategoriaInput = {
    id?: IntFieldUpdateOperationsInput | number
    competidor_id?: StringFieldUpdateOperationsInput | string
    area_id?: IntFieldUpdateOperationsInput | number
    convocatoria_id?: IntFieldUpdateOperationsInput | number
    fecha_inscripcion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado_inscripcion?: StringFieldUpdateOperationsInput | string
    tutorInscripciones?: Inscripcion_tutorUncheckedUpdateManyWithoutInscripcionNestedInput
    pagos?: PagoUncheckedUpdateManyWithoutInscripcionNestedInput
  }

  export type InscripcionUncheckedUpdateManyWithoutCategoriaInput = {
    id?: IntFieldUpdateOperationsInput | number
    competidor_id?: StringFieldUpdateOperationsInput | string
    area_id?: IntFieldUpdateOperationsInput | number
    convocatoria_id?: IntFieldUpdateOperationsInput | number
    fecha_inscripcion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado_inscripcion?: StringFieldUpdateOperationsInput | string
  }

  export type CategoriaCreateManyGrado_maxInput = {
    id?: number
    nombre_categoria: string
    grado_min_id: number
    descripcion_cat: string
  }

  export type CategoriaCreateManyGrado_minInput = {
    id?: number
    nombre_categoria: string
    grado_max_id: number
    descripcion_cat: string
  }

  export type CategoriaUpdateWithoutGrado_maxInput = {
    nombre_categoria?: StringFieldUpdateOperationsInput | string
    descripcion_cat?: StringFieldUpdateOperationsInput | string
    grado_min?: GradoUpdateOneRequiredWithoutCategorias_minNestedInput
    Categoria_convocatoria?: Categoria_areaUpdateManyWithoutCategoriaNestedInput
    Inscripcion?: InscripcionUpdateManyWithoutCategoriaNestedInput
  }

  export type CategoriaUncheckedUpdateWithoutGrado_maxInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre_categoria?: StringFieldUpdateOperationsInput | string
    grado_min_id?: IntFieldUpdateOperationsInput | number
    descripcion_cat?: StringFieldUpdateOperationsInput | string
    Categoria_convocatoria?: Categoria_areaUncheckedUpdateManyWithoutCategoriaNestedInput
    Inscripcion?: InscripcionUncheckedUpdateManyWithoutCategoriaNestedInput
  }

  export type CategoriaUncheckedUpdateManyWithoutGrado_maxInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre_categoria?: StringFieldUpdateOperationsInput | string
    grado_min_id?: IntFieldUpdateOperationsInput | number
    descripcion_cat?: StringFieldUpdateOperationsInput | string
  }

  export type CategoriaUpdateWithoutGrado_minInput = {
    nombre_categoria?: StringFieldUpdateOperationsInput | string
    descripcion_cat?: StringFieldUpdateOperationsInput | string
    grado_max?: GradoUpdateOneRequiredWithoutCategorias_maxNestedInput
    Categoria_convocatoria?: Categoria_areaUpdateManyWithoutCategoriaNestedInput
    Inscripcion?: InscripcionUpdateManyWithoutCategoriaNestedInput
  }

  export type CategoriaUncheckedUpdateWithoutGrado_minInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre_categoria?: StringFieldUpdateOperationsInput | string
    grado_max_id?: IntFieldUpdateOperationsInput | number
    descripcion_cat?: StringFieldUpdateOperationsInput | string
    Categoria_convocatoria?: Categoria_areaUncheckedUpdateManyWithoutCategoriaNestedInput
    Inscripcion?: InscripcionUncheckedUpdateManyWithoutCategoriaNestedInput
  }

  export type CategoriaUncheckedUpdateManyWithoutGrado_minInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre_categoria?: StringFieldUpdateOperationsInput | string
    grado_max_id?: IntFieldUpdateOperationsInput | number
    descripcion_cat?: StringFieldUpdateOperationsInput | string
  }

  export type PagoCreateManyMetodo_pagoInput = {
    id?: number
    inscripcion_id: number
    monto: Decimal | DecimalJsLike | number | string
    estado?: string
    codigo_pago: string
    fecha_pago?: Date | string
  }

  export type PagoUpdateWithoutMetodo_pagoInput = {
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: StringFieldUpdateOperationsInput | string
    codigo_pago?: StringFieldUpdateOperationsInput | string
    fecha_pago?: DateTimeFieldUpdateOperationsInput | Date | string
    inscripcion?: InscripcionUpdateOneRequiredWithoutPagosNestedInput
  }

  export type PagoUncheckedUpdateWithoutMetodo_pagoInput = {
    id?: IntFieldUpdateOperationsInput | number
    inscripcion_id?: IntFieldUpdateOperationsInput | number
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: StringFieldUpdateOperationsInput | string
    codigo_pago?: StringFieldUpdateOperationsInput | string
    fecha_pago?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PagoUncheckedUpdateManyWithoutMetodo_pagoInput = {
    id?: IntFieldUpdateOperationsInput | number
    inscripcion_id?: IntFieldUpdateOperationsInput | number
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: StringFieldUpdateOperationsInput | string
    codigo_pago?: StringFieldUpdateOperationsInput | string
    fecha_pago?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConvocatoriaCreateManyEstado_convocatoriaInput = {
    id?: number
    nombre_convocatoria: string
    fecha_inicio: Date | string
    fecha_fin: Date | string
    pago_fin: Date | string
    pago_inicio: Date | string
    competicion_inicio: Date | string
    competicion_fin: Date | string
    descripcion_convocatoria: string
  }

  export type ConvocatoriaUpdateWithoutEstado_convocatoriaInput = {
    nombre_convocatoria?: StringFieldUpdateOperationsInput | string
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    pago_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    pago_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    competicion_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    competicion_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    descripcion_convocatoria?: StringFieldUpdateOperationsInput | string
    Area_convocatoria?: Area_convocatoriaUpdateManyWithoutConvocatoriaNestedInput
    Inscripcion?: InscripcionUpdateManyWithoutConvocatoriaNestedInput
  }

  export type ConvocatoriaUncheckedUpdateWithoutEstado_convocatoriaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre_convocatoria?: StringFieldUpdateOperationsInput | string
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    pago_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    pago_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    competicion_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    competicion_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    descripcion_convocatoria?: StringFieldUpdateOperationsInput | string
    Area_convocatoria?: Area_convocatoriaUncheckedUpdateManyWithoutConvocatoriaNestedInput
    Inscripcion?: InscripcionUncheckedUpdateManyWithoutConvocatoriaNestedInput
  }

  export type ConvocatoriaUncheckedUpdateManyWithoutEstado_convocatoriaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre_convocatoria?: StringFieldUpdateOperationsInput | string
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    pago_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    pago_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    competicion_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    competicion_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    descripcion_convocatoria?: StringFieldUpdateOperationsInput | string
  }

  export type Inscripcion_tutorCreateManyInscripcionInput = {
    id?: number
    tutor_id: string
    aprobado?: boolean
    fecha_aprobacion?: Date | string | null
    motivo_rechazo_id?: number | null
    descripcion_rechazo?: string | null
    competidorId?: string | null
  }

  export type PagoCreateManyInscripcionInput = {
    id?: number
    monto: Decimal | DecimalJsLike | number | string
    estado?: string
    codigo_pago: string
    fecha_pago?: Date | string
    metodo_pago_id: number
  }

  export type Inscripcion_tutorUpdateWithoutInscripcionInput = {
    aprobado?: BoolFieldUpdateOperationsInput | boolean
    fecha_aprobacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    descripcion_rechazo?: NullableStringFieldUpdateOperationsInput | string | null
    tutor?: TutorUpdateOneRequiredWithoutInscripciones_tutorNestedInput
    Competidor?: CompetidorUpdateOneWithoutInscripcionesNestedInput
    MotivoRechazo?: Motivo_rechazoUpdateOneWithoutInscripcionesTutorNestedInput
  }

  export type Inscripcion_tutorUncheckedUpdateWithoutInscripcionInput = {
    id?: IntFieldUpdateOperationsInput | number
    tutor_id?: StringFieldUpdateOperationsInput | string
    aprobado?: BoolFieldUpdateOperationsInput | boolean
    fecha_aprobacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivo_rechazo_id?: NullableIntFieldUpdateOperationsInput | number | null
    descripcion_rechazo?: NullableStringFieldUpdateOperationsInput | string | null
    competidorId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Inscripcion_tutorUncheckedUpdateManyWithoutInscripcionInput = {
    id?: IntFieldUpdateOperationsInput | number
    tutor_id?: StringFieldUpdateOperationsInput | string
    aprobado?: BoolFieldUpdateOperationsInput | boolean
    fecha_aprobacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivo_rechazo_id?: NullableIntFieldUpdateOperationsInput | number | null
    descripcion_rechazo?: NullableStringFieldUpdateOperationsInput | string | null
    competidorId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PagoUpdateWithoutInscripcionInput = {
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: StringFieldUpdateOperationsInput | string
    codigo_pago?: StringFieldUpdateOperationsInput | string
    fecha_pago?: DateTimeFieldUpdateOperationsInput | Date | string
    metodo_pago?: Metodo_pagoUpdateOneRequiredWithoutPagoNestedInput
  }

  export type PagoUncheckedUpdateWithoutInscripcionInput = {
    id?: IntFieldUpdateOperationsInput | number
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: StringFieldUpdateOperationsInput | string
    codigo_pago?: StringFieldUpdateOperationsInput | string
    fecha_pago?: DateTimeFieldUpdateOperationsInput | Date | string
    metodo_pago_id?: IntFieldUpdateOperationsInput | number
  }

  export type PagoUncheckedUpdateManyWithoutInscripcionInput = {
    id?: IntFieldUpdateOperationsInput | number
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado?: StringFieldUpdateOperationsInput | string
    codigo_pago?: StringFieldUpdateOperationsInput | string
    fecha_pago?: DateTimeFieldUpdateOperationsInput | Date | string
    metodo_pago_id?: IntFieldUpdateOperationsInput | number
  }

  export type GradoCreateManyNivelInput = {
    id?: number
    nombre_grado: string
  }

  export type GradoUpdateWithoutNivelInput = {
    nombre_grado?: StringFieldUpdateOperationsInput | string
    categorias_max?: CategoriaUpdateManyWithoutGrado_maxNestedInput
    categorias_min?: CategoriaUpdateManyWithoutGrado_minNestedInput
  }

  export type GradoUncheckedUpdateWithoutNivelInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre_grado?: StringFieldUpdateOperationsInput | string
    categorias_max?: CategoriaUncheckedUpdateManyWithoutGrado_maxNestedInput
    categorias_min?: CategoriaUncheckedUpdateManyWithoutGrado_minNestedInput
  }

  export type GradoUncheckedUpdateManyWithoutNivelInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre_grado?: StringFieldUpdateOperationsInput | string
  }

  export type Inscripcion_tutorCreateManyMotivoRechazoInput = {
    id?: number
    inscripcion_id: number
    tutor_id: string
    aprobado?: boolean
    fecha_aprobacion?: Date | string | null
    descripcion_rechazo?: string | null
    competidorId?: string | null
  }

  export type Inscripcion_tutorUpdateWithoutMotivoRechazoInput = {
    aprobado?: BoolFieldUpdateOperationsInput | boolean
    fecha_aprobacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    descripcion_rechazo?: NullableStringFieldUpdateOperationsInput | string | null
    inscripcion?: InscripcionUpdateOneRequiredWithoutTutorInscripcionesNestedInput
    tutor?: TutorUpdateOneRequiredWithoutInscripciones_tutorNestedInput
    Competidor?: CompetidorUpdateOneWithoutInscripcionesNestedInput
  }

  export type Inscripcion_tutorUncheckedUpdateWithoutMotivoRechazoInput = {
    id?: IntFieldUpdateOperationsInput | number
    inscripcion_id?: IntFieldUpdateOperationsInput | number
    tutor_id?: StringFieldUpdateOperationsInput | string
    aprobado?: BoolFieldUpdateOperationsInput | boolean
    fecha_aprobacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    descripcion_rechazo?: NullableStringFieldUpdateOperationsInput | string | null
    competidorId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Inscripcion_tutorUncheckedUpdateManyWithoutMotivoRechazoInput = {
    id?: IntFieldUpdateOperationsInput | number
    inscripcion_id?: IntFieldUpdateOperationsInput | number
    tutor_id?: StringFieldUpdateOperationsInput | string
    aprobado?: BoolFieldUpdateOperationsInput | boolean
    fecha_aprobacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    descripcion_rechazo?: NullableStringFieldUpdateOperationsInput | string | null
    competidorId?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}